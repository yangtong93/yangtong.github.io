<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Think Different</title>
    <url>/yangtong.github.io/2023/07/11/thinkdifferent/</url>
    <content><![CDATA[<p><img src="/yangtong.github.io/images/greatpeople.jpg"></p>
<blockquote>
<p>“Here’s to the crazy ones. The misfits. The rebels. The troublemakers. The round pegs in the square holes. The ones who see things differently. They’re not fond of rules. And they have no respect for the status quo. You can quote them, disagree with them, glorify or vilify them. About the only thing you can’t do is ignore them. Because they change things. They push the human race forward. And while some may see them as the crazy ones, we see genius. Because the people who are crazy enough to think they can change the world are the ones who do.”</br><center>— Apple’s “Think Different” commercial, 1997</center></p>
</blockquote>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/radix/</url>
    <content><![CDATA[<p>基数排序（Radix Sort）是一种非比较性的排序算法，它基于元素的每个位进行排序。其基本思想是将待排序的数字按照低位到高位的顺序进行多次分配和收集，最终完成排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序的数字从最低位开始，按照当前位的值进行分桶（也可以理解为分配）。</li>
<li>收集各个桶中的数字，按照桶的顺序依次放回原数组。</li>
<li>重复步骤1和步骤2，直到所有位都被处理完毕。</li>
</ol>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>基数排序（Radix Sort）是一种非比较型的排序算法，它将待排序序列按照每个元素的位数进行分组，然后依次对每个位上的数字进行排序。基数排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：基数排序的时间复杂度是O(d * (n + k))，其中d是最大元素的位数，n是待排序序列的长度，k是进制数。基数排序需要对每个元素的每个位进行排序，因此需要进行d轮排序操作。在每轮排序中，需要对n个元素进行计数和重排，以及对k个可能的取值进行遍历。因此总体时间复杂度为O(d * (n + k))。</p>
<p>空间复杂度：基数排序的空间复杂度是O(n + k)，其中n是待排序序列的长度，k是进制数。基数排序需要使用一个辅助数组来存储每次排序过程中的临时结果，其大小与输入序列的长度相同。另外，还需要使用一个计数数组来记录每个数字出现的次数，其大小取决于进制数k。因此总体空间复杂度为O(n + k)。</p>
<p>稳定性：基数排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在基数排序中，每一轮按位排序将相等的元素放入相同的桶中，并且桶的顺序不会改变，因此相等元素的相对顺序保持不变。</p>
<p>需要注意的是，基数排序的效率受到最大元素位数d和进制数k的影响。当d较大时，基数排序可能不如其他排序算法（如快速排序、归并排序）高效。而且，基数排序适用于待排序元素可以分解为多个关键字进行排序的情况，例如十进制数的各个位。在实际应用中，要根据具体情况选择合适的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>基数排序（Radix Sort）是一种非比较型的排序算法，它根据数字的每个位上的值进行排序。基数排序适用于非负整数或字符串的排序。以下是基数排序的详细步骤：</p>
<ol>
<li><p><strong>确定最大位数</strong>：确定待排序元素中最大值的位数，并记为<code>max_digits</code>。</p>
</li>
<li><p><strong>按位排序</strong>：从最低有效位到最高有效位，依次对待排序的元素进行排序。</p>
<ul>
<li>对于每一位，使用稳定的排序算法（如计数排序或桶排序）对当前位进行排序。</li>
</ul>
</li>
<li><p><strong>重复排序</strong>：重复执行第2步，直到对所有位都进行了排序。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是基数排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 获取数组中元素的最大值</span>
<span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用计数排序对数组按照指定位进行排序（根据 LSD 方式）</span>
<span class="token keyword">void</span> <span class="token function">countSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> output<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储排序后的结果</span>
    <span class="token keyword">int</span> count<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 存储每个数字的出现次数</span>

    <span class="token comment">// 统计当前位数字的出现次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 计算累加次数，得到每个数字在输出数组中的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 根据统计信息将数字放置在输出数组中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        output<span class="token punctuation">[</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将排序后的结果拷贝回原数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 基数排序函数</span>
<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取数组中的最大值</span>

    <span class="token comment">// 从个位开始，对每一位进行计数排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> max <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">countSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们实现了一个<code>getMax</code>函数用于获取数组中的最大值，以及一个<code>countSort</code>函数来对数组按照指定位进行排序（使用LSD方式）。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>radixSort</code>函数对其进行基数排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，基数排序成功地将数组元素从小到大进行了排序。请注意，这只是基数排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>基数排序适用于以下一些应用场景：</p>
<ol>
<li><p><strong>非负整数的排序</strong>：基数排序最初是针对非负整数进行排序的。它通过按照数字的每个位上的值进行排序，可以高效地对非负整数序列进行排序。</p>
</li>
<li><p><strong>字符串的排序</strong>：由于字符串可以看作由字符组成的非负整数，因此基数排序也可以用于对字符串进行排序。按照字符的ASCII码或Unicode编码的每个位上的值进行排序，可以得到按字母顺序排列的字符串序列。</p>
</li>
<li><p><strong>固定长度的数据排序</strong>：当待排序的数据都具有固定的位数时，基数排序可以发挥其优势。例如，对于一个固定为8位的社会安全号码或学生学号的排序任务，可以使用基数排序来快速完成。</p>
</li>
<li><p><strong>稳定排序要求</strong>：基数排序是一种稳定的排序算法，即能够保持相等元素之间的相对顺序不变。如果对排序结果需要保持稳定性，基数排序是一个很好的选择。</p>
</li>
</ol>
<p>需要注意的是，基数排序对于具有较大位数的数据集可能需要更多的时间和空间。另外，基数排序只适用于非负整数或字符串的排序，对于包含负整数或其他类型的数据，需要先进行转换才能使用基数排序。</p>
<p>综上所述，基数排序在非负整数和字符串的排序、固定长度数据的排序以及对稳定性有要求的场景中具有优势。但在特定情况下，也可以根据实际需求选择其他排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>基数排序已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>使用桶排序替代计数排序：在基数排序中，每一位上的排序通常使用计数排序。如果待排序元素的范围较大，可以考虑使用桶排序来代替计数排序。对于每一位数字，将待排序元素分配到多个不同的桶中，然后对每个桶进行排序。这样可以减少计数数组的大小和遍历次数，提高性能。</p>
</li>
<li><p>选择合适的进制数：基数排序中的进制数k决定了每一位上可能的取值范围。选择合适的进制数可以减少每一轮排序所需的操作次数。一般来说，进制数与待排序元素范围的关系为k &#x3D; O(n)或者k &#x3D; O(log n)，其中n是待排序序列的长度。</p>
</li>
<li><p>考虑使用最低有效位（LSB）优先的排序：基数排序可以按照从高位到低位或从低位到高位的顺序进行排序。当待排序元素的位数较多时，考虑使用最低有效位（LSB）优先的排序，可以减少排序过程中元素的移动次数。</p>
</li>
<li><p>结合其他排序算法进行优化：在实际应用中，可以结合其他排序算法进行优化。例如，可以在基数排序的每一位上应用插入排序或快速排序来替代计数排序，当待排序序列长度较小的时候，这样可以提高排序效率。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升基数排序的性能。然而，需要注意的是，基数排序对数据的特定要求较高，适用于特定场景下。在面对大规模数据集时，其他排序算法（如快速排序、归并排序）可能更常用和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/merge/</url>
    <content><![CDATA[<p>归并排序（Merge Sort）是一种高效的排序算法，基于分治策略。其基本思想是将待排序序列递归地拆分成两个子序列，然后对这两个子序列进行排序，并将排序结果合并成一个有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序序列递归地拆分成更小的子序列，直到每个子序列只有一个元素。</li>
<li>对相邻的两个子序列进行合并，得到一个有序的更大的子序列。</li>
<li>不断重复步骤2，直到最终合并成一个完整的有序序列。</li>
</ol>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>归并排序（Merge Sort）是一种基于分治策略的排序算法，它将待排序序列划分为较小的子序列，然后逐步合并这些子序列来实现排序。归并排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：归并排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。归并排序的关键操作是合并两个有序序列，合并操作需要O(n)的时间复杂度，而每次递归划分序列的过程需要进行O(log n)次，因此总体时间复杂度为O(n log n)。</p>
<p>空间复杂度：归并排序的空间复杂度是O(n)，其中n是待排序序列的长度。归并排序需要额外的空间来存储临时数组，在合并过程中会对原始数组进行拷贝。在最差情况下，需要额外的O(n)空间来存储临时数组。</p>
<p>稳定性：归并排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在归并排序中，当合并两个有序序列时，如果遇到相等的元素，先从前一个有序序列中取出，可以保持相等元素的相对顺序不变。</p>
<p>归并排序具有较好的时间复杂度和稳定性，但其空间复杂度较高，需要额外的存储空间。然而，在实际应用中，由于归并排序的稳定性和分治特性，它常被用于需要稳定排序的场景或者对内存占用不敏感的情况下。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>归并排序（Merge Sort）是一种基于分治法的排序算法，它将待排序的数组不断划分为更小的子数组，然后通过合并操作将子数组排序，从而得到最终有序的数组。以下是归并排序的详细步骤：</p>
<ol>
<li><p><strong>划分</strong>：将待排序的数组递归地划分为更小的子数组，直到每个子数组只包含一个元素。</p>
</li>
<li><p><strong>合并</strong>：对于每一对相邻的子数组，使用合并操作将它们合并为一个有序的较大数组。重复这个过程，直到所有子数组合并成一个完整的有序数组。</p>
</li>
</ol>
<p>具体步骤如下：</p>
<ul>
<li><p><strong>划分过程</strong>：</p>
<ul>
<li>将待排序的数组划分为两个子数组，分别是左子数组和右子数组。</li>
<li>递归地对左右子数组进行划分，直到每个子数组只包含一个元素（递归的终止条件）。</li>
</ul>
</li>
<li><p><strong>合并过程</strong>：</p>
<ul>
<li>创建一个临时数组来存储合并后的结果。</li>
<li>通过比较左右子数组的第一个元素，选择较小（或较大）的元素放入临时数组中。</li>
<li>若一个子数组的所有元素都已被放入临时数组，则将另一个子数组中剩余的元素依次放入临时数组。</li>
<li>将临时数组中的元素复制回原始数组对应的位置，完成一次合并操作。</li>
</ul>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是归并排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 合并两个有序子数组</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左子数组的大小</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>    <span class="token comment">// 右子数组的大小</span>

    <span class="token keyword">int</span> L<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">,</span> R<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 创建临时数组来存储左右子数组的元素</span>

    <span class="token comment">// 拷贝数据到临时数组 L[] 和 R[]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 归并临时数组到原数组 arr[]</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 左子数组的索引</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 右子数组的索引</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment">// 合并后的数组的索引</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 拷贝剩余的元素（如果有）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 归并排序函数</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">// 分割数组并递归地对子数组进行排序</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 合并已经排序的子数组</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>merge</code>函数来合并两个有序子数组，并实现了<code>mergeSort</code>函数来进行归并排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>mergeSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，归并排序成功地将数组元素从小到大进行了排序。请注意，这只是归并排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>归并排序是一种高效的排序算法，适用于多种应用场景。以下是一些适合使用归并排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：归并排序具有稳定的时间复杂度O(n log n)，在平均和最坏情况下都表现良好。因此，对于大规模数据集的排序任务，归并排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相较于其他高效的排序算法（如快速排序），归并排序是一种稳定的排序算法，即能够保持相等元素之间的相对顺序不变。如果对稳定性有要求，归并排序是一个很好的选择。</p>
</li>
<li><p><strong>外部排序</strong>：归并排序天生适用于外部排序，其中待排序的数据无法全部加载到内存中。通过将大文件划分为多个小块，并对每个小块进行排序，然后合并这些有序的小块，可以有效地实现外部排序。</p>
</li>
<li><p><strong>链表排序</strong>：对于链表结构而言，归并排序是一种自然而然的选择。由于归并排序的合并操作只涉及指针的重新连接，而不需要实际的元素移动，因此可以很容易地对链表进行排序。</p>
</li>
</ol>
<p>需要注意的是，归并排序虽然具有较好的性能，但它的空间复杂度较高，需要额外的存储空间来存储临时数组。在内存受限的环境下，可能不适合使用归并排序。</p>
<p>综上所述，归并排序在大规模数据集、需要稳定性、外部排序和链表排序等场景中具有优势。但在特定情况下，也可以根据实际需求选择其他排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>归并排序本身已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>优化合并操作：在归并排序中，合并操作是关键步骤。可以通过使用辅助数组，在合并过程中减少数据拷贝的次数。一种常见的优化方式是在合并过程中先将数据拷贝到辅助数组中，然后再进行合并，而不是每次合并都创建新的临时数组。</p>
</li>
<li><p>针对小规模子序列使用插入排序：对于小规模的子序列，归并排序的性能可能被插入排序所超越。可以通过设置一个阈值，在递归划分到达该阈值时，改用插入排序来处理，从而提高性能。</p>
</li>
<li><p>自底向上的归并排序：传统的归并排序采用自顶向下的递归方式，可以尝试使用自底向上的迭代方式进行归并排序。自底向上的归并排序先将待排序序列划分为若干个长度为1的子序列，然后两两合并，并依次增加子序列的长度，直至整个序列有序。</p>
</li>
<li><p>使用循环内合并：在原始的归并排序中，每次合并操作需要递归调用自身。可以将合并操作放在循环内部，减少递归调用的次数，从而提高性能。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升归并排序的性能。然而，需要注意的是，在大规模数据集或者对内存占用敏感的情况下，其他算法（如快速排序）可能更为常用和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/heap/</url>
    <content><![CDATA[<p>堆排序（Heap Sort）是一种高效的排序算法，基于二叉堆数据结构。其基本思想是将待排序序列看作是一棵完全二叉树，并利用堆的性质进行排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是堆排序的算法原理：</p>
<ol>
<li>构建初始堆：将待排序序列构建成一个最大堆（或最小堆）。最大堆要求父节点的值大于等于子节点的值，最小堆要求父节点的值小于等于子节点的值。</li>
<li>将堆顶元素与末尾元素交换位置，并将末尾元素固定为已排序部分。</li>
<li>对剩余的未排序部分重新构建堆。</li>
<li>重复步骤2和步骤3，直到所有元素都排序完成。</li>
</ol>
<p>堆排序利用了堆的特性，在每一轮中选择堆顶元素（最大值或最小值），并将其放置在已排序部分的末尾。然后，重新构建堆来处理剩余的未排序部分。需要执行n-1轮排序操作，其中n为待排序元素的个数。堆排序的时间复杂度为O(n log n)。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的排序算法，它通过构建最大堆或最小堆，并依次将堆顶元素与末尾元素交换，然后调整堆来实现排序。堆排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：堆排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。建堆过程中需要进行n&#x2F;2次比较和交换操作，而每次堆化操作的时间复杂度为O(log n)，因此总体时间复杂度为O(n log n)。</p>
<p>空间复杂度：堆排序的空间复杂度是O(1)，因为它只需要常数级别的额外空间来存储临时变量，无需额外的辅助空间。</p>
<p>稳定性：堆排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在堆排序中，每次交换堆顶元素与末尾元素的位置会对相等元素产生影响，因此可能打破相等元素之间的相对顺序。</p>
<p>需要注意的是，堆排序虽然具有较好的时间复杂度，但由于其涉及到频繁的元素交换操作，因此在实际应用中对内存的访问比较敏感，可能不如一些其他排序算法（如快速排序、归并排序）效率高。堆排序主要适用于需要稳定时间复杂度的特殊场景或者仅需要部分有序的序列。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的排序算法，它利用堆的性质进行排序。具体步骤如下：</p>
<ol>
<li><p><strong>构建最大堆</strong>：将待排序的数组看作一个完全二叉树，并通过自底向上的方式构建一个最大堆。最大堆要求父节点的值大于或等于其子节点的值。</p>
</li>
<li><p><strong>调整最大堆</strong>：将堆顶元素（即最大值）与堆的最后一个元素交换位置，然后将堆的大小减一。接着，对新的堆顶元素进行一次从上往下的调整操作，使得堆重新满足最大堆的性质。</p>
</li>
<li><p><strong>重复调整</strong>：重复执行第2步，直到整个数组有序。每次循环都会将当前堆中的最大值放在已排序区的末尾，同时将堆的大小减一。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是堆排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 调整堆，使其满足堆的性质</span>
<span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 初始化根节点索引为最大值索引</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左子节点索引</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 右子节点索引</span>

    <span class="token comment">// 找到最大值索引</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 如果最大值索引不是根节点索引，则交换并继续调整堆</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 堆排序函数</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 构建初始堆（最大堆）</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 一个个取出堆顶元素，将其放置在已排序部分的末尾</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>swap</code>函数来交换两个元素的值，并实现了<code>heapify</code>函数用于调整堆的性质，以及<code>heapSort</code>函数来进行堆排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>heapSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，堆排序成功地将数组元素从小到大进行了排序。请注意，这只是堆排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>堆排序是一种高效的排序算法，适用于多种应用场景。以下是一些适合使用堆排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：堆排序具有稳定的时间复杂度O(n log n)，在平均和最坏情况下都表现良好。因此，对于大规模数据集的排序任务，堆排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相较于其他高效的排序算法（如快速排序和归并排序），堆排序是一种原地、不需要额外存储空间的排序算法。如果对稳定性有要求，堆排序可以在保持元素相对顺序方面进行优化。</p>
</li>
<li><p><strong>准实时应用</strong>：由于堆排序具有较好的最坏情况性能，它在某些准实时应用场景中很有用。当排序时间的上限比平均排序时间更重要时，堆排序可以在保证最坏情况下的性能。</p>
</li>
<li><p><strong>优先队列</strong>：堆排序使用堆这种数据结构，在构建和调整堆的过程中，可以快速找到最大或最小的元素。因此，堆排序常被用作实现优先队列的底层算法。</p>
</li>
</ol>
<p>需要注意的是，堆排序的实现相对较复杂，需要理解和掌握堆数据结构的性质和操作。在实际应用中，还应综合考虑数据规模、稳定性需求以及其他因素，选择适合的排序算法。</p>
<p>综上所述，堆排序在大规模数据集、需要稳定性、准实时应用和优先队列等场景中具有优势。但在特定情况下，也可以考虑使用其他排序算法来满足具体需求。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>堆排序本身已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>对建堆过程进行优化：在原始的堆排序中，建堆过程需要从最后一个非叶子节点开始依次向前进行下滤操作。可以通过从最后一个非叶子节点往前遍历，对每个节点执行下滤操作，从而减少比较和交换的次数。</p>
</li>
<li><p>选择合适的堆化方式：堆排序中的堆化操作可以选择自顶向下（即上滤）或自底向上（即下滤）两种方式。在实际应用中，可以根据具体情况选择更适合的堆化方式以提高性能。</p>
</li>
<li><p>使用小根堆进行降序排序：默认情况下，堆排序是使用大根堆来实现升序排序。如果需要进行降序排序，可以使用小根堆来构建堆，并依次取堆顶元素，然后调整堆。</p>
</li>
<li><p>针对部分有序序列的优化：对于已经部分有序的序列，可以通过设置一个阈值，当堆化过程中某些节点已经有序时，可以跳过这些节点的堆化操作，从而提高效率。</p>
</li>
<li><p>使用循环内建堆：在原始的堆排序中，每次交换堆顶元素后，需要重新对堆进行调整。可以考虑将这一过程放在循环内部，减少交换和调整堆的次数，提高性能。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升堆排序的性能。然而，需要注意的是，在实际应用中，堆排序通常在对稳定性要求不高且需要基于堆结构的其他操作时才会使用，而在面对大规模数据集或追求更高效稳定的排序算法时，其他算法（如快速排序、归并排序等）通常更为常用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/selection/</url>
    <content><![CDATA[<p>选择排序（Selection Sort）是一种简单但低效的排序算法。其基本思想是在每一轮中选择未排序部分的最小（或最大）元素，并将其与未排序部分的第一个元素交换位置，从而逐渐构建有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是选择排序的算法原理：</p>
<ol>
<li>遍历待排序序列，将序列中的第一个元素看作当前最小（或最大）元素。</li>
<li>依次与后续的元素进行比较，找到最小（或最大）的元素，记为当前最小（或最大）元素。</li>
<li>如果当前最小（或最大）元素不是当前位置的元素，则交换两者的位置，使得当前位置的元素成为有序序列的一部分。</li>
<li>继续从下一个位置开始执行步骤2和步骤3，直到遍历完整个序列。</li>
<li>重复步骤1~4，直到所有元素都排序完成。</li>
</ol>
<p>选择排序每一轮选择出最小（或最大）的元素，然后将其放置到正确的位置上，因此每一轮可以确定一个元素的最终位置。需要执行n-1轮排序操作，其中n为待排序元素的个数。选择排序的时间复杂度为O(n^2)。</p>
<p>尽管选择排序的效率较低，但由于其实现简单直观，对于小规模的数据集仍然具有一定的应用价值。此外，选择排序是一种不稳定的排序算法，相等元素的相对顺序有可能改变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>选择排序（Selection Sort）是一种简单直观的排序算法，它通过在待排序序列中找到最小（或最大）的元素，并将其放置在已排序序列的末尾。选择排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：无论待排序序列是否有序，选择排序的时间复杂度都为O(n^2)，其中n是待排序序列的长度。这是因为选择排序需要进行n次循环，每次循环需要遍历剩余未排序元素来寻找最小（或最大）的元素。</p>
<p>空间复杂度：选择排序的空间复杂度是O(1)，因为它只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：选择排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在选择排序中，每一次选择最小（或最大）的元素并与当前位置交换，可能导致相等元素的相对顺序发生改变。</p>
<p>需要注意的是，尽管选择排序的时间复杂度较高且不稳定，但由于其实现简单，比较次数固定，对于小规模的数据集仍然可能具有一定的实用性。然而，在面对大规模数据集或追求更高效稳定的排序算法时，其他算法（如快速排序、归并排序等）通常更为常用。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>选择排序（Selection Sort）是一种简单直观的排序算法，它通过重复选择最小（或最大）的元素，并放置到已排序序列的末尾，从而逐步构建有序序列。下面是选择排序的详细步骤：</p>
<ol>
<li><p><strong>初始状态</strong>：将待排序的数组分为已排序区和未排序区。初始时，已排序区为空，未排序区包含整个数组。</p>
</li>
<li><p><strong>找到最小元素</strong>：从未排序区中选择最小的元素，记录其索引或值。</p>
</li>
<li><p><strong>交换位置</strong>：将最小元素与未排序区的第一个元素交换位置，将该元素放入已排序区的末尾。</p>
</li>
<li><p><strong>更新区域</strong>：将已排序区扩展一个位置，将未排序区缩小一个位置。</p>
</li>
<li><p><strong>重复执行</strong>：重复执行第2至第4步，直到未排序区为空。此时，整个数组已经有序。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是选择排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 选择排序函数</span>
<span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>

        <span class="token comment">// 找到未排序部分的最小元素的索引</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 将最小元素与当前位置交换</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>swap</code>函数来交换两个元素的值，并实现了<code>selectionSort</code>函数来进行选择排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>selectionSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，选择排序成功地将数组元素从小到大进行了排序。请注意，这只是选择排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>选择排序是一种简单直观的排序算法，尽管在时间复杂度上不如其他高级排序算法，但它仍然有一些应用场景。以下是一些适合使用选择排序的情况：</p>
<ol>
<li><p><strong>小规模数据集</strong>：由于选择排序的实现简单且不需要额外的存储空间，对于小规模的数据集来说，其性能表现可接受。</p>
</li>
<li><p><strong>内存受限环境</strong>：选择排序是一种原地排序算法，即不需要额外的存储空间。在内存受限的环境中（如嵌入式系统、某些特殊硬件环境），选择排序可能是一个合适的选择。</p>
</li>
<li><p><strong>教学和理解</strong>：选择排序是最简单的排序算法之一，非常适合作为教学工具，帮助初学者理解排序算法的基本原理和思想。</p>
</li>
<li><p><strong>辅助其他排序算法</strong>：选择排序的交换次数相对较少，可以用作其他排序算法的前置步骤或优化策略。</p>
</li>
</ol>
<p>需要注意的是，选择排序的主要应用场景是在小规模数据和内存受限环境下，或作为教学使用，而不适用于大规模数据和时间敏感的应用。在这些情况下，建议使用更高效的排序算法，如快速排序、归并排序等。选择排序的性能相对较低，通常不是首选的排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>选择排序是一种简单但效率较低的排序算法。尽管它的时间复杂度无法通过优化得到明显改善，但可以考虑以下几种优化方法来提高选择排序的性能：</p>
<ol>
<li><p>最小&#x2F;最大元素同时查找：在每次循环中，除了找到当前未排序序列中的最小（或最大）元素外，还可以同时找到最大和最小元素的位置。这样可以将两个交换操作合并为一次，减少总体的比较次数。</p>
</li>
<li><p>跳过已排序部分查找：在每次循环中，在待排序序列中查找最小（或最大）元素时，可以跳过已经排序好的部分。因为已排序部分的元素已经处于正确的位置上，无需再次比较。</p>
</li>
<li><p>优化交换操作：选择排序每次需要找到最小（或最大）元素，并与当前位置进行交换。可以通过添加一个判断语句，在找到最小（或最大）元素后，若它就处于当前位置，则无需进行交换操作。</p>
</li>
<li><p>针对优化情况的增量设置：对于一些已基本有序的序列，可以通过设定适当的增量（如步长）来进行排序，使得每一趟排序的跨度减小，从而加快排序速度。例如，可以使用希尔增量序列或其他合适的增量序列。</p>
</li>
</ol>
<p>这些优化方法可以在某些情况下提高选择排序的性能。然而，需要注意的是，尽管这些优化措施可能减少了一些比较和交换操作的次数，但选择排序的时间复杂度仍然保持不变，因此对于大规模数据集来说，它仍然不是一个高效的排序算法。在实际应用中，通常会选择其他更为高效的排序算法来处理排序任务。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/quick/</url>
    <content><![CDATA[<p>快速排序（Quick Sort）是一种常用且高效的排序算法。其基本思想是通过分治法将待排序序列不断划分成较小和较大的子序列，然后对子序列进行递归排序，最终合并得到有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>选择一个基准元素（pivot），通常是待排序序列的第一个或最后一个元素。</li>
<li>将待排序序列划分成两个子序列，一个子序列包含所有比基准元素小的元素，另一个子序列包含所有比基准元素大的元素。在划分过程中，可以使用两个指针（low和high）分别从序列的起始位置和末尾位置向中间移动。</li>
<li>对两个子序列递归地应用快速排序算法，直到子序列的长度为1或0时停止递归。</li>
<li>合并排好序的子序列和基准元素，即可得到完全排序的序列。</li>
</ol>
<p>快速排序的关键在于划分过程，它通过一次遍历将待排序序列划分为两个子序列，其中一个子序列的元素都比基准元素小，另一个子序列的元素都比基准元素大。这样，在每一轮划分后，基准元素就找到了它的最终位置，不需要再移动，从而提高了排序效率。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>快速排序（Quick Sort）是一种常用的排序算法，它基于分治思想，在待排序序列中选择一个元素作为基准值，将序列划分为两个子序列，使得左侧子序列的所有元素小于等于基准值，右侧子序列的所有元素大于基准值，然后对两个子序列递归地进行排序。快速排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：在平均情况下，快速排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。在最坏情况下，当待排序序列已经有序或基本有序时，快速排序的时间复杂度退化为O(n^2)。尽管最坏情况下的时间复杂度较高，但由于快速排序的平均时间复杂度较低且具有良好的性能表现，因此它仍然是一种常用的排序算法。</p>
<p>空间复杂度：快速排序的空间复杂度取决于递归调用的栈空间。在每次划分过程中，需要额外的空间来保存基准值和左右子序列的划分点。因此，快速排序的空间复杂度是O(log n)。</p>
<p>稳定性：快速排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在快速排序中，由于划分过程中涉及到元素的交换，可能打破相等元素之间的相对顺序。因此，快速排序并不保证相等元素的相对顺序不变。</p>
<p>需要注意的是，在实际应用中，可以通过选择合适的基准值和优化划分过程来提高快速排序的性能，例如随机选择基准值或使用三数取中法来选择基准值，并采用插入排序等方法来处理小规模子序列。这些优化措施能够使快速排序更加稳定和高效。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>快速排序（Quick Sort）是一种常用的高效排序算法，基于分治法的思想。它通过选择一个基准元素，并将数组划分成两个子数组，其中一个子数组的元素均小于等于基准元素，而另一个子数组的元素均大于基准元素。然后对这两个子数组分别递归地应用快速排序，最终完成整体的排序。下面详细解释快速排序的步骤：</p>
<ol>
<li><p><strong>选择基准元素</strong>：从待排序的数组中选择一个元素作为基准元素。通常可以选择第一个元素、最后一个元素或者随机位置的元素作为基准。</p>
</li>
<li><p><strong>划分过程</strong>：将数组中的其他元素与基准元素进行比较，并将小于等于基准的元素放在基准元素的左侧，大于基准的元素放在右侧。此过程称为划分（Partition）。</p>
</li>
<li><p><strong>递归调用</strong>：对基准元素左侧和右侧的子数组，分别递归地应用快速排序算法。重复上述步骤，直到每个子数组只包含一个元素，即达到基线条件。</p>
</li>
<li><p><strong>合并结果</strong>：当所有子数组都有序时，整个数组也就有序了。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是快速排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 划分函数，将序列划分为两个子序列</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 选择最后一个元素作为基准</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小于基准元素的指针</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 快速排序函数</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分并获得基准元素的位置</span>

        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对基准元素左侧的子序列进行递归排序</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对基准元素右侧的子序列进行递归排序</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了三个函数：<code>swap</code>用于交换两个元素的值，<code>partition</code>用于划分序列并返回基准元素的位置，<code>quickSort</code>实现递归地对子序列进行快速排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>quickSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，快速排序成功地将数组元素从小到大进行了排序。请注意，这只是快速排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>快速排序是一种高效的排序算法，适用于各种应用场景。以下是一些适合使用快速排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：快速排序在平均情况下具有良好的性能，其时间复杂度为O(n log n)。因此，对于大规模数据集的排序任务，快速排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相比于其他常用的高效排序算法（如堆排序和归并排序），快速排序是一种原地排序算法，不需要额外的存储空间。如果对稳定性有要求，可以通过修改算法来保持相等元素的相对顺序。</p>
</li>
<li><p><strong>部分有序数组</strong>：快速排序的性能在处理部分有序的数组时表现良好。由于快速排序的分区过程会将数组划分成两个子数组，对于已经有序或基本有序的数组，递归处理时只需少量的比较和交换操作。</p>
</li>
<li><p><strong>应用中频繁插入和删除元素</strong>：快速排序的特点是基于分治法，将数组划分成两个子数组。当需要在已排序的数组中频繁地插入和删除元素时，快速排序具有较好的适应性。</p>
</li>
</ol>
<p>需要注意的是，快速排序的最坏情况时间复杂度为O(n^2)，即当选择的基准元素不合适（如数组已经有序或基本有序）时，性能可能下降。因此，在特定情况下，可以考虑使用其他排序算法来避免快速排序的最坏情况。</p>
<p>综上所述，快速排序在大规模数据集、需要稳定性、部分有序数组和频繁插入删除元素等场景中具有优势。但在实际应用中，还应综合考虑数据规模、应用需求以及其他因素，选择合适的排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>快速排序本身已经是一种高效的排序算法，但还可以通过以下优化方法进一步提升性能：</p>
<ol>
<li><p>随机选择基准值：在每次划分过程中，选择一个随机位置的元素作为基准值。这样可以避免在待排序序列已经有序或近乎有序的情况下，快速排序退化为最坏情况。</p>
</li>
<li><p>三数取中法选择基准值：从待排序序列的开始、中间和末尾位置分别选取一个元素，然后将它们进行比较，并选择其中位于中间大小的元素作为基准值。这样可以尽量避免选择极端值作为基准值，进而减少快速排序的不平衡性。</p>
</li>
<li><p>小规模子序列使用插入排序：当待排序子序列的长度比较小（通常小于一定阈值）时，可以直接采用插入排序等简单且稳定的排序算法来替代快速排序。因为对于小规模的子序列，插入排序可能会更加高效。</p>
</li>
<li><p>跳过相等元素的划分：在划分过程中，如果遇到与基准值相等的元素，可以跳过它们，避免不必要的交换操作。这样可以减少比较和交换的次数，提高性能。</p>
</li>
<li><p>优化递归：通过尾递归、迭代或使用隐式栈等方式，减少递归调用的深度，避免栈溢出的问题。</p>
</li>
</ol>
<p>这些优化方法可以结合使用，根据具体情况选择适合的优化策略。它们在实际应用中可以显著提升快速排序的性能，使得它更加稳定和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/bubble/</url>
    <content><![CDATA[<p>冒泡排序（Bubble Sort）是一种简单但低效的排序算法。其基本思想是通过不断比较相邻的元素并交换位置，将最大（或最小）的元素逐渐“冒泡”到序列的末尾（或开头），从而实现排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>从待排序的数组的第一个元素开始，依次比较每一对相邻的元素。</li>
<li>如果当前元素大于（或小于）它的下一个元素，则交换这两个元素的位置，使较大（或较小）的元素“浮”到前面。</li>
<li>继续重复步骤2，对剩余的元素进行相同的操作，直到最后一个元素。</li>
<li>一轮比较过程完成后，最大（或最小）的元素已经移动到了序列的末尾（或开头）。</li>
<li>重复步骤1~4，对剩余未排序的元素进行相同的操作，直到所有元素都排序完成。</li>
</ol>
<p>冒泡排序每一轮都会将最大（或最小）的元素“浮”到末尾（或开头），因此在每一轮排序中都可以减少一个元素的比较次数。最坏情况下，需要进行n-1轮比较和移动操作，其中n为待排序元素的个数。冒泡排序的时间复杂度为O(n^2)。</p>
<p>尽管冒泡排序的效率较低，但由于其实现简单直观，对于小规模的数据集仍然具有一定的应用价值。此外，冒泡排序也是稳定的排序算法，相等元素的相对顺序不会改变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>冒泡排序（Bubble Sort）是一种简单且容易理解的排序算法，它通过相邻元素之间的比较和交换来进行排序。冒泡排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：冒泡排序的平均时间复杂度和最坏情况下的时间复杂度都是O(n^2)，其中n是待排序序列的长度。在最好情况下，即待排序序列已经完全有序的情况下，冒泡排序的时间复杂度可以是O(n)。但由于每次循环都需要执行两两比较和可能的交换操作，所以总体时间复杂度仍然是O(n^2)。</p>
<p>空间复杂度：冒泡排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：冒泡排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在冒泡排序中，通过相邻元素之间的比较和交换，只有当相邻元素大小不符合排序规则时才进行交换，所以相等元素之间的相对顺序不会改变，即冒泡排序是一种稳定的排序算法。</p>
<p>需要注意的是，尽管冒泡排序的时间复杂度较高，但在某些特定情况下（如待排序序列已经基本有序），它可能具有较好的性能表现。然而，在实际应用中，根据具体情况选择合适的排序算法，综合考虑数据规模、时间复杂度要求以及稳定性等因素。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它通过多次遍历待排序的数组，并比较相邻元素的大小来进行排序。在每次遍历中，较大的元素会逐渐“浮”到数组的末尾，故称为冒泡排序。下面是冒泡排序的详细步骤：</p>
<ol>
<li><p><strong>从第一个元素开始</strong>：从数组的第一个元素开始，依次比较相邻的两个元素的大小。</p>
</li>
<li><p><strong>比较相邻元素</strong>：将当前元素与其后面的相邻元素进行比较，如果当前元素大于后面的元素，则交换这两个元素的位置，使较大的元素“冒泡”。</p>
</li>
<li><p><strong>向后遍历</strong>：继续向后遍历，重复执行步骤2，直到遍历到倒数第二个元素。此时，最大的元素已经“冒泡”到了数组的最后一个位置。</p>
</li>
<li><p><strong>重复遍历步骤</strong>：重复执行上述步骤，每次遍历范围缩小一个元素，直到整个数组有序。</p>
</li>
<li><p><strong>优化处理</strong>：可以添加一个标志位来判断在一轮遍历中是否发生了元素的交换。如果没有发生交换，说明数组已经有序，可以提前结束排序。</p>
</li>
</ol>
<p>冒泡排序的核心思想是通过相邻元素的比较和交换来将最大（或最小）的元素逐渐移动到数组的末尾。该算法时间复杂度为O(n^2)，其中n是数组的长度。虽然冒泡排序不是一种高效的排序算法，但由于其简单直观的实现方式，对于小规模数据集或已经基本有序的数据集仍具有一定的应用价值。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是冒泡排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 在每一轮中执行比较和交换操作</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果当前元素大于下一个元素，则交换位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该示例中，我们定义了一个<code>bubbleSort</code>函数来实现冒泡排序。在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>bubbleSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可见，冒泡排序成功地将数组元素从小到大进行了排序。请注意，这只是冒泡排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>尽管冒泡排序在时间复杂度上不如其他高级排序算法，但它仍然有一些应用场景。以下是一些适合使用冒泡排序的情况：</p>
<ol>
<li><p><strong>小规模数据集</strong>：由于冒泡排序的实现简单直观，对于小规模的数据集来说，其性能表现可接受。</p>
</li>
<li><p><strong>部分有序数组</strong>：当待排序的数组已经基本有序时，冒泡排序的效率会更高。因为冒泡排序的特点是每次都会将最大（或最小）的元素交换到末尾，所以对于部分有序的数组，只需进行少量的比较和交换操作即可完成排序。</p>
</li>
<li><p><strong>教学和理解</strong>：冒泡排序是最简单的排序算法之一，非常适合作为教学工具，帮助初学者理解排序算法的基本原理和思想。</p>
</li>
<li><p><strong>稳定性要求</strong>：冒泡排序是一种稳定的排序算法，即相等元素的相对顺序不变。在某些情况下，对于需要保持相等元素顺序的应用场景，冒泡排序是一个合适的选择。</p>
</li>
</ol>
<p>需要注意的是，对于大规模的数据集，冒泡排序的性能不够理想，建议使用更高效的排序算法，如快速排序、归并排序等。冒泡排序的主要应用场景是在小规模数据和部分有序数组情况下，或作为教学使用，而不适用于大规模数据和时间敏感的应用。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>冒泡排序是一种简单但效率较低的排序算法，由于其两两比较和交换的思想，导致在大多数情况下需要进行多次无意义的比较和交换操作。为了提高冒泡排序的效率，可以采用以下几种优化方法：</p>
<ol>
<li><p>设置标志位：在每一轮内部循环中，如果没有发生元素的交换操作，说明待排序序列已经有序，可以提前结束排序过程。</p>
</li>
<li><p>记录最后一次交换位置：在每一轮内部循环中，记录最后一次元素交换的位置，该位置之后的元素已经有序，因此下一轮只需比较到这个位置即可。</p>
</li>
<li><p>双向冒泡排序：正常的冒泡排序是从左到右依次比较相邻元素并进行交换，而双向冒泡排序可以同时从左到右和从右到左进行相邻元素的比较和交换操作，从而减少排序的趟数。</p>
</li>
<li><p>针对优化情况的增量设置：对于一些已基本有序的序列，可以通过设定适当的增量（如步长）来进行排序，使得每一趟排序的跨度减小，从而加快排序速度。例如，可以使用希尔增量序列或者其他合适的增量序列。</p>
</li>
</ol>
<p>这些优化方法都是基于冒泡排序的思想，通过剪枝和减少比较交换次数来提高效率。然而，尽管这些优化方法可以降低冒泡排序的时间复杂度，并且在某些特定情况下可能具有较好的性能表现，但在大多数实际应用中，其他更为高效的排序算法（如快速排序或归并排序）通常更受青睐。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/shell/</url>
    <content><![CDATA[<p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为缩小增量排序。其基本思想是通过将整个待排序序列分割成若干个子序列进行排序，然后逐步缩小子序列的间隔，直到最后一次排序时间隔为1，即执行最后一次普通的插入排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是希尔排序的算法原理：</p>
<ol>
<li>首先选择一个增量序列，通常为n&#x2F;2、n&#x2F;4、n&#x2F;8…直到增量为1。</li>
<li>根据选定的增量，将待排序的数组分成多个子序列，每个子序列包含间隔为增量的元素。</li>
<li>对每个子序列进行插入排序，即将每个子序列中的元素按照插入排序的方式进行排序。</li>
<li>缩小增量，重新分割子序列，并对每个子序列进行排序。重复这一步骤，直到增量为1。</li>
<li>最后一次排序时，增量为1，即进行一次普通的插入排序，将整个序列排序完成。</li>
</ol>
<p>希尔排序的关键在于选取的增量序列，不同的增量序列可能会影响排序的效率。一般情况下，增量序列可以使用Hibbard增量序列（2^k - 1, 2^(k-1) - 1, …, 7, 3, 1）或者Sedgewick增量序列（1, 5, 19, 41, 109, …），它们经过实践证明能够获得较好的排序效果。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>希尔排序（Shell Sort）是一种基于插入排序的排序算法，它通过将待排序序列分成多个较小的子序列进行排序，然后逐步缩小子序列的间隔，最终完成整个序列的排序。希尔排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：希尔排序的时间复杂度取决于增量序列的选择。最坏情况下，希尔排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。但在大多数情况下，希尔排序的时间复杂度可以达到O(n log n)或更好。具体的时间复杂度分析比较复杂，取决于增量序列的选取和序列的有序度。</p>
<p>空间复杂度：希尔排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：希尔排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在希尔排序中，由于每次排序的跨度比较大，可能会打破相等元素之间的相对顺序，因此希尔排序并不保证相等元素的相对顺序不变。</p>
<p>需要注意的是，希尔排序的性能受到增量序列的选择影响较大。选择合适的增量序列可以显著改善希尔排序的性能，并使其接近最优的时间复杂度。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为缩小增量排序。它通过将待排序的数组分割成多个子序列，并对每个子序列进行插入排序来实现整体的排序。希尔排序的步骤如下所示：</p>
<ol>
<li><p><strong>选择增量序列</strong>：选择一个递减的增量序列，常见的选择方式是使用希尔增量序列（例如，Knuth序列或者Sedgewick序列）。增量序列决定了每次分割子序列的间隔。</p>
</li>
<li><p><strong>根据增量分割子序列</strong>：按照选定的增量将待排序的数组分割成多个子序列，并对每个子序列进行插入排序。通常，初始增量会将数组分割成较小的子序列，随着增量的逐渐减小，子序列的长度也会逐渐增加。</p>
</li>
<li><p><strong>对子序列进行插入排序</strong>：对每个子序列应用插入排序算法，通过比较相邻元素的大小并移动元素，将子序列中的元素进行排序。</p>
</li>
<li><p><strong>减小增量并重复上述步骤</strong>：重复以上步骤，每次减小增量直到增量为1。当增量减小为1时，整个序列被视为一个子序列，并进行最后一次插入排序。</p>
</li>
<li><p><strong>合并子序列</strong>：在完成上述步骤后，所有的子序列都已经有序。最后，对整个数组进行一次插入排序，确保整体有序。</p>
</li>
</ol>
<p>希尔排序通过提前对较远距离的元素进行比较和交换，可以快速地减小逆序对的数量，从而加快排序的速度。尽管希尔排序的时间复杂度没有严格的界定，但在实践中，它通常具有较好的性能表现。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是希尔排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 选择增量序列（可以使用其他增量序列）</span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对每个子序列进行插入排序</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            
            <span class="token comment">// 在子序列中进行插入排序</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> gap <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 缩小增量</span>
        gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">shellSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，<code>shellSort</code>函数实现了希尔排序算法。它首先选择一个增量序列，并使用增量来分割待排序的数组成多个子序列。然后对每个子序列应用插入排序算法来对子序列进行排序。最后，通过不断减小增量的方式重复上述过程，直到增量为1，完成整体的排序。</p>
<p>在<code>main</code>函数中，我们创建一个示例数组并调用<code>shellSort</code>函数来对数组进行排序。最终，打印出原始数组和排序后的数组。</p>
<p>请注意，在实际应用中，可以根据具体需求选择不同的增量序列，并对算法进行优化。以上是希尔排序的一个基本实现，您可以根据需要进行修改和扩展。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>希尔排序在以下情况下适用：</p>
<ol>
<li><p>中等规模的数据集：希尔排序相对于一些更为复杂的排序算法（如快速排序和归并排序）来说，实现起来比较简单且效率较高。因此，在数据集规模不是很大的情况下，希尔排序可以提供较好的性能。</p>
</li>
<li><p>需要原地排序的场景：希尔排序只需要常数级别的额外空间，因此它是一种原地排序算法。如果空间复杂度是一个重要的考虑因素，希尔排序是一个合适的选择。</p>
</li>
<li><p>对稳定性没有特别要求的场景：希尔排序是一种不稳定的排序算法，即可能打破相等元素之间的相对顺序。如果待排序序列中存在相等元素，并且要求保持它们的相对顺序不变，那么希尔排序可能不适合。但在某些情况下，对稳定性没有特别要求的场景，希尔排序仍然可以使用。</p>
</li>
</ol>
<p>总的来说，希尔排序在中等规模的数据集以及需要原地排序且对稳定性没有特别要求的场景下表现良好。然而，在实际应用中，根据具体情况选择合适的排序算法，综合考虑数据规模、时间复杂度要求以及稳定性等因素。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>希尔排序可以通过以下几种优化方法来提高其性能：</p>
<ol>
<li><p><strong>选择优化的增量序列</strong>：希尔排序中增量序列的选择对算法的性能有着重要影响。一些常用的增量序列如Hibbard增量序列和Sedgewick增量序列，它们经过实践证明能够获得较好的排序效果。同时，还可以针对特定数据集进行实验，选择适合该数据集的增量序列。</p>
</li>
<li><p><strong>插入排序的优化</strong>：在希尔排序中，每个子序列都会执行插入排序。可以尝试使用更高效的插入排序算法，比如二分插入排序（折半插入排序）来替代普通的插入排序。这样可以减少每个子序列的比较和移动操作次数，进而提高整体的排序效率。</p>
</li>
<li><p><strong>多线程并行处理</strong>：希尔排序可以通过并行处理来提高排序速度。将待排序的数组分成多个子序列后，可以采用多线程的方式并行地对各个子序列进行排序，从而加快整体的排序过程。需要注意线程同步和数据分配的问题。</p>
</li>
<li><p><strong>结合其他排序算法</strong>：结合其他排序算法进行改进也是一种优化方法。例如，可以通过希尔排序的初步排序得到一个部分有序的数组，然后再使用其他排序算法（如快速排序或归并排序）对部分有序的数组进行最终的排序。这样可以在一定程度上提高整体的排序效率。</p>
</li>
</ol>
<p>需要根据具体情况选择适合的优化方法，并进行实际的测试和评估来确定其效果。不同的数据集和需求可能会导致不同的优化策略。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>折半插入排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/halfinsertion/</url>
    <content><![CDATA[<p>折半插入排序（Binary Insertion Sort）是在直接插入排序的基础上进行改进的一种排序算法。与直接插入排序类似，折半插入排序也通过构建有序序列来对数据进行排序。它的基本思想是利用二分查找的方式来确定待插入元素在已排序部分中的位置，从而减少比较操作的次数。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序的数组分为已排序和未排序两部分，初始时已排序部分只包含第一个元素。</li>
<li>对于每个未排序的元素，使用二分查找在已排序部分找到合适的插入位置。</li>
<li>采用二分查找时，首先取已排序部分的中间位置mid，将待插入元素与mid处的元素进行比较。</li>
<li>如果待插入元素小于mid处的元素，则说明插入位置在mid的左侧，将搜索范围缩小至左半部分继续进行二分查找。</li>
<li>如果待插入元素大于或等于mid处的元素，则说明插入位置在mid的右侧，将搜索范围缩小至右半部分继续进行二分查找。</li>
<li>不断重复步骤3~5，直到找到合适的插入位置。</li>
<li>将待插入元素插入到已排序部分的正确位置上，将已排序部分的长度增加1。</li>
<li>重复步骤2~7，直到所有元素都插入完成。</li>
</ol>
<p>通过利用二分查找来确定插入位置，折半插入排序减少了比较的次数，相对于直接插入排序可以提高效率。其时间复杂度仍然为O(n^2)，但是在实际应用中，由于比较次数的减少，折半插入排序通常比直接插入排序更快。同时，折半插入排序也是稳定的排序算法，保持相等元素之间的相对顺序不变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>折半插入排序（或称为二分插入排序）的时间复杂度、空间复杂度和稳定性与直接插入排序相同。</p>
<p>时间复杂度：折半插入排序的时间复杂度仍然是O(n^2)，其中n是待排序序列的长度。虽然折半插入排序减少了比较操作的次数，但仍需要进行元素的移动操作，最坏情况下仍然需要进行n*(n-1)&#x2F;2次比较和移动操作。</p>
<p>空间复杂度：折半插入排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：折半插入排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在折半插入排序中，当找到待插入元素应该插入的位置时，将其插入到该位置之前，并不会改变相等元素的相对顺序，因此折半插入排序也是稳定的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>折半插入排序的步骤详解如下：</p>
<ol>
<li>将待排序的数组分为已排序和未排序两部分，初始时已排序部分只包含第一个元素。</li>
<li>对于每个未排序的元素，使用二分查找在已排序部分找到合适的插入位置。</li>
<li>采用二分查找时，首先确定已排序部分的起始位置start和结束位置end。初始时，start为0，end为已排序部分的最后一个元素的索引。</li>
<li>计算mid &#x3D; (start + end) &#x2F; 2，取已排序部分中间位置元素的索引。</li>
<li>比较待插入元素与mid处元素的大小关系：<ul>
<li>如果待插入元素小于mid处元素，则说明插入位置在mid的左侧，将end更新为mid-1。</li>
<li>如果待插入元素大于或等于mid处元素，则说明插入位置在mid的右侧，将start更新为mid+1。</li>
<li>如果待插入元素等于mid处元素，则可以选择将待插入元素插入到mid的左侧或右侧，保持稳定性即可。</li>
</ul>
</li>
<li>重复进行二分查找，直到找到合适的插入位置，此时start的值即为插入位置的索引。</li>
<li>将待插入元素插入到start的位置上，并将已排序部分的长度增加1。</li>
<li>重复步骤2~7，对未排序部分的每个元素都进行插入操作，直到所有元素都插入完成。</li>
</ol>
<p>在折半插入排序中，二分查找的使用使得待插入元素的比较次数减少，从而提高了算法的效率。与直接插入排序相比，折半插入排序保持了相同的稳定性，但一般情况下具有更好的性能。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是折半插入排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">binaryInsertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>
    
    <span class="token comment">// 从第二个元素开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前待插入元素</span>
        low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 使用二分查找在已排序部分中寻找待插入元素的插入位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        <span class="token comment">// 将插入位置之后的元素都向后移动一个位置，为待插入元素腾出空间</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> low<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token comment">// 插入待插入元素到正确位置</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始序列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">binaryInsertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此代码中，binaryInsertionSort函数用于实现折半插入排序算法。在main函数中，我们定义了一个待排序序列arr，并对其进行排序。最终输出排序结果。运行该程序将得到如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">原始序列：5 2 4 6 1 3 
排序结果：1 2 3 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这是折半插入排序在C语言中的基本实现，通过利用二分查找来确定待插入元素的插入位置，从而减少比较操作的次数。然后，将插入位置之后的元素都向后移动一个位置，为待插入元素腾出空间，最后将待插入元素插入到正确的位置上，得到有序序列。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>折半插入排序通常在以下情况下适用：</p>
<ol>
<li><p>大部分元素已经有序：折半插入排序的优势在于它利用了已排序部分的有序性质，通过二分查找来确定待插入元素的插入位置。因此，当待排序序列中的大部分元素已经有序时，折半插入排序可以有效地减少比较操作的次数，提高排序效率。</p>
</li>
<li><p>数据量不是很大：由于折半插入排序的时间复杂度仍然是O(n^2)，其中n是待排序序列的长度，所以在数据量较大的情况下，其他更高效的排序算法（如快速排序或归并排序）可能更合适。折半插入排序通常在数据量不是很大的情况下发挥其优势。</p>
</li>
<li><p>稳定排序要求：折半插入排序是一种稳定的排序算法，即相等元素的相对顺序在排序后保持不变。如果需要保持相等元素的原始相对顺序，折半插入排序是一个良好的选择。</p>
</li>
</ol>
<p>总的来说，折半插入排序在某些特定情况下能够提供比直接插入排序更好的性能表现。但在实际应用中，需要根据具体情况选择合适的排序算法，根据数据量大小、有序度以及稳定性等因素进行综合考虑。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>在折半插入排序中，可以使用一些优化方法来进一步提高算法的效率和性能。以下是一些常见的折半插入排序的优化方法：</p>
<ol>
<li><p><strong>二分查找的优化</strong>：传统的二分查找需要不断地比较并更新左右指针，这会带来额外的开销。为了减少比较操作的次数，可以使用二分查找的变种，如插值查找或斐波那契查找等，来更快地找到插入位置。</p>
</li>
<li><p><strong>前置判断</strong>：在开始进行二分查找之前，可以先对待插入元素与已排序部分的第一个元素进行比较。如果待插入元素小于或等于第一个元素，那么直接将其插入到已排序部分的开头即可，无需进行二分查找。</p>
</li>
<li><p><strong>移动元素的优化</strong>：传统的折半插入排序在找到插入位置后，需要依次移动元素以空出插入位置。这一过程可以通过一次数组元素的搬移操作来进行，从而减少元素搬移的次数。</p>
</li>
<li><p><strong>使用二分查找定位插入位置</strong>：除了用二分查找来确定插入位置外，还可以选择使用其他更高效的数据结构，如平衡二叉搜索树（如红黑树）、跳表等，来加速查找插入位置的过程。</p>
</li>
</ol>
<p>这些优化方法可以结合使用，根据具体情况进行选择和调整。优化后的折半插入排序能够更快地找到插入位置并减少元素搬移的次数，从而提高算法的效率和性能。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/insertion/</url>
    <content><![CDATA[<p>直接插入排序是一种简单直观的排序算法，其基本思想是将待排序的序列分为已排序和未排序两部分。初始时，已排序部分只包含一个元素（即第一个元素），然后逐步将未排序部分中的每个元素插入到已排序部分的适当位置，直到全部元素都被插入到已排序部分为止。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>首先，从第二个元素开始遍历整个序列，将当前元素标记为待插入元素。</li>
<li>将待插入元素与已排序部分的最后一个元素进行比较。</li>
<li>如果待插入元素小于已排序部分的最后一个元素，则将已排序部分的最后一个元素向后移动一个位置，腾出空间给待插入元素。</li>
<li>继续向前比较，直到找到待插入元素应该插入的位置为止。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤2至5，直到遍历完所有待排序元素。</li>
</ol>
<p>整个过程可以类比为打扑克牌时整理手中的牌，每次将一张新的牌插入到正确的位置上。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>直接插入排序的时间复杂度是O(n^2)，其中n是待排序序列的长度。在最坏情况下，即待排序序列是逆序的情况下，需要进行n*(n-1)&#x2F;2次比较和移动操作。</p>
<p>空间复杂度是O(1)，因为直接插入排序只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>直接插入排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在直接插入排序中，当找到待插入元素应该插入的位置时，将其插入到该位置之前，并不会改变相等元素的相对顺序，因此直接插入排序是稳定的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>以下是直接插入排序的详细步骤：</p>
<ol>
<li>假设待排序序列为arr，长度为n。</li>
<li>从第二个元素开始，将当前元素标记为待插入元素。</li>
<li>将待插入元素与已排序部分（即前面的元素）进行比较，从最后一个元素开始。</li>
<li>如果待插入元素小于已排序部分的某个元素，则将该元素向后移动一个位置，为待插入元素腾出空间。</li>
<li>继续向前比较下一个元素，直到找到待插入元素应该插入的位置或者遍历完已排序部分。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤3至6，直到遍历完所有待排序元素。</li>
</ol>
<p>以下是一个简单示例来说明直接插入排序的步骤：<br>假设待排序序列为[5, 2, 4, 6, 1, 3]</p>
<ol>
<li><p>第一轮：</p>
<ul>
<li>待插入元素为2。与已排序部分中的5比较，2小于5，将5向后移动一个位置。</li>
<li>排序结果：[2, 5, 4, 6, 1, 3]</li>
</ul>
</li>
<li><p>第二轮：</p>
<ul>
<li>待插入元素为4。与已排序部分中的5比较，4小于5，将5向后移动一个位置。</li>
<li>排序结果：[2, 4, 5, 6, 1, 3]</li>
</ul>
</li>
<li><p>第三轮：</p>
<ul>
<li>待插入元素为6。与已排序部分中的5和4比较，6大于5和4，找到待插入位置。</li>
<li>排序结果：[2, 4, 5, 6, 1, 3]</li>
</ul>
</li>
<li><p>第四轮：</p>
<ul>
<li>待插入元素为1。与已排序部分中的6、5、4、2比较，1小于所有元素，将它们向后移动一个位置。</li>
<li>排序结果：[1, 2, 4, 5, 6, 3]</li>
</ul>
</li>
<li><p>第五轮：</p>
<ul>
<li>待插入元素为3。与已排序部分中的6、5、4比较，3小于5和6，找到待插入位置。</li>
<li>排序结果：[1, 2, 3, 4, 5, 6]</li>
</ul>
</li>
</ol>
<p>最终得到的有序序列为[1, 2, 3, 4, 5, 6]。通过重复上述步骤，将每个待插入元素插入到正确的位置上，直到所有元素都被插入为止。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是直接插入排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
    
    <span class="token comment">// 从第二个元素开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前待插入元素</span>
        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 将比key大的元素向后移动</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token comment">// 插入key到正确位置</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始序列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此代码中，insertionSort函数用于实现直接插入排序算法。在main函数中，我们定义了一个待排序序列arr，并对其进行排序。最终输出排序结果。运行该程序将得到如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">原始序列：5 2 4 6 1 3 
排序结果：1 2 3 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这是直接插入排序在C语言中的基本实现，通过不断比较和移动元素，将待插入的元素插入到正确的位置上，最终得到有序序列。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>直接插入排序在以下几个场景下可以应用：</p>
<ol>
<li><p><strong>小规模数据集</strong>：当待排序的数据集规模比较小的时候，直接插入排序是一种简单而有效的排序方法。由于其简单的实现和较低的时间复杂度常数，直接插入排序对小规模数据集表现良好。</p>
</li>
<li><p><strong>部分有序数据集</strong>：如果待排序的数据集已经部分有序，即大部分元素已经按照近似的顺序排列，那么直接插入排序的效果会很好。由于该算法每次只移动一个元素，所以对于已经有序或近似有序的部分，插入的代价相对较低。</p>
</li>
<li><p><strong>在线排序</strong>：直接插入排序是一种适用于在线排序的算法，即数据不断到达并需要立即排序。每当新的数据到达时，直接插入排序可将其插入到已排序序列中的正确位置，确保序列始终有序。</p>
</li>
<li><p><strong>稳定性要求</strong>：直接插入排序是一种稳定的排序算法，它保持相等元素之间的相对顺序不变。因此，当排序需要保持稳定性时，直接插入排序是一个很好的选择。</p>
</li>
</ol>
<p>需要注意的是，对于大规模乱序的数据集，直接插入排序的性能可能不如其他高效的排序算法。对于大规模数据集的排序，更适合使用快速排序、归并排序等时间复杂度为O(n log n)的算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>直接插入排序的一个常见优化方法是使用二分查找来寻找待插入元素的插入位置，以减少比较操作的次数。这种优化称为二分插入排序。</p>
<p>二分插入排序的基本思想是利用已排序部分的有序性质，通过二分查找找到待插入元素应该插入的位置，从而减少比较次数。</p>
<p>以下是二分插入排序的优化步骤：</p>
<ol>
<li>假设待排序序列为arr，长度为n。</li>
<li>从第二个元素开始，将当前元素标记为待插入元素。</li>
<li>使用二分查找在已排序部分中寻找待插入元素的插入位置。</li>
<li>找到插入位置后，将插入位置之后的元素都向后移动一个位置，腾出空间给待插入元素。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤3至5，直到遍历完所有待排序元素。</li>
</ol>
<p>相比于普通的直接插入排序，二分插入排序减少了比较操作的次数，从而提高了算法的效率。尽管二分插入排序减少了比较次数，但仍然需要进行元素的移动操作，因此其时间复杂度仍为O(n^2)。然而，在某些特定情况下，二分插入排序的优化效果可能更显著，特别是当待排序序列较大或有序度较高时。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理</title>
    <url>/yangtong.github.io/2023/08/03/imageprocess/imageprocess/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>生物学</title>
    <url>/yangtong.github.io/2023/08/02/biology/biology/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生物学</category>
      </categories>
      <tags>
        <tag>生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/binarytree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/binarysearchtree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/balancedbinarytree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/btree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/heap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树堆</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/treap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/trie/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/bplustree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/tree/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>树是一种非线性的数据结构，它由节点（node）组成，并且这些节点之间存在特定的层次关系。树的定义如下：</p>
<p>树是一个包含n（n &gt;&#x3D; 0）个节点的有限集合。</p>
<ul>
<li>如果n &#x3D; 0，则称为空树。</li>
<li>否则，树由一个称为根节点（root）的特殊节点以及其他n - 1个不相交的子树T1、T2、…、Tn组成，每个子树本身也是一棵树。</li>
</ul>
<p>树的目的是用于组织和存储数据，并提供高效地搜索、插入和删除数据的操作。树这种数据结构在计算机科学中应用广泛，常见的应用场景包括：</p>
<ol>
<li><p>层次结构表示：树可以用来表示具有层次关系的数据，例如文件系统的目录结构、网站的导航菜单等。</p>
</li>
<li><p>搜索和排序：二叉搜索树是一种基于树的数据结构，可以快速地搜索和排序数据。它具有良好的查找、插入和删除性能。</p>
</li>
<li><p>表达关联关系：树可以用来表示具有父子关系或关联关系的数据，例如家谱、组织架构图等。</p>
</li>
<li><p>算法实现：许多经典的算法和数据结构都基于树的概念，例如平衡二叉树、堆、哈夫曼树等。</p>
</li>
</ol>
<h2 id="特点与属性"><a href="#特点与属性" class="headerlink" title="特点与属性"></a>特点与属性</h2><p>树这种数据结构具有以下主要特点和属性：</p>
<ol>
<li><p>层次关系：树的节点之间存在层次关系，每个节点都可以有零个或多个子节点，除了根节点外，其他节点都有一个父节点。</p>
</li>
<li><p>根节点和叶子节点：树的顶部节点被称为根节点，它没有父节点。没有子节点的节点称为叶子节点。根据根节点与叶子节点之间的路径长度，树可以被划分为不同的层级。</p>
</li>
<li><p>分支因子：树的分支因子是指每个节点的子节点数量。二叉树是一种特殊的树，每个节点最多只有两个子节点，即分支因子为2。</p>
</li>
<li><p>深度和高度：树的深度是从根节点到任意节点的路径长度。树的高度是从根节点到最远叶子节点的路径长度。</p>
</li>
<li><p>无环性质：树是无环的，即不存在任何节点之间的回路。</p>
</li>
</ol>
<p>树具有以下优势：</p>
<ul>
<li>快速搜索：树的结构使得在包含大量数据时，能够快速搜索目标元素，时间复杂度通常为O(log n)。</li>
<li>插入和删除效率高：树的插入和删除操作通常比线性结构（如数组）的操作效率更高。</li>
<li>数据分层组织：树的层次结构可以方便地表示和操作具有层次关系的数据，例如文件系统的目录结构。</li>
</ul>
<p>然而，树也有一些限制和适用场景：</p>
<ul>
<li>内存消耗：树的节点需要额外的空间来存储子节点的引用，因此在存储大量数据时，可能需要较多的内存空间。</li>
<li>平衡性维护：某些树类型（如二叉搜索树）在插入和删除操作后可能变得不平衡，导致搜索性能下降。为了保持平衡，可能需要额外的操作成本。</li>
<li>不适合有序数据：对于已经有序的数据集合，树的优势可能不明显，可能会选择其他更适合的数据结构。</li>
</ul>
<p>树适用于以下场景：</p>
<ul>
<li>层次关系表示：需要表达分层关系的数据结构，如组织架构、家谱等。</li>
<li>快速搜索：需要在大量数据中快速搜索目标元素，例如数据库索引、哈希表等。</li>
<li>排序和范围查询：树可以支持高效的排序和范围查询操作，例如二叉搜索树和B树。</li>
<li>数据组织和管理：树可以用于管理和组织具有层次结构的数据，例如文件系统、网络路由表等。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>树这种数据结构有以下几种基本操作：</p>
<ol>
<li><p>插入（Insertion）：向树中添加一个新节点。插入操作需要考虑树的特定规则，如二叉搜索树中插入节点时需要保持左子节点小于父节点、右子节点大于父节点的性质。</p>
</li>
<li><p>删除（Deletion）：从树中移除一个节点。删除操作也需要遵循树的规则，例如在二叉搜索树中删除节点时需要调整树结构以保持排序性质。</p>
</li>
<li><p>查找（Search）：在树中搜索指定值或关键字。查找可以是深度优先搜索（DFS）或广度优先搜索（BFS）的形式，具体取决于树的遍历方式。</p>
</li>
<li><p>遍历（Traversal）：按照一定顺序访问树中的所有节点。常见的树遍历算法包括前序遍历、中序遍历和后序遍历，它们定义了节点的访问次序。</p>
</li>
<li><p>最小值和最大值查找：在树中查找最小值和最大值。在二叉搜索树中，最小值位于最左边的叶子节点，最大值位于最右边的叶子节点。</p>
</li>
<li><p>树的高度和大小计算：计算树的高度（从根节点到最远叶子节点的路径长度）和大小（树中节点的总数）。</p>
</li>
<li><p>平衡检查和平衡操作：对于具有平衡性要求的树，例如AVL树或红黑树，需要执行平衡检查和相应的平衡操作，以确保树的高度平衡。</p>
</li>
<li><p>迭代器操作：提供迭代器来顺序访问树的所有元素。迭代器可以按照预定义的顺序遍历树中的节点。</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以下是一个简单的树的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 树节点结构定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>                 <span class="token comment">// 节点数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> left<span class="token punctuation">;</span>    <span class="token comment">// 左子节点指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> right<span class="token punctuation">;</span>   <span class="token comment">// 右子节点指针</span>
<span class="token punctuation">&#125;</span> TreeNode<span class="token punctuation">;</span>

<span class="token comment">// 创建一个新节点</span>
TreeNode<span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    TreeNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 插入节点</span>
TreeNode<span class="token operator">*</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">createNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">></span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 在树中搜索指定值</span>
TreeNode<span class="token operator">*</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root<span class="token operator">-></span>data <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 中序遍历打印树节点</span>
<span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 主函数测试树的功能</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">// 插入节点</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 中序遍历打印树节点</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中序遍历结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 搜索节点</span>
    <span class="token keyword">int</span> searchData <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> searchResult <span class="token operator">=</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>searchResult <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"找到了节点 %d\n"</span><span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"未找到节点 %d\n"</span><span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个示例中，我们定义了一个<code>TreeNode</code>结构表示树的节点，在<code>createNode</code>函数中创建了新节点。<code>insertNode</code>函数用于插入新节点到树中，并保持排序性质。<code>searchNode</code>函数用于在树中搜索指定值。<code>inorderTraversal</code>函数用于中序遍历打印树节点。</p>
<p>在主函数中，我们通过调用<code>insertNode</code>函数插入节点到树中，并使用<code>inorderTraversal</code>函数进行中序遍历打印树节点。然后，我们使用<code>searchNode</code>函数搜索特定的值。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/linklist/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>链表是一种常用的动态数据结构，用于存储和组织数据。它由一系列节点（Node）组成，每个节点包含两部分：数据（data）和指向下一个节点的指针（next）。</p>
<p>链表的目的是在内存中灵活地存储和访问数据。与数组不同，链表的节点可以在内存中任意位置分布，而不需要连续的存储空间。这使得链表能够有效地处理插入、删除等操作，并且可以动态地调整大小。</p>
<p>链表有多种类型，其中最常见的两种是单向链表和双向链表。单向链表中，每个节点只有一个指向下一个节点的指针，而双向链表中，每个节点除了指向下一个节点的指针外，还有指向前一个节点的指针。</p>
<p>链表的优点：</p>
<ul>
<li>动态性：链表的大小可以根据需要进行动态调整，支持高效的插入和删除操作。</li>
<li>灵活性：链表可以存储不同类型的数据，节点之间的连接方式也可以根据需求进行变化。</li>
<li>内存利用率高：链表节点可以根据需求分散在内存中，不需要预先分配固定大小的连续空间。</li>
</ul>
<p>链表的缺点：</p>
<ul>
<li>随机访问性能较差：由于链表中的节点不是连续存储的，如果需要访问特定位置的数据，需要从头节点开始遍历。</li>
<li>需要额外的内存空间：链表中的每个节点都需要额外的指针来存储连接关系，这增加了一定的内存开销。</li>
</ul>
<h2 id="特点和属性"><a href="#特点和属性" class="headerlink" title="特点和属性"></a>特点和属性</h2><p>链表的主要特点和属性如下：</p>
<ol>
<li><p>动态性：链表的大小可以根据需要动态调整，支持高效的插入和删除操作。</p>
</li>
<li><p>灵活性：链表可以存储不同类型的数据，节点之间的连接方式也可以根据需求变化。</p>
</li>
<li><p>内存利用率高：链表的节点可以分散在内存中，不需要预先分配固定大小的连续空间。</p>
</li>
<li><p>随机访问性能较差：由于链表中的节点不是连续存储的，如果需要访问特定位置的数据，需要从头节点开始遍历。这导致链表的随机访问效率较低。</p>
</li>
<li><p>额外的指针开销：链表中的每个节点都需要额外的指针来存储连接关系，这增加了一定的内存开销。</p>
</li>
<li><p>时间复杂度分析：链表中插入和删除一个节点的时间复杂度为O(1)，因为只需要修改节点的指针即可。然而，查找特定节点的时间复杂度为O(n)，其中n是链表的长度。</p>
</li>
<li><p>空间要求：链表需要额外的指针来存储连接关系，因此相对于数组等数据结构，链表需要更多的内存空间。</p>
</li>
</ol>
<p>适用场景：</p>
<ul>
<li>当需要频繁执行插入和删除操作，而对查找操作的要求相对较低时，链表是一个很好的选择。</li>
<li>当预先不知道需要存储多少元素时，链表可以动态地调整大小。</li>
<li>在内存有限且大小未知的情况下，链表可以提供更好的空间利用率。</li>
</ul>
<p>限制：</p>
<ul>
<li>如果需要频繁进行随机访问，链表的性能会比较差。在这种情况下，数组可能是更好的选择。</li>
<li>链表需要额外的指针来维护连接关系，因此相对于数组等数据结构，链表会占用更多的内存空间。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>链表支持以下基本操作：</p>
<ol>
<li><p>插入节点（Insertion）：在链表中插入一个新节点。可以在链表的开头、结尾或指定位置插入节点。</p>
</li>
<li><p>删除节点（Deletion）：从链表中删除指定节点。可以根据节点的值或位置来删除。</p>
</li>
<li><p>遍历链表（Traversal）：按顺序访问链表中的每个节点，以便读取或处理节点的数据。</p>
</li>
<li><p>查找节点（Search）：根据给定的值或条件，搜索链表中特定的节点。可以返回第一个匹配的节点或所有匹配的节点。</p>
</li>
<li><p>获取节点数量（Count）：计算链表中节点的数量。</p>
</li>
<li><p>判空（Empty Check）：检查链表是否为空。</p>
</li>
<li><p>反转链表（Reverse）：将链表中的节点顺序反转。</p>
</li>
<li><p>合并链表（Merge）：将两个有序链表合并成一个有序链表。</p>
</li>
<li><p>获取链表长度（Length）：计算链表的长度。</p>
</li>
</ol>
<p>这些操作使得我们能够有效地操作和管理链表中的数据。具体的实现方式会根据链表类型（如单向链表或双向链表）而有所不同。对于每个操作，需要考虑边界情况（如插入&#x2F;删除首尾节点、空链表等）和错误处理（如节点不存在等）以保证链表的正确性和稳定性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以下是一个简单的C语言实现单向链表的例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 定义链表节点结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>           <span class="token comment">// 节点数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>  <span class="token comment">// 指向下一个节点的指针</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token comment">// 插入节点到链表头部</span>
<span class="token keyword">void</span> <span class="token function">insertAtHead</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新节点</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                         <span class="token comment">// 设置节点数据</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>                        <span class="token comment">// 将新节点的指针指向当前头节点</span>
    <span class="token operator">*</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                              <span class="token comment">// 更新头节点为新节点</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 插入节点到链表尾部</span>
<span class="token keyword">void</span> <span class="token function">insertAtTail</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新节点</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                         <span class="token comment">// 设置节点数据</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                         <span class="token comment">// 将新节点的指针设置为NULL</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                          <span class="token comment">// 如果链表为空，直接将新节点设为头节点</span>
        <span class="token operator">*</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    Node<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 找到链表的尾节点</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                         <span class="token comment">// 将新节点连接到尾节点的后面</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 删除指定值的节点</span>
<span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>          <span class="token comment">// 用于记录要删除节点的前一个节点</span>
    Node<span class="token operator">*</span> curr <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>         <span class="token comment">// 用于遍历链表</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>data <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果要删除的是头节点</span>
        <span class="token operator">*</span>head <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>data <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 查找要删除的节点</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 如果没有找到要删除的节点</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Node not found.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    prev<span class="token operator">-></span>next <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>                    <span class="token comment">// 将要删除节点的前一个节点指向要删除节点的下一个节点</span>
    <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">// 释放要删除节点的内存空间</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印链表元素</span>
<span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> temp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 主函数测试链表操作</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化链表为空</span>

    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Linked list: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出链表内容：1 2 3</span>

    <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除值为2的节点</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Linked list after deleting node with value 2: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出链表内容：1 3</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="应用和示例"><a href="#应用和示例" class="headerlink" title="应用和示例"></a>应用和示例</h2><p>链表在各个领域中有广泛的应用，以下是一些常见的应用和实际示例：</p>
<ol>
<li><p>数据结构实现：链表是许多其他数据结构的基础，比如栈、队列和图等。链表的动态性和灵活性使得它们成为这些数据结构的核心组成部分。</p>
</li>
<li><p>文件系统：文件系统使用链表来组织文件和目录的层次结构。每个目录节点可以包含指向子目录或文件的指针，从而形成一个树状结构。</p>
</li>
<li><p>缓存管理：链表可用于实现缓存替换算法，例如LRU（最近最少使用）算法。LRU缓存将最近使用的项放在链表的头部，当缓存满时，删除链表尾部的项。</p>
</li>
<li><p>高级程序设计语言中的垃圾回收器：链表被广泛用于实现垃圾回收机制。垃圾回收器使用链表来跟踪分配的内存块，并在不再使用时回收这些块。</p>
</li>
<li><p>网络流量管理：链表可以用于追踪路由器或交换机中的网络流量。每个数据包都可以表示为一个节点，并通过链表进行管理和处理。</p>
</li>
<li><p>游戏开发：链表可以用于管理游戏中的对象，如角色、敌人、子弹等。通过链表，可以轻松地添加、删除和遍历游戏对象。</p>
</li>
</ol>
<p>与其他数据结构相比，链表具有一些独特的优势和特点：</p>
<ul>
<li>相对于数组，链表的大小可以动态调整，不需要预先分配固定大小的连续空间。</li>
<li>插入和删除节点的操作效率高，时间复杂度为O(1)。</li>
<li>链表可以存储不同类型的数据，节点之间的连接方式可以根据需要进行变化。</li>
</ul>
<p>然而，链表也有一些限制：</p>
<ul>
<li>随机访问性能较差，需要从头节点开始遍历以获取指定位置的节点。</li>
<li>需要额外的指针来存储连接关系，增加了一定的内存开销。</li>
</ul>
<p>因此，在选择数据结构时，需要根据具体需求权衡利弊。链表适用于频繁插入和删除操作、动态大小需求或对内存空间有限制的场景。在需要快速随机访问和对空间利用率有严格要求的情况下，可能需要考虑其他数据结构，如数组。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/list/</url>
    <content><![CDATA[<blockquote>
<p>队列，又称为伫列（queue），计算机科学中的一种抽象资料类型，是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>队列是一种基本的数据结构，用于存储元素集合，并按照先进先出（First-In-First-Out, FIFO）的原则进行管理。它类似于现实生活中排队等待服务的场景。</p>
<p>队列的定义包括以下几个关键点：</p>
<ul>
<li>元素插入操作只能在队列的末尾进行，而元素移除操作只能从队列的开头进行。</li>
<li>插入操作称为入队（enqueue），移除操作称为出队（dequeue）。</li>
<li>队列可以为空，也可以有限制长度。</li>
<li>队列内元素的顺序由其插入的顺序决定，最早插入的元素最先被移除。</li>
</ul>
<p>队列的目的主要在于提供一种有序处理元素的方式，以满足特定的需求。以下是队列的一些常见应用场景和目的：</p>
<ul>
<li>任务调度：使用队列可以按照特定的顺序调度和执行任务，确保任务按照先后顺序完成。</li>
<li>广度优先搜索（BFS）：在图或树的遍历中，使用队列来保存待访问的节点，以确保按层次顺序进行遍历。</li>
<li>缓冲区：队列可以作为缓冲区，允许生产者将数据放入队列，然后消费者按照相同的顺序取出数据进行处理。</li>
<li>管理资源共享：多个进程或线程需要访问共享资源时，使用队列可以确保公平地分配资源，避免数据竞争。</li>
<li>消息传递系统：在分布式系统或通信系统中，消息队列用于实现异步通信，降低系统间耦合性。</li>
</ul>
<h2 id="特点和属性"><a href="#特点和属性" class="headerlink" title="特点和属性"></a>特点和属性</h2><p>队列具有以下主要特点和属性：</p>
<ol>
<li><p>先进先出（FIFO）：最先插入的元素最先被移除，保持元素按照插入顺序进行处理。</p>
</li>
<li><p>插入操作只在队尾：新元素只能被添加到队列的末尾。</p>
</li>
<li><p>移除操作只在队头：只能从队列的开头移除元素。</p>
</li>
<li><p>有限长度或无限长度：队列可以有限长度，即固定容量，也可以是无限长度，即不受容量限制。</p>
</li>
<li><p>空队列和满队列：队列可以为空（没有元素）或满（达到了容量上限）。</p>
</li>
</ol>
<p>对于队列的优势、限制和适用场景，我们可以考虑以下方面的特点：</p>
<ul>
<li><p><strong>复杂度分析</strong>：插入（enqueue）和删除（dequeue）操作的时间复杂度为O(1)，即常数时间。因此，队列操作的效率很高。</p>
</li>
<li><p><strong>空间要求</strong>：队列通常需要连续的内存空间来存储元素。具体的空间需求取决于队列的长度和元素的大小。</p>
</li>
<li><p><strong>操作效率</strong>：由于队列遵循先进先出原则，它在处理需要按照顺序进行的任务时非常有效。然而，如果需要在队列中间插入或删除元素，效率将比较低。</p>
</li>
<li><p><strong>适用场景</strong>：队列在许多应用中都非常有用。例如，广度优先搜索（BFS）算法、任务调度、消息传递系统等都可以使用队列来实现。队列还能够解决需要按照特定顺序处理元素的问题。</p>
</li>
<li><p><strong>限制</strong>：队列的主要限制之一是容量限制。当队列达到其最大容量时，无法再插入新元素，即队列为满状态。此外，由于插入和删除操作只能在两端进行，如果需要频繁地在队列中间执行插入或删除操作，可能会导致性能下降。</p>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>要实现和使用队列，我们可以考虑以下几个基本操作：插入（enqueue）、删除（dequeue）和查找队首元素（peek）。下面是一种基本的队列实现方式：</p>
<ol>
<li><p>使用数组：我们可以使用数组来实现队列。创建一个固定大小的数组，并定义两个指针front和rear。</p>
</li>
<li><p>插入（enqueue）操作：</p>
<ul>
<li>检查队列是否已满。如果rear指针等于数组的长度减1，表示队列已满。</li>
<li>将新元素添加到rear指针所在位置的后一位。</li>
<li>更新rear指针，使其指向新添加的元素。</li>
</ul>
</li>
<li><p>删除（dequeue）操作：</p>
<ul>
<li>检查队列是否为空。如果front指针等于rear指针，表示队列为空。</li>
<li>移除front指针所在位置的元素。</li>
<li>更新front指针，使其指向下一个元素。</li>
</ul>
</li>
<li><p>查找队首元素（peek）操作：</p>
<ul>
<li>检查队列是否为空。如果front指针等于rear指针，表示队列为空。</li>
<li>返回front指针所在位置的元素。</li>
</ul>
</li>
</ol>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>以下是使用数组实现队列的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义队列结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span>

<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否为空</span>
<span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否已满</span>
<span class="token keyword">int</span> <span class="token function">isFull</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>rear <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入队操作</span>
<span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is full. Cannot enqueue %d\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    queue<span class="token operator">-></span>rear<span class="token operator">++</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d enqueued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出队操作</span>
<span class="token keyword">int</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot dequeue.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> queue<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d dequeued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 查找队首元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot peek.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Queue myQueue<span class="token punctuation">;</span>
    <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element after dequeuing: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述示例代码中，我们使用了一个包含固定大小数组的队列结构体。通过<code>initQueue</code>函数初始化队列，并用<code>enqueue</code>和<code>dequeue</code>函数进行元素的入队和出队操作。<code>peek</code>函数用于查找队首元素。最后，在<code>main</code>函数中展示了如何创建队列、进行基本操作，并输出一些结果。</p>
<p>以下是使用链表实现队列的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 定义链表节点结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token comment">// 定义队列结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> front<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span>

<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否为空</span>
<span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入队操作</span>
<span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d enqueued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出队操作</span>
<span class="token keyword">int</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot dequeue.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> temp <span class="token operator">=</span> queue<span class="token operator">-></span>front<span class="token punctuation">;</span>
    value <span class="token operator">=</span> temp<span class="token operator">-></span>data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> queue<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> queue<span class="token operator">-></span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d dequeued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 查找队首元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot peek.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> queue<span class="token operator">-></span>front<span class="token operator">-></span>data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Queue myQueue<span class="token punctuation">;</span>
    <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element after dequeuing: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例代码中，我们使用一个包含链表节点的队列结构体。通过<code>initQueue</code>函数初始化队列，并用<code>enqueue</code>和<code>dequeue</code>函数进行元素的入队和出队操作。<code>peek</code>函数用于查找队首元素。最后，在<code>main</code>函数中展示了如何创建队列、进行基本操作，并输出一些结果。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/stack/</url>
    <content><![CDATA[<blockquote>
<p>堆栈（stack）又称为栈或堆叠，是计算机科学中的一种抽象资料类型，只允许在有序的线性资料集合的一端（称为堆栈顶端，top）进行加入数据（push）和移除数据（pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作，堆栈常用一维数组或链接串列来实现。常与另一种有序的线性资料集合队列相提并论。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种线性数据结构，用于存储和管理数据元素。它支持两个主要操作：压入（Push）将元素添加到栈的顶部，弹出（Pop）从栈的顶部移除元素。栈还提供了一个检查栈顶元素的操作（Top）。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>栈通常被用于需要按照特定顺序处理或管理元素的场景。它可以帮助实现递归算法、括号匹配、表达式求值、函数调用等。栈的设计目的是提供一种快速有效的数据访问方式，并且在插入和删除元素时具有常数时间复杂度。</p>
<h2 id="特点与属性"><a href="#特点与属性" class="headerlink" title="特点与属性"></a>特点与属性</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>后进先出（LIFO）：栈中最后插入的元素是第一个被访问和移除的。</li>
<li>仅允许在栈顶进行操作：只能对栈顶元素进行插入、删除、查看等操作，而不能直接访问或修改其他元素。</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>简单高效：栈的操作时间复杂度为O(1)，即常数时间，因为只需修改栈顶指针即可。</li>
<li>节省空间：栈可以使用连续的内存块实现，不需要额外的指针或链表结构。</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>容量限制：栈的容量可能有限，当栈满时无法再插入新元素，可能导致溢出错误。</li>
<li>访问限制：只能访问栈顶元素，如果需要访问其他位置的元素，需要先将栈顶元素出栈。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>函数调用栈：用于保存函数调用过程中的局部变量、返回地址等信息。</li>
<li>表达式求值：用于计算中缀表达式转换为后缀表达式，并进行运算。</li>
<li>括号匹配：用于检查表达式中的括号是否匹配。</li>
<li>历史记录：用于实现撤销、恢复等操作。</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：栈的插入、删除、查看等操作都只涉及栈顶元素，时间复杂度为O(1)。</li>
<li>空间复杂度：栈的空间复杂度与存储的元素数量成线性关系，即O(n)，其中n为栈中元素的个数。但通常情况下，栈的空间需求不会随输入规模的增长而线性增加，因为栈可以重复利用已分配的内存空间。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>栈可以通过数组或链表来实现。下面将涵盖基本的操作，包括插入（压栈）、删除（弹栈）和查找（获取栈顶元素）。</p>
<ol>
<li>使用数组实现栈：</li>
</ol>
<ul>
<li>创建一个数组，并定义一个指针top用于记录栈顶位置。</li>
<li>插入（压栈）操作：将元素添加到top指向的位置，并将top加1。</li>
<li>删除（弹栈）操作：将top减1，并返回top指向的元素作为弹栈结果。</li>
<li>查找（获取栈顶元素）操作：返回top指向的元素。</li>
</ul>
<ol start="2">
<li>使用链表实现栈：</li>
</ol>
<ul>
<li>创建一个链表，并定义一个指针top指向链表的头部（栈顶）。</li>
<li>插入（压栈）操作：创建一个新节点，将其链接到链表的头部，并更新top指针指向新节点。</li>
<li>删除（弹栈）操作：移动top指针到下一个节点，并返回原top指向的节点的值作为弹栈结果。</li>
<li>查找（获取栈顶元素）操作：返回top指向的节点的值。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>以下是使用数组实现栈的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义栈结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> stack<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Stack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否为空</span>
<span class="token keyword">int</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否已满</span>
<span class="token keyword">int</span> <span class="token function">is_full</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入栈操作</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Overflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出栈操作</span>
<span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Underflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 获取栈顶元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Stack my_stack<span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试入栈操作</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试出栈操作</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试获取栈顶元素</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Top element: %d\n"</span><span class="token punctuation">,</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>以下是使用链表实现栈的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义栈结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> stack<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Stack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否为空</span>
<span class="token keyword">int</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否已满</span>
<span class="token keyword">int</span> <span class="token function">is_full</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入栈操作</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Overflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出栈操作</span>
<span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Underflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 获取栈顶元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Stack my_stack<span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试入栈操作</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试出栈操作</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试获取栈顶元素</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Top element: %d\n"</span><span class="token punctuation">,</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="应用和示例"><a href="#应用和示例" class="headerlink" title="应用和示例"></a>应用和示例</h2><p>栈作为一种简单高效的数据结构，在各个领域中有许多常见应用和实际示例。以下是一些常见的应用和示例：</p>
<ol>
<li><p>函数调用栈：栈在编程语言中的函数调用过程中发挥着重要作用。每当一个函数被调用，栈会保存调用前的状态（如返回地址、局部变量等），以便在函数执行完毕后能够正确返回到调用点。</p>
</li>
<li><p>表达式求值：在表达式求值过程中，栈可以用于转换中缀表达式为后缀表达式，并进行运算。栈可用于保存操作符，按照优先级对操作符进行排序，并确保正确的计算顺序。</p>
</li>
<li><p>括号匹配：栈在括号匹配中非常有用。通过遍历字符串中的字符，将左括号入栈，当遇到右括号时，检查栈顶元素是否与其对应的左括号匹配。如果匹配，则弹出栈顶元素；如果不匹配，则括号不匹配。</p>
</li>
<li><p>十进制转二进制&#x2F;十六进制：使用栈可以将十进制数转换为二进制或十六进制。通过对十进制数连续进行除法操作，并将余数入栈，最后将栈中的余数依次出栈即可得到相应的二进制或十六进制表示。</p>
</li>
<li><p>撤销&#x2F;恢复操作：在编辑器、图形界面设计等应用中，栈可以用于实现撤销和恢复功能。每次用户执行操作时，将操作记录保存在栈中。当用户希望撤销操作时，从栈中弹出最近的操作，并对应地进行撤销操作。</p>
</li>
</ol>
<p>与其他数据结构相比，栈具有自身的优势和适用性。相对于数组，栈的插入和删除操作更加高效，并且不需要预先知道存储元素的数量。与链表相比，栈仅涉及栈顶元素的操作，没有指针域的访问和修改，因此操作更加简单有效。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>多维数组</title>
    <url>/yangtong.github.io/2023/07/14/datastruct/multarray/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>多维数组是一种扩展的数组数据结构，用于存储具有多个维度的元素集合。与一维数组类似，多维数组也提供了连续的内存空间来存储数据，并使用多个索引来访问和操作元素。以下是对多维数组的概述：</p>
<p>多维数组是一种灵活且强大的数据结构，常用于矩阵、图像处理、科学计算等领域。它提供了一种有效的方式来组织和操作具有多个维度的数据集合，使得数据的表示和处理更加直观和高效。</p>
<span id="more"></span>
<h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p>多维数组是一个具有多个维度的数据集合，其中的元素具有相同的数据类型。每个维度代表一个独立的索引范围，用于标识元素在多维数组中的位置。例如，二维数组由行和列两个维度组成，可以通过行和列的索引来访问元素。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>多维数组在内存中以类似于矩阵的方式排列，其中的元素按照行优先或列优先的顺序存储。在二维数组中，每行的元素紧邻存放，而各行之间相隔整个一行大小的内存空间。三维及更高维度的数组也遵循类似的规则。</p>
<h2 id="索引和访问"><a href="#索引和访问" class="headerlink" title="索引和访问"></a>索引和访问</h2><p>多维数组的元素可以通过多个索引进行访问和操作。对于二维数组，可以使用两个索引（行索引和列索引）来指定元素的位置。例如，要访问二维数组arr中的第i行、第j列的元素，可以使用arr[i][j]来获取或修改该元素的值。</p>
<h2 id="大小和边界检查"><a href="#大小和边界检查" class="headerlink" title="大小和边界检查"></a>大小和边界检查</h2><p>多维数组的大小在创建时指定，并且各个维度的大小可以不相同。在访问多维数组元素时，需要确保每个索引在其对应维度范围内以避免越界错误。</p>
<h2 id="多维数组的优点和缺点"><a href="#多维数组的优点和缺点" class="headerlink" title="多维数组的优点和缺点"></a>多维数组的优点和缺点</h2><ul>
<li>优点：多维数组提供了一种方便的方式来存储和处理具有多个维度的数据。它可以直观地表示复杂的结构和关系，并提供高效的元素访问能力。</li>
<li>缺点：多维数组可能会占用较大的内存空间，尤其是当维度较高时。另外，多维数组的创建和操作可能更复杂和容易出错，特别是在维度和索引管理方面。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>一般形式如下</p>
<pre class="line-numbers language-none"><code class="language-none">type name[size1][size2]...[sizeN];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>例如，下面的声明创建了一个三维 5 x 10 x 4 整型数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> threedim<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">type arrayName [ x ][ y ];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，type 可以是任意有效的 C 数据类型，arrayName 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/yangtong.github.io/images/muarray.png"></p>
<p>因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。</p>
<h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><p>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  
 <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token punctuation">,</span>   <span class="token comment">/*  初始化索引号为 0 的行 */</span>
 <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span> <span class="token punctuation">,</span>   <span class="token comment">/*  初始化索引号为 1 的行 */</span>
 <span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span>   <span class="token comment">/*  初始化索引号为 2 的行 */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 定义并初始化一个2x3的二维数组</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="访问二维数组元素"><a href="#访问二维数组元素" class="headerlink" title="访问二维数组元素"></a>访问二维数组元素</h3><p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> val <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
   <span class="token comment">/* 一个带有 5 行 2 列的数组 */</span>
   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
 
   <span class="token comment">/* 输出数组中每个元素的值 */</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d][%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre class="line-numbers language-none"><code class="language-none">a[0][0] &#x3D; 0
a[0][1] &#x3D; 0
a[1][0] &#x3D; 1
a[1][1] &#x3D; 2
a[2][0] &#x3D; 2
a[2][1] &#x3D; 4
a[3][0] &#x3D; 3
a[3][1] &#x3D; 6
a[4][0] &#x3D; 4
a[4][1] &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/yangtong.github.io/2023/07/14/datastruct/array/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
</blockquote>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数组是一种常见的数据结构，用于存储相同类型的元素的集合。它提供了一种连续的内存空间来存储数据，并使用索引来访问和操作元素。</p>
<p>数组是一种简单但强大的数据结构，广泛应用于编程和算法中。它提供了高效的元素访问和处理能力，适合用于存储和处理静态或有序的数据集合。</p>
<h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p>数组是一个有序的数据集合，其中的元素具有相同的数据类型。数组的大小（即元素数量）在创建时就确定，并且通常在运行时不可更改。每个数组元素都有一个唯一的索引，用于标识其在数组中的位置。</p>
<p><img src="/yangtong.github.io/images/array1.png"></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>数组在内存中以连续的方式存储元素。这意味着数组的各个元素占用相邻的内存地址，可以通过偏移量和元素大小来计算和访问特定索引处的元素。由于连续的内存分配，数组具有快速的随机访问能力。</p>
<h2 id="索引和访问"><a href="#索引和访问" class="headerlink" title="索引和访问"></a>索引和访问</h2><p>数组中的元素可以通过索引进行访问和操作。索引通常从0开始，依次递增。例如，要访问数组arr中的第i个元素，可以使用arr[i]来获取或修改该元素的值。由于索引从0开始，因此最后一个元素的索引是数组大小减1。</p>
<h2 id="大小和边界检查"><a href="#大小和边界检查" class="headerlink" title="大小和边界检查"></a>大小和边界检查</h2><p>数组的大小在创建时指定，并且不能动态调整。因此，在使用数组之前，需要明确知道数组的大小。在访问数组元素时，应进行边界检查以确保索引不超出数组范围，否则可能导致访问越界错误。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>除了一维数组外，还可以创建多维数组，如二维、三维等。多维数组在内存中以类似于矩阵的方式排列，通过多个索引来访问元素。例如，二维数组可以使用arr[i][j]的形式来访问其中的元素。</p>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li>优点：快速随机访问，节省内存空间，直观表示数据的顺序性。</li>
<li>缺点：大小固定，插入和删除元素的操作效率低，如果需要频繁改变大小或执行插入&#x2F;删除操作，使用动态数据结构（如链表）更合适。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    array<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组长度为: %d\n"</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
   <span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* n 是一个包含 10 个整数的数组 */</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
 
   <span class="token comment">/* 初始化数组元素 */</span>         
   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
        n<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* 设置元素 i 为 i + 100 */</span>
   <span class="token punctuation">&#125;</span>
   
   <span class="token comment">/* 输出数组中每个元素的值 */</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Element[%d] = %d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> n<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/yangtong.github.io/2023/07/10/c/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/yangtong.github.io/2023/07/10/cplusplus/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11</title>
    <url>/yangtong.github.io/2023/07/10/cplusplus11/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件</title>
    <url>/yangtong.github.io/2023/07/10/middleware/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/yangtong.github.io/2023/07/10/datastruct/datastruct/</url>
    <content><![CDATA[<blockquote>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
</blockquote>
<span id="more"></span>
<h2 id="概念与定义"><a href="#概念与定义" class="headerlink" title="概念与定义"></a>概念与定义</h2><blockquote>
<p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。</p>
</blockquote>
<blockquote>
<p>简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
</blockquote>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><h3 id="数据逻辑结构"><a href="#数据逻辑结构" class="headerlink" title="数据逻辑结构"></a>数据逻辑结构</h3><p>指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括：</p>
<ol>
<li>集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系<br><img src="/yangtong.github.io/images/set.png"></li>
<li>线性结构：数据结构中的元素存在一对一的相互关系<br><img src="/yangtong.github.io/images/array.png"></li>
<li>树形结构：数据结构中的元素存在一对多的相互关系<br><img src="/yangtong.github.io/images/tree.png"></li>
<li>图形结构：数据结构中的元素存在多对多的相互关系<br><img src="/yangtong.github.io/images/graph.png"></li>
</ol>
<h3 id="数据物理结构"><a href="#数据物理结构" class="headerlink" title="数据物理结构"></a>数据物理结构</h3><p>数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。</p>
<h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。</p>
<p>常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。</p>
<ul>
<li>数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；</li>
<li>非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括线性结构和非线性结构两类。 </p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>简单地说，线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点： </p>
<ol>
<li>线性结构是非空集。 </li>
<li>线性结构有且仅有一个开始结点和一个终端结点。 </li>
<li>线性结构所有结点都最多只有一个直接前驱结点和一个直接后继结点。</li>
</ol>
<p>常见的线性结构：</p>
<ol>
<li>数组（Array）</li>
<li>链表（Linked List）</li>
<li>栈（Stack）</li>
<li>队列（Queue）</li>
<li>双端队列（Deque）</li>
<li>线性表（List）</li>
</ol>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>简单地说，非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点： </p>
<ol>
<li>非线性结构是非空集。 </li>
<li>非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点。</li>
</ol>
<p>常见的非线性结构：</p>
<ol>
<li>树（Tree）</li>
<li>图（Graph）</li>
<li>堆（Heap）</li>
<li>散列表（Hash Table）</li>
<li>图论中的树和森林</li>
</ol>
<h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 </p>
<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈( Stack)"></a>栈( Stack)</h3><p>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照先进后出或后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 </p>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。 </p>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表( Linked List)"></a>链表( Linked List)</h3><p>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 </p>
<h2 id="树形数据结构"><a href="#树形数据结构" class="headerlink" title="树形数据结构"></a>树形数据结构</h2><p>树形数据结构是一种分层的、非线性的数据结构，由节点和边组成。它模拟了现实世界中的树结构，具有一个根节点以及零个或多个子节点。树形数据结构在计算机科学中有广泛的应用，如文件系统、数据库索引、组织结构等。</p>
<h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树( Tree)"></a>树( Tree)</h3><p>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。 </p>
<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树可以是空树，也可以只有根节点。</p>
<ul>
<li>完全二叉树（Complete Binary Tree）：除了最后一层外，其他层的节点都要填满，且最后一层从左到右连续填入节点。</li>
<li>满二叉树（Full Binary Tree）：每个节点要么没有子节点，要么有两个子节点。<br>二叉搜索树（Binary Search Tree）：二叉搜索树是一种有序的二叉树，其中任意节点的值都大于其左子树中的所有节点的值，而小于其右子树中的所有节点的值。这使得查找、插入和删除操作的时间复杂度可以在平均情况下达到 O(log n)。</li>
</ul>
<h3 id="AVL-树（Adelson-Velsky-and-Landis-Tree）"><a href="#AVL-树（Adelson-Velsky-and-Landis-Tree）" class="headerlink" title="AVL 树（Adelson-Velsky and Landis Tree）"></a>AVL 树（Adelson-Velsky and Landis Tree）</h3><p>AVL 树是一种自平衡的二叉搜索树，它通过旋转操作来保持树的平衡性。在 AVL 树中，任意节点的左子树和右子树的高度差（平衡因子）不超过 1。</p>
<h3 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red-Black Tree）"></a>红黑树（Red-Black Tree）</h3><p>红黑树也是一种自平衡的二叉搜索树，它通过颜色标记来保持树的平衡性。在红黑树中，节点被标记为红色或黑色，并且遵循一些规则，如根节点和叶子节点（NIL 节点）都是黑色，红色节点的子节点必须是黑色等。</p>
<h3 id="B-树（B-Tree）"><a href="#B-树（B-Tree）" class="headerlink" title="B 树（B-Tree）"></a>B 树（B-Tree）</h3><p>B 树是一种多路搜索树，用于处理大量数据的外部存储器操作。它具有多个子节点和一个关键字集合，可以支持高效的插入、删除和查找操作。B 树适用于磁盘或其他随机访问时间较长的存储设备。</p>
<h3 id="字典树（Trie）"><a href="#字典树（Trie）" class="headerlink" title="字典树（Trie）"></a>字典树（Trie）</h3><p>字典树是一种专门为快速查找和插入单词而设计的树结构。每个节点代表一个字符，并且从根节点到叶子节点的路径构成了一个完整的单词。字典树通常用于实现字典、拼写检查和字符串匹配算法。</p>
<h2 id="图形数据结构"><a href="#图形数据结构" class="headerlink" title="图形数据结构"></a>图形数据结构</h2><p>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><ul>
<li>无向图是一种图形数据结构，其中的边没有方向或箭头。任意两个节点之间的连接都是双向的。</li>
<li>无向图可以用邻接矩阵或邻接表来表示。邻接矩阵是一个二维数组，用于记录节点之间的连接关系；邻接表是一个链表数组，每个节点都有一个链表存储与其相连的节点。</li>
</ul>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><ul>
<li>有向图是一种图形数据结构，其中的边具有方向或箭头，表示从一个节点指向另一个节点的关系。</li>
<li>有向图也可以用邻接矩阵或邻接表来表示。邻接矩阵是一个二维数组，其中的元素表示边的方向和权重；邻接表是一个链表数组，每个节点都有一个链表存储从该节点出发的边和目标节点。</li>
</ul>
<h3 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h3><ul>
<li>加权图是一种图形数据结构，在边上附加了权重或成本信息。这些权重可以表示距离、时间、容量等。</li>
<li>加权图可以用邻接矩阵或邻接表来表示，与无向图和有向图类似。不同之处在于邻接矩阵的元素表示边的权重，而邻接表中的链表节点包含权重信息。</li>
</ul>
<h2 id="散列（哈希）数据结构"><a href="#散列（哈希）数据结构" class="headerlink" title="散列（哈希）数据结构"></a>散列（哈希）数据结构</h2><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列（哈希）数据结构是一种通过使用哈希函数将键映射到存储位置的数据结构。它可以高效地插入、查找和删除数据。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/yangtong.github.io/2023/07/10/algorihtm/algorihtm/</url>
    <content><![CDATA[<blockquote>
<p>算法（英语：algorithm），在数学（算学）和计算机科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序[1]，常用于计算、数据处理和自动推理。算法是有效方法，包含一系列定义清晰的指令[2]，并可于有限的时间及空间内清楚的表述出来[3]。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>算法具有以下几个主要特点：</p>
<ol>
<li><p>输入：算法接受输入数据，这些数据可能是预先给定的或通过外部来源获取的。</p>
</li>
<li><p>输出：算法产生输出结果，输出可以是一个值、一组值、数据结构、文件等。</p>
</li>
<li><p>确定性：算法中的每一步都必须明确定义，无二义性。对于相同的输入，算法将始终产生相同的输出。</p>
</li>
<li><p>有限性：算法必须在有限的步骤之后终止。这是因为算法中不能包含无限循环或递归。</p>
</li>
<li><p>可行性：算法的每个步骤都必须可行，即能够在有限时间内执行完成。</p>
</li>
<li><p>独立性：算法应该是独立的，即不依赖于特定的硬件或操作系统。</p>
</li>
<li><p>利用资源：算法可以使用计算机的处理能力、内存空间和其他资源，以实现所需的计算过程。</p>
</li>
<li><p>优化性能：好的算法应该尽量优化性能，例如时间复杂度和空间复杂度，以提高执行效率。</p>
</li>
<li><p>可读性：算法应该易于理解和阅读，使人们能够理解其思想和实现。</p>
</li>
<li><p>可扩展性：算法应该能够在需要时进行扩展和修改，以适应不同的数据规模或问题要求。</p>
</li>
</ol>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>评估算法的复杂度是为了衡量算法在不同输入规模下所需的计算资源（如时间和空间）的增长情况。常用的评估指标包括时间复杂度和空间复杂度。</p>
<ol>
<li><p>时间复杂度（Time Complexity）：表示算法执行所需的时间量级。它描述了算法运行时间随着输入规模增加而增长的速率。通常使用大 O 记法来表示时间复杂度。例如，O(1) 表示常数时间复杂度，O(log n) 表示对数时间复杂度，O(n) 表示线性时间复杂度，O(n^2) 表示平方时间复杂度等。时间复杂度可以帮助我们比较不同算法之间的效率，并预测算法在大型输入上的表现。</p>
</li>
<li><p>空间复杂度（Space Complexity）：表示算法所需的额外空间或内存的量级。它描述了算法消耗的空间随着输入规模增加而增长的速率。类似于时间复杂度，空间复杂度也使用大 O 记法来表示。例如，O(1) 表示常数空间复杂度，O(n) 表示线性空间复杂度，O(n^2) 表示平方空间复杂度等。空间复杂度可以帮助我们评估算法在内存使用方面的效率，并预测算法在大规模数据上的可行性。</p>
</li>
</ol>
<p>评估算法复杂度时，需要考虑最坏情况下的时间和空间消耗。通常关注最高阶的项，忽略低阶项和常数因子，以及对于非常大的输入规模，更关注增长最快的项。</p>
<p>通过分析和评估算法的复杂度，我们可以选择更有效的算法来解决问题，并做出合理的时间和空间优化。</p>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>常见的算法有很多，以下列举了一些常见的算法：</p>
<h3 id="排序算法（Sorting-Algorithms）"><a href="#排序算法（Sorting-Algorithms）" class="headerlink" title="排序算法（Sorting Algorithms）"></a>排序算法（Sorting Algorithms）</h3><ol>
<li><p>冒泡排序（Bubble Sort）：重复比较相邻的两个元素，如果顺序错误则交换它们。通过多次遍历，将最大（或最小）的元素逐渐移到数组的末尾。</p>
</li>
<li><p>插入排序（Insertion Sort）：将未排序部分的每个元素插入到已排序部分的合适位置。从第二个元素开始，逐个将元素插入到前面已排序的部分。</p>
</li>
<li><p>选择排序（Selection Sort）：在未排序部分中选择最小（或最大）的元素，并将其与未排序部分的第一个元素进行交换。通过多次遍历，将最小（或最大）的元素逐渐移到数组的开头。</p>
</li>
<li><p>快速排序（Quick Sort）：选择一个基准元素，将数组分成两个子数组，使得左子数组所有元素都小于基准，右子数组所有元素都大于基准，然后对子数组递归地应用快速排序。</p>
</li>
<li><p>归并排序（Merge Sort）：将数组不断二分，直到只剩一个元素，然后将这些单个元素按顺序合并为有序数组。通过递归不断合并，最终得到完全有序的数组。</p>
</li>
<li><p>堆排序（Heap Sort）：将待排序的元素构建成一个堆，然后反复从堆顶取出最大（或最小）的元素，并将其与堆的最后一个位置交换，再重新调整堆，直到所有元素都排序完成。</p>
</li>
<li><p>希尔排序（Shell Sort）：将待排序的元素按一定间隔分组，然后对每个分组进行插入排序。逐渐缩小间隔，直到间隔为1，最后进行一次完整的插入排序。</p>
</li>
<li><p>计数排序（Counting Sort）：统计数组中每个元素的出现次数，并根据统计信息将元素按顺序放置在输出数组中。适用于有限范围内的整数排序。</p>
</li>
<li><p>桶排序（Bucket Sort）：将元素分布在不同的桶中，然后对每个桶中的元素进行排序，最后按顺序将各个桶中的元素合并起来。</p>
</li>
<li><p>基数排序（Radix Sort）：按照元素的位数依次对元素进行排序。先按最低有效位排序，然后按次低有效位排序，以此类推，直到最高有效位。</p>
</li>
</ol>
<h3 id="搜索算法（Searching-Algorithms）"><a href="#搜索算法（Searching-Algorithms）" class="headerlink" title="搜索算法（Searching Algorithms）"></a>搜索算法（Searching Algorithms）</h3><ol>
<li><p>线性搜索（Linear Search）：从数据集的开头开始，逐个比较元素，直到找到目标元素或遍历完整个数据集。</p>
</li>
<li><p>二分搜索（Binary Search）：仅适用于已排序的数据集。将数据集分成两部分，并根据目标值与中间值的大小关系，确定目标值在哪一部分，然后再在该部分进行继续二分搜索。</p>
</li>
<li><p>广度优先搜索（BFS，Breadth-First Search）：从一个起始节点开始，逐层扩展搜索，先访问离起始节点最近的节点，再访问其邻居节点，以此类推。常用于寻找最短路径等问题。</p>
</li>
<li><p>深度优先搜索（DFS，Depth-First Search）：从一个起始节点开始，沿着路径尽可能深入，直到无法继续为止，然后回溯并探索其他路径。通常使用递归或栈实现。</p>
</li>
<li><p>A<em>搜索（A</em> Search）：是一种启发式搜索算法，结合了广度优先搜索和贪心算法的思想。通过估计函数来评估每个节点的优先级，并选择具有最低优先级的节点进行扩展，以找到最优解。</p>
</li>
<li><p>Dijkstra算法（Dijkstra’s Algorithm）：用于在加权图中找到单源最短路径。从起始节点开始，逐步选择距离最小的节点，并更新到达其他节点的累积距离。</p>
</li>
<li><p>Bellman-Ford算法（Bellman-Ford’s Algorithm）：用于在有向图中找到单源最短路径，可以处理带有负权边的图。通过迭代松弛操作来逐步更新节点的最短路径估计。</p>
</li>
<li><p>深度受限搜索（Depth-Limited Search）：与深度优先搜索类似，但限制深度以避免无限循环。适用于深度过大导致嵌套层数过多的情况。</p>
</li>
<li><p>迭代加深搜索（Iterative Deepening Search）：结合了深度受限搜索和广度优先搜索的优点，在每次迭代中递增限制的深度，以逐渐扩展搜索范围。</p>
</li>
<li><p>双向搜索（Bidirectional Search）：同时从起始节点和目标节点开始搜索，逐步扩展搜索，直到两个搜索方向相交为止。常用于寻找两个节点之间的最短路径。</p>
</li>
</ol>
<h3 id="图算法（Graph-Algorithms）"><a href="#图算法（Graph-Algorithms）" class="headerlink" title="图算法（Graph Algorithms）"></a>图算法（Graph Algorithms）</h3><ol>
<li><p>深度优先搜索（DFS，Depth-First Search）：从一个起始节点开始，沿着路径尽可能深入，直到无法继续为止，然后回溯并探索其他路径。DFS可以用于遍历图中的所有节点或查找特定节点。</p>
</li>
<li><p>广度优先搜索（BFS，Breadth-First Search）：从一个起始节点开始，逐层扩展搜索，先访问离起始节点最近的节点，再访问其邻居节点，以此类推。BFS通常用于寻找最短路径等问题。</p>
</li>
<li><p>最小生成树算法（Minimum Spanning Tree）：例如Prim算法和Kruskal算法，用于找到连接图中所有节点的最小权重边的集合，形成一棵无环的树。</p>
</li>
<li><p>单源最短路径算法（Single Source Shortest Path）：例如Dijkstra算法和Bellman-Ford算法，用于在加权图中找到从一个节点到其他所有节点的最短路径。</p>
</li>
<li><p>全源最短路径算法（All Pairs Shortest Path）：例如Floyd-Warshall算法，用于找到图中任意两个节点之间的最短路径。</p>
</li>
<li><p>拓扑排序（Topological Sorting）：用于有向无环图(DAG)中将节点线性排序，使得每个节点在排序中都出现在它的后继节点之前。</p>
</li>
<li><p>强连通分量算法（Strongly Connected Components）：例如Tarjan算法和Kosaraju算法，用于将图中的节点划分为强连通分量，即在分量内任意两个节点都可以互相到达。</p>
</li>
<li><p>最大流算法（Maximum Flow）：例如Ford-Fulkerson算法和Edmonds-Karp算法，用于在有向图中找到从源节点到汇节点的最大可行流量。</p>
</li>
<li><p>最小割算法（Minimum Cut）：例如Karger算法，用于在无向图中找到将图分割成两个部分的最小边权重总和。</p>
</li>
<li><p>图染色算法（Graph Coloring）：例如贪心算法和回溯算法，用于给图中的节点分配颜色，使得相邻节点具有不同的颜色。</p>
</li>
</ol>
<h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><p>动态规划是一种常用的优化问题求解方法，常见的动态规划算法有以下几种：</p>
<ol>
<li><p>最长公共子序列（Longest Common Subsequence）：用于找到两个序列（字符串、数组等）中最长的公共子序列的长度。</p>
</li>
<li><p>背包问题（Knapsack Problem）：包括0&#x2F;1背包问题和无限背包问题，用于在给定容量限制下选择物品以达到最大价值或最小重量。</p>
</li>
<li><p>最长递增子序列（Longest Increasing Subsequence）：在一个序列中找到最长的递增子序列的长度。</p>
</li>
<li><p>切割钢条问题（Cutting Rod Problem）：给定一根长度为n的钢条和对应价格表，找到切割方案使得售出的价值最大化。</p>
</li>
<li><p>矩阵链乘法（Matrix Chain Multiplication）：给定一系列矩阵的大小，确定它们相乘的最佳顺序，使得计算乘法运算的总次数最少。</p>
</li>
<li><p>最长公共子串（Longest Common Substring）：在两个字符串中找到最长的公共连续子串的长度。</p>
</li>
<li><p>编辑距离（Edit Distance）：计算将一个字符串转换成另一个字符串所需的最少操作次数，允许插入、删除和替换操作。</p>
</li>
<li><p>最大子数组和（Maximum Subarray Sum）：在一个数组中找到连续子数组的和的最大值。</p>
</li>
<li><p>最优二叉搜索树（Optimal Binary Search Tree）：在给定的一组关键字和它们对应的概率下，构建一个具有最小搜索代价的二叉搜索树。</p>
</li>
<li><p>最长路径问题（Longest Path Problem）：在一个加权有向图中找到从起始节点到目标节点的最长路径。</p>
</li>
</ol>
<h3 id="贪心算法（Greedy-Algorithms）"><a href="#贪心算法（Greedy-Algorithms）" class="headerlink" title="贪心算法（Greedy Algorithms）"></a>贪心算法（Greedy Algorithms）</h3><p>一种每次选择局部最优解以期望获得全局最优解的算法。</p>
<ol>
<li><p>贪心选择性质（Greedy-choice Property）：在每个步骤中，选择最佳的局部解，以期望最终获得全局最优解。</p>
</li>
<li><p>活动选择问题（Activity Selection Problem）：给定一组活动，每个活动都有开始时间和结束时间，要求选择出最大数量的互不相交的活动。</p>
</li>
<li><p>哈夫曼编码（Huffman Coding）：通过构建最优二叉树，将出现频率高的字符用更短的编码表示，而出现频率低的字符用更长的编码表示。</p>
</li>
<li><p>最小生成树（Minimum Spanning Tree）：在一个加权连通图中，找到一棵包含所有顶点的树，并且边的权重之和最小。</p>
</li>
<li><p>最短路径问题（Shortest Path Problem）：在带权重的有向图或无向图中，找到从起点到目标点的路径，使得路径上各边的权重之和最小。</p>
</li>
<li><p>背包问题（Knapsack Problem）：给定一组物品以及它们的价值和重量，在限制总重量的情况下选择物品，使得总价值最大化。</p>
</li>
</ol>
<h3 id="回溯算法（Backtracking-Algorithms）"><a href="#回溯算法（Backtracking-Algorithms）" class="headerlink" title="回溯算法（Backtracking Algorithms）"></a>回溯算法（Backtracking Algorithms）</h3><p>回溯算法是一种通过穷举所有可能的解并逐步构建可行解的算法。常见的回溯算法有以下几种：</p>
<ol>
<li><p>八皇后问题（Eight Queens Problem）：在8×8的棋盘上放置8个皇后，使得它们互不攻击（即不在同一行、同一列或同一对角线上）。</p>
</li>
<li><p>正则表达式匹配（Regular Expression Matching）：判断一个字符串是否与给定的正则表达式匹配。</p>
</li>
<li><p>数独问题（Sudoku Problem）：填充一个9×9的数独盘面，使得每一行、每一列和每个小九宫格内的数字都是1到9且不重复。</p>
</li>
<li><p>字符串的全排列（Permutations of a String）：生成一个字符串的所有可能排列组合。</p>
</li>
<li><p>子集问题（Subset Problem）：找出一个集合的所有子集。</p>
</li>
<li><p>图的哈密顿回路（Hamiltonian Cycle in a Graph）：判断一个无向图是否存在一条哈密顿回路，即一条遍历所有节点且不重复的闭合路径。</p>
</li>
<li><p>图的着色问题（Graph Coloring Problem）：为一个图的每个节点分配颜色，使得相邻节点拥有不同的颜色。</p>
</li>
<li><p>寻找单词（Word Search）：在一个字符矩阵中查找是否存在给定的单词。</p>
</li>
<li><p>子集和问题（Subset Sum Problem）：判断一个给定集合中是否存在一个子集，使得子集中元素的和等于给定目标值。</p>
</li>
<li><p>旅行商问题（Traveling Salesman Problem）：找到一条路径，使得访问所有城市且回到起始城市的总路径最短。</p>
</li>
</ol>
<h3 id="分治算法（Divide-and-Conquer-Algorithms）"><a href="#分治算法（Divide-and-Conquer-Algorithms）" class="headerlink" title="分治算法（Divide and Conquer Algorithms）"></a>分治算法（Divide and Conquer Algorithms）</h3><p>一种将问题分解为更小的子问题，并将子问题的解合并以获得原始问题解的算法，如归并排序、快速排序等。</p>
<ol>
<li><p>快速排序（Quick Sort）：将待排序数组划分为两个子数组，然后分别对子数组进行递归地快速排序。</p>
</li>
<li><p>归并排序（Merge Sort）：将待排序数组分成两部分，分别对两部分进行归并排序，然后再将已排序的子数组合并成一个有序数组。</p>
</li>
<li><p>傅里叶变换（Fast Fourier Transform, FFT）：通过将信号分解成频域上的频率分量，应用分治思想来高效计算信号的傅里叶变换。</p>
</li>
<li><p>棋盘覆盖问题（Chessboard Coverage Problem）：将一个棋盘按特定规则分割为不同大小的若干块，然后使用分治策略解决覆盖问题。</p>
</li>
<li><p>最接近点对问题（Closest Pair of Points Problem）：在给定的点集中找到最近的一对点，利用分治算法的思想来高效解决。</p>
</li>
<li><p>Karatsuba乘法算法：用于高精度乘法的算法，通过将乘法运算分解为较小的子乘法来提高计算效率。</p>
</li>
</ol>
<h3 id="字符串匹配算法（String-Matching-Algorithms）"><a href="#字符串匹配算法（String-Matching-Algorithms）" class="headerlink" title="字符串匹配算法（String Matching Algorithms）"></a>字符串匹配算法（String Matching Algorithms）</h3><ol>
<li><p>暴力匹配算法（Brute Force）：也称为朴素匹配算法，从文本串中的每个位置开始与模式串逐个字符进行比较，直到找到匹配或遍历完整个文本串。</p>
</li>
<li><p>KMP算法（Knuth-Morris-Pratt Algorithm）：利用了模式串自身的信息，在匹配失败时通过跳过一些已经匹配过的字符来提高匹配效率。</p>
</li>
<li><p>Boyer-Moore算法（Boyer-Moore Algorithm）：根据模式串最右端的字符在该模式串中的出现情况来确定下一次匹配的起始位置，以此进行快速的匹配。</p>
</li>
<li><p>Rabin-Karp算法（Rabin-Karp Algorithm）：利用哈希函数对文本串和模式串进行哈希计算，通过比较哈希值来尽可能排除不匹配的情况。</p>
</li>
<li><p>Aho-Corasick算法（Aho-Corasick Algorithm）：用于多模式串的匹配，可以同时在一个文本串中查找多个模式串的出现位置。</p>
</li>
</ol>
<h3 id="最优化算法（Optimization-Algorithms）"><a href="#最优化算法（Optimization-Algorithms）" class="headerlink" title="最优化算法（Optimization Algorithms）"></a>最优化算法（Optimization Algorithms）</h3><ol>
<li><p>梯度下降法（Gradient Descent）：用于求解无约束优化问题的迭代优化算法，通过沿着负梯度方向更新参数来最小化目标函数。</p>
</li>
<li><p>共轭梯度法（Conjugate Gradient）：用于求解线性方程组或二次型最小化问题的迭代方法，通过共轭方向的选择和迭代来加速收敛。</p>
</li>
<li><p>牛顿法（Newton’s Method）：一种求解优化问题的迭代算法，通过使用目标函数的二阶导数（Hessian矩阵）和一阶导数（梯度）来逼近解。</p>
</li>
<li><p>雅可比法（Jacobian Method）：用于求解非线性方程组的迭代方法，通过构建雅可比矩阵来逼近解。</p>
</li>
<li><p>遗传算法（Genetic Algorithms）：模拟生物进化过程的优化算法，通过遗传操作（如交叉、变异）和自然选择来搜索最优解。</p>
</li>
<li><p>粒子群优化算法（Particle Swarm Optimization）：模拟鸟群觅食行为的优化算法，通过粒子的位置和速度更新来搜索最优解。</p>
</li>
<li><p>蚁群算法（Ant Colony Optimization）：模拟蚂蚁觅食行为的优化算法，通过蚂蚁在解空间中的移动路径和信息素更新来搜索最优解。</p>
</li>
<li><p>卡尔曼滤波算法（Kalman Filtering）：一种用于估计系统状态的优化算法，可以处理带有噪声和不确定性的动态系统。</p>
</li>
</ol>
<h3 id="哈希算法（Hashing-Algorithms）"><a href="#哈希算法（Hashing-Algorithms）" class="headerlink" title="哈希算法（Hashing Algorithms）"></a>哈希算法（Hashing Algorithms）</h3><ol>
<li><p>MD5（Message Digest Algorithm 5）：MD5是一种广泛使用的哈希算法，生成128位（16字节）的哈希值。尽管MD5在数据完整性校验上表现良好，但由于其容易被碰撞攻击，已经不再被推荐用于安全性要求较高的场景。</p>
</li>
<li><p>SHA-1（Secure Hash Algorithm 1）：SHA-1是一种160位（20字节）的哈希算法，用于生成哈希值。然而，由于SHA-1存在碰撞漏洞，已经不再被推荐作为加密哈希函数。</p>
</li>
<li><p>SHA-256（Secure Hash Algorithm 256-bit）：SHA-256是SHA-2系列中的一种算法，生成256位（32字节）的哈希值。SHA-256在许多领域中得到广泛应用，如密码学、数字证书等。</p>
</li>
<li><p>CRC32（Cyclic Redundancy Check 32）：CRC32是一种循环冗余校验算法，生成32位（4字节）的哈希值。它主要用于错误检测和数据完整性验证，例如在网络通信中常用于校验数据传输的准确性。</p>
</li>
<li><p>MurmurHash：MurmurHash是一种快速非加密型哈希算法，适用于一般的哈希表和哈希集合实现。MurmurHash具有较低的冲突率和计算速度，被广泛应用于分布式系统中的哈希算法。</p>
</li>
<li><p>CityHash：CityHash是一种高效的哈希算法，适用于存储在内存或磁盘中的数据。它在处理大型数据集时表现出色，并且对于随机输入有较低的冲突率。</p>
</li>
<li><p>xxHash（Extremely Fast Hash）：xxHash是一种快速且可靠的哈希算法，具有极高的速度和低的冲突率。它适用于需要高性能哈希算法的场景，如校验和计算、数据完整性检查等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/yangtong.github.io/2023/07/10/database/database/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/yangtong.github.io/2023/07/10/design/design/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/yangtong.github.io/2023/07/10/net/network/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/yangtong.github.io/2023/07/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
