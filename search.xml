<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Think Different</title>
    <url>/yangtong.github.io/2023/07/11/thinkdifferent/</url>
    <content><![CDATA[<p><img src="/yangtong.github.io/images/greatpeople.jpg"></p>
<blockquote>
<p>“Here’s to the crazy ones. The misfits. The rebels. The troublemakers. The round pegs in the square holes. The ones who see things differently. They’re not fond of rules. And they have no respect for the status quo. You can quote them, disagree with them, glorify or vilify them. About the only thing you can’t do is ignore them. Because they change things. They push the human race forward. And while some may see them as the crazy ones, we see genius. Because the people who are crazy enough to think they can change the world are the ones who do.”</br><center>— Apple’s “Think Different” commercial, 1997</center></p>
</blockquote>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>butterfly</title>
    <url>/yangtong.github.io/2023/08/11/butterfly/</url>
    <content><![CDATA[<pre class="line-numbers language-none"><code class="language-none">go ki gen na cyou ni na tte  
果 Ki 根  那 jio  你 那  德
ゴキゲンな蝶（ちょう）になって 
好想化做一只蝴蝶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki ra me ku ka ze ni no tte
Ki 拉 me 酷 卡 则 你 诺 德
きらめく風（かぜ）に乗（の）って
乘著微风振翅高飞<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">i ma su gu 
一麻苏谷 
今（いま）すぐ 
现在马上 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki mi ni, a i ni, yu ko u
Ki 米 你 阿以你 U  扩 哦
キミに会（あ）いに行（い）こう
只想赶快和你见面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">yo kei na ko to nan te
哟 克  那 扩 多 那嗯德
余計（よけい）な事（こと）なんて 
烦心的事放在一边 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">wa su re, ta ho ga, ma shi sa
瓦 苏 勒 他 或 嘎 嘛 西 撒
忘（わす）れた方（ほう）がマシさ
如果忘记那也无所谓<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ko re i jyou 
扩 勒 以 jio
これ以上（いじょう）
已经没有 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sya re te, ru ji kan, wa nai
夏 勒 德  路 几 康 瓦  那以
シャレてる時間（じかん）はない
多余时间可以浪费<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">na ni ga, wow wow 
纳 尼 嘎 wow wow~
何（なに）がwow wow 
似乎有 wow wow~ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ko no so ra ni, to do ku no da ro u
扩 诺 索 拉 你 托 多 哭 诺 大 洛 哦
この空（そら）に届（とど）くのだろう

什廖事会在这片晴空下出现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">
da ke do, wow wow 
打 ke 躲 wow wow~
だけどwow wow 
就算是 wow wow~ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">a shi ta no, yo tei mo, wa ka ra na i
阿西  大 诺 哟 德  莫 瓦 卡 拉 那 以
明日（あした）の予定（よてい）もわからない
面对未知的明天勇敢去冒险<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">
mu gen dai na, yu me no a to no 
木 跟  带  那 U  me 诺 啊 躲 诺 
無限大（むげんだい）な夢（ゆめ）のあとの 
在无限延伸的梦想后面 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">na ni mo nai, yo no na ka jya
那 尼 莫 奈  哟 诺 那 卡 加 )
何（なに）もない世（よ）の中（なか）じゃ
穿越冷酷无情的世界<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sou sa i to shi i 
所哦撒 以躲 西  以 
そうさ愛（いと）しい 

不想要输给自己 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">o mo i mo ma, ke sou, ni na ru ke do
哦莫 一莫 麻 克 所哦你  那 路 克 躲
想（おも）いも負（ま）けそうになるけど
有你的美丽记忆会让我更努力<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Stay shi ga, chi nai mee ji, da ra ke no
stay 西  尬  七 奈  me  几 打 啦 克 诺 
Stayしがちなイメージだらけの
相信爱永远不会止息 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ta yo ri nai tsu ,ba sa de mo
塔 哟 里  奈  子 吧 撒 得 莫)
頼（たよ）りない翼（つばさ）でも
即使偶尔会遇上难道<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
ki tto to be ru sa On My Love
Ki 躲 托  呗 路 撒 on my love
きっと飛（と）べるさ On my love
一定能化险为夷 on my love<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">

u ka re ta cyou ni na tte 
五卡 勒 塔 jio  你 那 德 
ウカレタ蝶（ちょう）になって
仿佛蝴蝶展开双翼 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">i chi zu na ka ze ni no tte
一气  字 那 卡 则 你 诺 德
一途（いちず）な風（かぜ）に乗（の）って
一路迎着微风飞行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
do ko ma de mo 
躲 扩 麻 得 莫 
どこまでも 
直到我和你 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki mi ni, a i ni, yu ko u
キミに会（あ）いに行（い）こう
Ki 米 你 阿以尼 U扩哦
相见约定不再分离<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
a i ma i na ko to ba tte 
爱以买以 那 扩 托 把 德
曖昧（あいまい）な言葉（ことば）って
有时候暖昧的表达<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">i ga i ni be n ri da tte
以嘎以 你 呗  尼  打  德 )
意外（いがい）に便利（べんり）だって
 意外的有效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sa ke n de ru 
撒ke 恩 德 路 
叫（さけ）んでる
热门歌曲如此高唱 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">hi tto so n, gu ki ki na ga ra
嘿 托  送恩 古 ki ki 那 嘎 啦
ヒットソング聴（き）きながら
那道旋律萦绕耳畔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
na ni ga, wow wow
那你嘎wow wow~ 
何（なに）がwow wow
好像有 wow wow~ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ko no ma, chi ni, hi bi, ku no da ro u
扩 诺 麻 气  你 嘿 比 哭 诺 达 洛哦
この街（まち）に響（ひび）くのだろう
什么声音悄悄从这街角响起<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">da ke do, wow wow 
打 克 躲 wow wow~
だけどwow wow 
而现在 wow wow~ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki ta i shi te, te mo, shi ka ta na i
ki 太以  西 德 德 莫  西 卡 塔 那 一
期待（きたい）してても仕方（しかた）ない
不想再空等让憧憬变成泡影<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
mu ge n da i na yu me no a to no
木 跟   带   那 鱼 me 诺 啊托 诺 
無限大（むげんだい）な夢（ゆめ）のあとの
在无限延伸的梦想后面 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ya ru se na i yo no na ka jya
呀 路 瑟 奈 一哟 诺 那 卡 家 )
やるせない世（よ）の中（なか）じゃ
纵然世界再虚假多变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sou sa jyo shi ki 
搜哦撒 jio 洗 ki 
そうさ常識
那些常识<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ha zu, re mo, wa ru ku ha na i ka na
哈啊组勒 莫 哇啊路 哭 哈 奈   卡  那
（じょうしき）はずれも悪（わる）くはないかな
即使不用也不会太差
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Stay shi sou nai mee ji wo, so me ta 
stay 西  搜  奈  me  几 我 所 me 塔 
Stayしそうなイメージを染（そ）めた

哪怕最后还是一场虚空想像 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">gi ko chi, nai tsu, ba sa de mo
gi 扩 七  奈  字  吧 撒 得 莫
ぎこちない翼（つばさ）でも

也要张开脆弱的翅膀<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki tto to be ru sa On My Love
Ki 躲 托  呗 路 撒 on my love 
きっと飛（と）べるさ On my love
飞翔在那片天空 on my love<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">mu gen dai na yu me no a to no 
木跟    带 那 yu me 诺 啊多诺 
無限大（むげんだい）な夢（ゆめ）のあとの 

在无限延伸的梦想后面 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">na ni mo nai yo no na ka jya
纳 尼 莫 奈  哟 诺 那 卡  家
何（なに）もない世（よ）の中（なか）じゃ
穿越冷酷无情的世界<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sou sa i to shi i 
搜哦萨以 托  西 以
そうさ愛（いと）しい
不想要输给自己 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">o mo i, mo ma, ke sou, ni na ru ke do
哦莫 一莫 麻 克 搜哦你 那 路 克 多
想（おも）いも負（ま）けそうになるけど

有你的美丽记忆会让我更努力
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Stay shi ga chi nai mee ji, da ra ke no 
stay 西  尬  七 奈  me  几 大 啦 克 诺
Stayしがちなイメージだらけの

相信爱永远不会止息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ta yo ri nai tsu, ba sa de mo
塔 哟 里  奈  字 八 撒 德 莫)
頼（たよ）りない翼（つばさ）でも

即使偶尔会遇上难道<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki tto to be ru sa oh yeah
Ki 躲 托 呗  路 撒 oh yeah )
きっと飛（と）べるさ oh yeah
一定能化险为夷 oh yeah<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
mu ge n da i na yu me no a to no 
木  跟   带  那 yu me 诺 啊 多诺 
無限大（むげんだい）な夢（ゆめ）のあとの
在无限延伸的梦想后面 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ya ru se na i yo no na ka jya
呀 路 瑟 那 一哟 诺 那 卡 家 
やるせない世（よ）の中（なか）じゃ
纵然世界再虚假多变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">sou sa jyo shi ki 
搜哦撒 jio 西 ki
そうさ常識（じょうしき）
那些常识 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ha zu, re mo, wa ru ku ha na i ka na
哈啊组勒 莫 哇 路 哭 哈  奈以 卡 那
はずれも悪（わる）くはないかな
即使不用也不会太差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">
Stay shi sou nai mee ji, wo so me ta 
stay 西 搜   奈  me  及 我 所 me 塔 
Stayしそうなイメージを染（そ）めた

哪怕最后还是一场虚空想像 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">gi ko chi nai tsu, ba sa de mo
gi 扩 气  奈  字 吧 撒  德 莫
ぎこちない翼（つばさ）でも

也要张开脆弱的翅膀<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ki tto to be ru sa On My Love
Ki 躲  托 呗 路 撒 on my love )
きっと飛（と）べるさ On my love
飞翔在那片天空 on my love<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>lemon</title>
    <url>/yangtong.github.io/2023/08/10/lemon/</url>
    <content><![CDATA[<p>yu me na ra ba, do re ho do, yo ka tta de syo u<br>(you me拿啦把, 多勒或剁,    哟 嘎  打  德  修 哦)<br>夢(ゆめ)ならばどれほどよかったでしょう<br>[如果这一切都是梦境该有多好]</p>
<span id="more"></span>

<p>i ma da ni, a na ta ,no ko to wo ,yu me ni mi ru<br>(姨妈打你, 啊那打, 诺扩多哦, you me你咪路 )<br>未(いま)だにあなたのことを夢(ゆめ)にみる<br>[至今仍能与你在梦中相遇]</p>
<p>wa su re ta mo ,no wo to ri ,ni ka e ru yo u ni<br>(挖苏勒打模, 诺哦托里, 你卡额录you你)<br>忘(わす)れた物(もの)を取(と)りに帰(かえ)るように<br>[如同取回遗忘之物一般]</p>
<p>fu ru bi ta o mo i de no ho ko ri wo ha ra u<br>(福录比 打哦摸 一德诺霍扩咦哦 哈拉无)<br>古(ふる)びた思(おも)い出(で)の埃(ほこり)を払(はら)う<br>[细细拂去将回忆覆盖的尘埃]</p>
<p>mo do ra na i shi a wa se ga a ru ko to wo<br>(摸多拉拿咦 西啊哇涩 嘎阿路扩多哦)<br>戻(もど)らない幸(しあわ)せがあることを<br>[最终是你让我懂得了]</p>
<p>sa i go ni a na ta ga o shi e te ku re ta<br>(赛咦果 你阿拿打 尬哦西诶 德哭勒踏)<br>最後(さいご)にあなたが教(おし)えてくれた</p>
<p>[这世间亦有无法挽回的幸福]</p>
<p>i e zu ni ka ku shi te ta ku ra i ka ko mo<br>(咦诶组你卡哭 西德塔哭 啦咦卡扩摸)<br>言(い)えずに隠(かく)してた昏(くら)い過去(かこ)も<br>[那些未对他人提及过的黑暗往事]</p>
<p>a na ta ga i na kya e i e nn ni ku ra i ma ma<br>(阿拿打 尬一那kia诶 嗯你 哭啦以妈妈 )<br>あなたがいなきゃ永遠(えいえん)に昏(くら)いまま<br>[如果不曾有你的话 它们将永远沉睡在黑暗中]</p>
<p>ki tto mo u ko re i jyo u, ki zu tu ku ko to na do<br>(ki托摸 扩勒一咦舅 ki字组哭阔托拿多)<br>きっともうこれ以上(いじょう)傷(きず)つくことなど<br>[我知道这世上一定没有]</p>
<p>a ri ha shi na i to wa ka tte i ru<br>(阿里挖 西  哪 一咦托挖卡  德 一 路)<br>ありはしないとわかっている<br>[比这更令人难过的事情了]</p>
<p>a no hi no ka na, shi mi sa e<br>(啊诺hi 诺 卡 纳, 西  咪 撒 诶 )<br>あの日(ひ)の悲(かな)しみさえ<br>[那日的悲伤]</p>
<p>a no hi no ku ru, shi mi sa e<br>(啊诺hi 诺 库 鲁, 西  咪  撒 诶)<br>あの日(ひ)の苦(くる)しみさえ<br>[与那日的痛苦]</p>
<p>so no su be te wo<br>(索诺 苏 呗 德 哦)<br>そのすべてを<br>[连同深着]</p>
<p>a i shi te ta a na ta to, to mo ni<br>(阿姨洗 德 他 阿拿 他 托, 托 沫 你)<br>愛(あい)してたあなたとともに<br>[这一切的你]</p>
<p>mu ne ni no ko ri ha ra ne na i<br>(木ne 你 诺 扩 力 哈 娜 勒 拿 以)<br>胸(むね)に残(のこ)り離(はな)れない<br>[化作了深深烙印在我心中的]</p>
<p>ni ga i re mo nn no ni o i<br>(你 嘎一 le mo n 诺 你 哦一)<br>苦(にが)いレモンの匂(にお)い<br>[苦涩柠檬的香气]</p>
<p>a me ga fu ri ya mu ma de ha ka e re na i<br>(啊me尬 福 里 呀 目 马 德 娃 卡 埃 勒 拿以)<br>雨(あめ)が降(ふ)り止(や)むまでは帰(かえ)れない<br>[在雨过天晴前都无法归去]</p>
<p>i ma de mo a na ta ha wa ta shi no hi ka ri<br>(姨妈德 摸 阿 拿 他 娃 娃 他 西 诺 hi 卡 里)<br>今(いま)でもあなたはわたしの光(ひかり)<br>[时至今日 你仍是我的光芒]</p>
<p>第二段</p>
<p>ku ra ya mi de a na ta no se wo na zo tta<br>库 拉 呀 咪 德 阿 那 他 诺 瑟 哦 那 组哦 踏<br>暗闇(くらやみ)であなたの背(せ)をなぞった<br>[在黑暗中追寻着你的身影]</p>
<p>so no ri nn ka ku wo se i me i ni o  bo  e    te  i ru<br>(索诺里     卡 库 哦   瑟  me  你 哦 波 wu e 德 一 路)<br>その輪郭(りんかく)を鮮明(せんめい)に覚(おぼ)えている<br>[那轮廓至今仍鲜明地刻印于心]</p>
<p>u   ke to me ki re na i mo no to de a u ta bi<br>(五 ke 托 me ki 勒 那 一摸 诺 托 德 阿五他比)<br>受(う)け止(と)めきれないものと出会(であ)うたび<br>[每当遇到无法承受的苦痛时]</p>
<p>a fu re te ya ma na i  no ha na mi da da ke<br>(阿福热 德 呀 马 拿 一 诺 哇 娜 咪 达 达 ke)<br>溢(あふ)れてやまないのは涙(なみだ)だけ<br>[总是不禁泪如泉涌]</p>
<p>na ni wo shi te i ta no<br>(纳尼 哦 西 德 一 塔 诺)<br>何(なに)をしていたの<br>[你都经历过什么]</p>
<p>na ni wo mi te i ta no<br>(纳尼哦  米 德 一 他诺)<br>何(なに)を見(み)ていたの<br>[又目睹过什么呢]</p>
<p>wa ta shi no shi ra na i yo ko ga o de<br>(瓦塔  西 诺  西  拉娜 以 哟 扩 尬哦 德)<br>わたしの知(し)らない横顔(よこがお)で<br>[脸上浮现着我不曾见过的神情]</p>
<p>do ko ka de a na ta ga i ma<br>(多ko 卡 德 阿 娜 塔 嘎 姨 马)<br>どこかであなたが今(いま)<br>[如果你正在什么地方]</p>
<p>wa ta shi to o na ji yo u na<br>(哇塔  西 托 哦娜 寄 哟 五 那)<br>わたしと同(おな)じ様(よう)な<br>[与我一样]</p>
<p>na mi da ni ku re<br>(娜咪 打 你 库 热)<br>涙(なみだ)にくれ<br>[终日过着]</p>
<p>sa mi shi sa no na ka ni i ru na ra<br>(撒咪 西  撒 诺 拿 卡 你 一 路 娜 拉 )<br>淋(さび)しさの中(なか)にいるなら<br>[以泪洗面的寂寞生活的话]</p>
<p>wa ta shi no ko to na do do u ka<br>(哇塔 西  诺 阔 托 那 多 多 五 卡)<br>わたしのことなどどうか<br>[就请你将我的一切]</p>
<p>wa su re te ku da sa i<br>(哇苏 热 德 库 大 赛 )<br>忘(わす)れてください<br>[全部遗忘吧]</p>
<p>so nn na ko to wo ko ko ro ka ra ne ga u ho do ni<br>(送 恩 那阔 托 哦 扩 扩 罗 卡 拉 ne 嘎 五 或 多你)<br>そんなことを心(こころ)から願(ねが)うほどに<br>[这是我发自内心深处唯一的祈愿]</p>
<p>i ma de mo a na ta ha wa ta shi no hi ka ri<br>(姨妈德 摸 阿娜 塔 挖 哇 塔  西  诺 hi 卡 里)<br>今(いま)でもあなたはわたしの光(ひかり)<br>[时至今日 你仍是我的光芒]</p>
<p>ji bu nn ga o mo u yo ri<br>(几不 嗯 嘎 哦 谋  哟 里)<br>自分(じぶん)が思(おも)うより<br>[我深深地恋慕着你]</p>
<p>ko i wo shi te i ta a na ta ni<br>(扩以哦 喜  德 一 塔 阿 娜 塔你 )<br>恋(こい)をしていたあなたに<br>[甚至超出了我自己的想象 ]</p>
<p>a  re ka ra o mo u yo u ni<br>(阿勒 卡 拉 哦莫 五 哟  你)<br>あれから思(おも)うように<br>[自此每当想起你]</p>
<p>i ki ga de ki na i<br>(一ki嘎 德 ki 拿 一)<br>息(いき)ができない<br>[都如同窒息般痛苦]</p>
<p>a nn na ni so ba ni i ta no ni<br>(昂  那 你 索 把 你 以 塔 诺 你)<br>あんなに側(そば)にいたのに<br>[你曾亲密伴我身旁]</p>
<p>ma ru de u so mi ta i<br>(马鲁 德 无 所 米 台)<br>まるで嘘(うそ)みたい<br>[如今却如烟云般消散]</p>
<p>to te mo wa su re ra re na i<br>(托特 膜 哇 苏 勒 啦 勒 那 一)<br>とても忘(わす)れられない<br>[唯一能确定的是]</p>
<p>so re da ke ga ta shi ka<br>(所勒 达 ke 嘎 塔  西 卡)<br>それだけが確(たし)か<br>[我永远都不会将你遗忘]</p>
<p>a no hi no ka na shi mi sa e<br>(啊诺hi 诺 卡 纳 西  密 撒 诶)<br>あの日(ひ)の悲(かな)しみさえ<br>[那日的悲伤]</p>
<p>a no hi no ku ru shi mi sa e<br>(啊诺hi诺  库 鲁 西  米 撒 诶)<br>あの日(ひ)の苦(くる)しみさえ<br>[与那日的痛苦]</p>
<p>so no su be te wo<br>(索诺 苏 呗 德 哦)<br>そのすべてを<br>[连同深爱着]</p>
<p>a i shi te ta a na ta to to mo ni<br>(阿姨西 德 塔 阿拿 塔 托 托 沫 你)<br>愛(あい)してた あなたとともに<br>[这一切的你]</p>
<p>mu ne ni no ko ri ha ra ne na i<br>(木ne 你 诺 扩 力 哈 娜 ne 拿 以)<br>胸(むね)に残(のこ)り離(はな)れない<br>[化作了深深烙印在我心中的]</p>
<p>ni ga i re mo nn no ni o i<br>(你嘎 一 lemon   诺 你 哦一)<br>苦(にが)いレモンの匂(にお)い<br>[苦涩柠檬的香气]</p>
<p>a me ga fu ri ya mu ma de ha ka e re na i<br>(啊me嘎 福 里 呀 目 马 德 娃 卡 诶勒 拿 以)<br>雨(あめ)が降(ふ)り止(や)むまでは帰(かえ)れない<br>[化作了深深烙印在我心中的]</p>
<p>ki ri wa ke ta ka ji tsu no ka ta ho u no yo u ni<br>(ki里 哇 ke 塔 卡 寄 次  诺 卡 塔 或 五 诺 哟 五你 )<br>切(き)り分(わ)けた果実(かじつ)の片方(かたほう)の様(よう)に<br>[如同被切开的半个柠檬一般]</p>
<p>i ma de mo a na ta ha wa ta shi no hi ka ri<br>(姨妈德 摸 阿 拿 塔 娃 娃塔  洗 诺 hi 卡 里)<br>今(いま)でもあなたはわたしの光(ひかり)<br>[时至今日 你仍是我的光芒]</p>
]]></content>
      <categories>
        <category>音乐</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题</title>
    <url>/yangtong.github.io/2023/08/10/cplusplusinterview/</url>
    <content><![CDATA[<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-存储持续性、作用域和链接性"><a href="#1-存储持续性、作用域和链接性" class="headerlink" title="1.存储持续性、作用域和链接性"></a>1.存储持续性、作用域和链接性</h3><h4 id="1-存储持续性："><a href="#1-存储持续性：" class="headerlink" title="1.存储持续性："></a>1.存储持续性：</h4><ul>
<li>自动存储持续性：<ul>
<li>在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。</li>
<li>寿命：它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放</li>
</ul>
</li>
<li>静态存储持续性：（可以再细分成3种，见小标题4）<ul>
<li>寿命：这种变量的寿命都持续到程序结束。</li>
<li>在<strong>函数定义外定义的变量</strong>和<strong>使用关键字static定义的变量</strong>的存储持续性都是静态。</li>
<li>C++为静态存储持续性变量提供了3种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或者代码块中访问）。</li>
<li>如果没有显式地初始化静态变量，编译器将把它设置为0。默认情况下，静态数组和结构将每个元素或成员的所有位都设置为0。</li>
</ul>
</li>
<li>动态存储持续性：</li>
<li>线程存储持续性：<span id="more"></span></li>
</ul>
<h4 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h4><p>作用域描述了名称在文件（翻译单元）的多大范围内可见。</p>
<p>例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。</p>
<ul>
<li><strong>函数原型作用域：</strong>函数原型作用域中使用的名称只在包含参数列表的括号内可用</li>
<li><strong>局部作用域：</strong>作用域为局部的变量只能在定义它的代码块中可用。代码块是由花括号括起来的一系列语句</li>
<li><strong>类作用域：</strong>再类中声明的成员的作用域为整个类</li>
<li><strong>作用域为全局</strong>（也叫文件作用域）的变量在定义位置到文件结尾之间都可用</li>
<li>在<strong>命名空间</strong>中声明的变量的作用域为整个名称空间（全局作用域是名称空间作用域的特例）</li>
</ul>
<p>C++函数的作用域可以是整个类或者整个名称空间（包括全局）的，但不能是局部的（也就是不能在代码块内定义函数，否则将无法被其他函数调用）。</p>
<h4 id="3-链接性"><a href="#3-链接性" class="headerlink" title="3.链接性"></a>3.链接性</h4><p>链接性表述了名称如何在不同单元间共享。</p>
<ul>
<li>链接性为<strong>外部</strong>的名称可在文件间共享</li>
<li>链接性为<strong>内部</strong>的名称只能由一个文件中的函数共享。</li>
</ul>
<p>自动变量的名称没有链接性，因为它们不能共享。</p>
<h4 id="4-静态存储持续性（即全局变量、全局static变量、局部static变量。这3种变量的寿命都持续到程序结束）"><a href="#4-静态存储持续性（即全局变量、全局static变量、局部static变量。这3种变量的寿命都持续到程序结束）" class="headerlink" title="4.静态存储持续性（即全局变量、全局static变量、局部static变量。这3种变量的寿命都持续到程序结束）"></a>4.静态存储持续性（即全局变量、全局static变量、局部static变量。这3种变量的寿命都持续到程序结束）</h4><ul>
<li>要想创建链接性为外部（可在其他文件中访问）的静态持续变量，必须在代码块的外面声明它<ul>
<li>全局变量，无static修饰的</li>
</ul>
</li>
<li>要创建链接性为内部（只能在当前文件中访问）的静态持续变量，必须在代码块外面声明它，并使用static限定符。<ul>
<li>全局静态变量</li>
</ul>
</li>
<li>要创建没有链接性（只能在当前函数或者代码块中访问）的静态持续变量，必须在代码块内声明它，并使用static限定符<ul>
<li>局部静态变量</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">...
int global&#x3D;1000;&#x2F;&#x2F;全局变量，静态持续变量，外部链接性。可以在本文件，也可以在其他文件中使用。
static int one_file&#x3D;50;&#x2F;&#x2F;全局静态变量，静态持续变量，内部链接性。只可以在本文件使用，从声明位置到文件结尾
int main()&#123;
    ...
&#125;

void funct1(int n)
&#123;
    static int count&#x3D;0;&#x2F;&#x2F;局部静态变量，静态持续变量，无链接性。只能在funct1函数中使用，但它具备静态持续性。即生命周期持续到程序结束。
    int llama&#x3D;0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-extern的跨文件用法"><a href="#5-extern的跨文件用法" class="headerlink" title="5.extern的跨文件用法"></a>5.extern的跨文件用法</h4><p>extern:该变量&#x2F;函数是从别的文件来的，或者该变量&#x2F;函数可以被别的文件使用。</p>
<p><code>extern int yyd;//这是声明</code></p>
<p><code>extern int yyd=1;//这是定义</code></p>
<p>1.两个文件都加上extern声明，不过只能有一个定义。正确</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd &#x3D; 1;
void test2();
int main() &#123;
    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd;
void test2() &#123;
    cout &lt;&lt; yyd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.第一个文件里没有extern，第二个文件extern声明。正确</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
int yyd &#x3D; 1;
void test2();
int main() &#123;
    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd;
void test2() &#123;
    cout &lt;&lt; yyd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.各种错误实例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
int yyd;
&#x2F;&#x2F;b.cpp
int yyd;&#x2F;&#x2F;错误!


&#x2F;&#x2F;a.cpp
extern int yyd&#x3D;0;
&#x2F;&#x2F;b.cpp
int yyd;&#x2F;&#x2F;错误！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>总结：</strong></p>
<ul>
<li>只能有一个份定义。定义时加不加extern都行</li>
<li>定义<ul>
<li><code>extern int  yyd=1;</code></li>
<li>或者</li>
<li><code>int yyd=1;</code></li>
</ul>
</li>
<li>声明<ul>
<li><code>extern int yyd;</code></li>
</ul>
</li>
</ul>
<h4 id="6-使用C-的作用域解析运算符-来访问被隐藏的外部变量"><a href="#6-使用C-的作用域解析运算符-来访问被隐藏的外部变量" class="headerlink" title="6.使用C++的作用域解析运算符(::)来访问被隐藏的外部变量"></a>6.使用C++的作用域解析运算符(::)来访问被隐藏的外部变量</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
int yyd&#x3D;1;
void test2();
int main() &#123;

    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd;
void test2() &#123;
    int yyd &#x3D; 2;
    cout &lt;&lt; &quot;局部变量：&quot;&lt;&lt;yyd&lt;&lt;endl;&#x2F;&#x2F;局部变量
    cout &lt;&lt; &quot;全局变量:&quot; &lt;&lt; ::yyd &lt;&lt; endl;&#x2F;&#x2F;该运算符表示使用变量的全局版本
&#125;
&#x2F;&#x2F;输出
 &quot;局部变量：&quot; 2
 &quot;全局变量:&quot;  1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="7-全局静态变量有什么用？"><a href="#7-全局静态变量有什么用？" class="headerlink" title="7.全局静态变量有什么用？"></a>7.全局静态变量有什么用？</h4><ul>
<li><p>如果文件a定义了一个静态外部变量（全局静态变量），其名称与另一个文件b中声明的常规外部变量（普通全局变量）相同，则在该文件a中，全局静态变量将隐藏外部的全局变量.</p>
</li>
<li><p>可使用链接性为内部的静态变量（全局静态变量）<strong>在同一个文件</strong>中的多个函数之间共享数据。</p>
</li>
<li><p>如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。</p>
</li>
<li><p>其实总结就是用static将变量的链接性变为了内部的，使之只能在一个文件中使用。</p>
</li>
<li><p>用static也可以将函数的链接性变为了内部的，使之只能在一个文件中使用。要知道<strong>函数，默认都是自带extern的。使用static可以将函数只能在本文件使用</strong>。</p>
<ul>
<li><pre><code class="c++">//a.cpp
static int parivate(double x);
...
static int private(double x);
<pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;c++
- extern和static肯定是不能同时出现的。因为extern是为了说明这是个跨文件的变量。而static则是限定，这是个只支持在本文件使用的变量。二者是矛盾和对立的。

​&#96;&#96;&#96;c++
&#x2F;&#x2F;a.cpp
int yyd&#x3D;20;&#x2F;&#x2F;普通的全局变量
&#x2F;&#x2F;b.cpp
static int yyd&#x3D;10;&#x2F;&#x2F;你要是写int yyd&#x3D;10;会报错的
&#x2F;&#x2F;你要是写extern int yyd;&#x2F;&#x2F;那就是引入了a文件的变量
&#x2F;&#x2F;而写static int yyd&#x3D;10，则是不会报错，隐藏了a文件的普通全局变量yyd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
int yyd&#x3D;1;
void test2();
int main() &#123;

    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
static int yyd;
void test2() &#123;
    int yyd &#x3D; 2;
    cout &lt;&lt; &quot;局部变量：&quot;&lt;&lt;yyd&lt;&lt;endl;
    cout &lt;&lt; &quot;全局变量:&quot; &lt;&lt; ::yyd &lt;&lt; endl;
&#125;
&#x2F;&#x2F;输出
&quot;局部变量：&quot; 2
&quot;全局变量:&quot;  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
int tom&#x3D;3;
int dick&#x3D;30;
static int harry&#x3D;300;

&#x2F;&#x2F;b.cpp
extern int tom;
static int dick&#x3D;10;
int harry&#x3D;200;

&#x2F;&#x2F;两个文件使用了同一个tom变量，但使用了不同的dick和harry变量。两个tom变量的地址相同，而两个dick和harry变量的地址不同。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-默认const全局变量的链接性是内部的，如同自带static。如果你希望是外部的，需要定义里自己加上extern"><a href="#8-默认const全局变量的链接性是内部的，如同自带static。如果你希望是外部的，需要定义里自己加上extern" class="headerlink" title="8.默认const全局变量的链接性是内部的，如同自带static。如果你希望是外部的，需要定义里自己加上extern"></a>8.默认const全局变量的链接性是内部的，如同自带static。如果你希望是外部的，需要定义里自己加上extern</h4><p>一般的全局变量的链接性为外部的，但是const全局变量的链接性是内部的。也就是说，在C++看来，全局const定义，就如同自带static一样</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a&#x3D;1;&#x2F;&#x2F;全局变量，链接性是外部的
static int b&#x3D;2;&#x2F;&#x2F;全局静态变量，链接性是内部的
const int c&#x3D;3;&#x2F;&#x2F;全局const变量，链接性是内部的
extern const int d&#x3D;4;&#x2F;&#x2F;全局const变量，链接性是外部的
int mian()
&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-名称空间"><a href="#8-名称空间" class="headerlink" title="8.名称空间"></a>8.名称空间</h4><ul>
<li>using声明将名称std添加到局部声明区域中。</li>
<li>在main里用了using，test2里没有，所以test2里找不到cout</li>
<li>在函数外面使用using声明时，可以把名称std添加到全局名称空间中，那么整个文件都可用了</li>
</ul>
<p>错误</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
int yyd &#x3D; 1;
void test2();
int main() &#123;
    using namespace std;&#x2F;&#x2F;
    test2();
    return 0;
&#125;

void test2() &#123;
    int yyd &#x3D; 2;
    cout &lt;&lt; &quot;局部变量：&quot; &lt;&lt; yyd &lt;&lt; endl;&#x2F;&#x2F;出错，未定义的标识符cout,endl
    cout &lt;&lt; &quot;全局变量:&quot; &lt;&lt; ::yyd &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>正确</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
int yyd &#x3D; 1;
void test2();
 using namespace std;&#x2F;&#x2F;
int main() &#123;

    test2();
    return 0;
&#125;

void test2() &#123;
    int yyd &#x3D; 2;
    cout &lt;&lt; &quot;局部变量：&quot; &lt;&lt; yyd &lt;&lt; endl;&#x2F;&#x2F;出错，未定义的标识符cout,endl
    cout &lt;&lt; &quot;全局变量:&quot; &lt;&lt; ::yyd &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="9-C-在哪里查找函数"><a href="#9-C-在哪里查找函数" class="headerlink" title="9.C++在哪里查找函数"></a>9.C++在哪里查找函数</h4><p>如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；否则， 编译器（包括链接程序）将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库名称同名的名称，编译器将使用程序员定义的版本而不是库函数（然而C++保留了标准库函数的名称，即程序员不应该使用它们）。</p>
<h3 id="2-说一下static关键字的作用"><a href="#2-说一下static关键字的作用" class="headerlink" title="2.说一下static关键字的作用"></a>2.说一下static关键字的作用</h3><ul>
<li>对于全局变量或者一个普通函数，static是个紧箍咒，他们从本来可以跨文件使用，被限制在了只能在本文件使用。不过同时也提供了一点便利性，不必担心名称与其他文件中的作用域为整个文件的变量、函数发生冲突（或者说叫做文件隔离）</li>
<li>对于局部变量，static为其提供了长久的寿命，可以每次进入其作用域时取出旧值。</li>
<li>对于类内静态数据成员，它提供了所有该类型对象共用一个数据</li>
<li>对于类内静态函数成员，它不需要对象名，直接通过类名就可以调用类内静态函数成员</li>
</ul>
<h4 id="1-全局静态变量"><a href="#1-全局静态变量" class="headerlink" title="1.全局静态变量"></a>1.全局静态变量</h4><p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p>
<p><strong>内存中的位置</strong>：<strong>静态存储区</strong>，在整个程序运行期间一直存在。（即<strong>初始化数据段+未初始化数据段（BSS段）</strong>）</p>
<p><strong>初始化</strong>：未经初始化的全局静态变量会被自动初始化为0（自动对象（也就是非静态变量）的值是任意的，除非他被显式初始化）；</p>
<p><strong>作用域</strong>：全局静态变量（全局变量+static修饰）在声明他的文件之外是不可见的，准确地说是<strong>从定义之处开始，到本文件结尾。</strong></p>
<p><strong>附注：</strong></p>
<ul>
<li>全局变量和全局静态变量不一样。</li>
<li>全局变量和全局静态变量都具有全局作用域</li>
<li><strong>静态全局变量(全局变量被static修饰)与全局变量(全局变量未被static修饰)的区别</strong>在于如果程序包含多个文件的话，静态全局变量作用于定义它的文件里，<strong>不能作用到其它文件里，即被static关键字修饰过的全局变量只能在当前文件中访问。static的全局变量作用域只在本文件中，所以extern和static不能同时修饰一个变量</strong>。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li>
<li>而全局变量（没有被static修饰的），只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern关键字再次声明这个全局变量。</li>
<li>一般定义static全局变量时，都把它放在源文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染。<ul>
<li>因为如果你在头文件中定义static全局变量，你可能想当然的认为，两个包含该头文件的源文件中的该变量是共通的，然而实际上是独立的两个变量。这将造成一些不必要的误会。</li>
</ul>
</li>
</ul>
<h4 id="2-局部静态变量"><a href="#2-局部静态变量" class="headerlink" title="2.局部静态变量"></a>2.局部静态变量</h4><p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p>
<p><strong>内存中的位置</strong>：静态存储区（即<strong>初始化数据段+未初始化数据段（BSS段）</strong>）</p>
<p><strong>初始化</strong>：未经初始化的局部静态变量会被自动初始化为0（与之相对的自动对象的值是任意的，除非他被显式初始化）；</p>
<p><strong>作用域</strong>：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
<h4 id="3-静态函数"><a href="#3-静态函数" class="headerlink" title="3.静态函数"></a>3.静态函数</h4><p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但<strong>静态函数只是在声明他的文件当中可见，不能被其他文件所用</strong>。</p>
<p>函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>warning：不要在头文件中声明static的全局函数，不要在cpp内定义多个非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
<h4 id="4-类的静态成员"><a href="#4-类的静态成员" class="headerlink" title="4.类的静态成员"></a>4.类的静态成员</h4><ul>
<li>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</li>
<li><strong>类的静态数据成员必须在类外定义和初始化</strong>，用(::)来指明所属的类。</li>
</ul>
<h4 id="5-类的静态函数"><a href="#5-类的静态函数" class="headerlink" title="5.类的静态函数"></a>5.类的静态函数</h4><ul>
<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>
<li>静态成员函数主要用于处理该类的静态数据成员。<strong>在静态成员函数的实现中不能直接引用类中说明的非静态成员</strong>，可以引用类中说明的静态成员（这点非常重要）。</li>
<li>如果静态成员函数中要引用非静态成员时，可通过参数传递的方式得到对象名，然后再通过对象名来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>
<li>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</li>
</ul>
<h3 id="3-说一下C-和C的区别"><a href="#3-说一下C-和C的区别" class="headerlink" title="3.说一下C++和C的区别"></a>3.说一下C++和C的区别</h3><h4 id="1-按照Effective-C-的理解"><a href="#1-按照Effective-C-的理解" class="headerlink" title="1.按照Effective C++的理解"></a>1.按照Effective C++的理解</h4><p>C++是一个语言联邦，包括：C、面向对象的C++、模板C++、STL。</p>
<ul>
<li>C语言：<ul>
<li>区块（blocks）、语句、预处理器、内置数据类型、数组、指针等通通来自C。C里没有模板、没有异常、没有重载…</li>
</ul>
</li>
<li>Object-Oriented C++：<ul>
<li>这部分就是C with Classes所诉求的：类classes（包括构造函数和析构函数），封装，继承，多态，虚函数（动态绑定）等等。</li>
<li>这就是面向对象的思想在C++上的体现。</li>
</ul>
</li>
<li>Template C++：<ul>
<li>C++的泛型编程部分。</li>
<li>泛型编程，编程范型，模板元编程（TMP）（模板元编程可以在编译的过程中计算出结果：例如计算一个数的阶乘，运行      时当作常量使用）</li>
<li>通用编程意味着您不是在编写按原样编译的源代码，而是编写源代码的“模板”，这些模板在编译过程中会转换为源代码。</li>
<li>c不支持泛型。c++的范型只是让编译器自动生成代码，编译器自动生成和手写的只是人力成本上的差异，因为C语言不支持泛型，所以需要多费点体力，或者写个自动生成代码的工具。</li>
</ul>
</li>
<li>STL：<ul>
<li>STL是一个模板程序库。包含 容器，迭代器，算法，函数对象等</li>
</ul>
</li>
</ul>
<h4 id="2-设计思想上："><a href="#2-设计思想上：" class="headerlink" title="2.设计思想上："></a>2.设计思想上：</h4><p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p>
<h4 id="3-详细的："><a href="#3-详细的：" class="headerlink" title="3.详细的："></a>3.详细的：</h4><p>跟上边4个基本类似，多详细添加了3个：类型检查机制、异常处理、重载的机制</p>
<ul>
<li><strong>增强了类型检查机制</strong><ul>
<li>C&#x2F;C++ 是静态数据类型语言，类型检查发生在编译时，因此编译器知道程序中每一个变量对应的数据类型。C++ 的类型检查相对更严格一些。</li>
<li>传统上 C 使用 void* 指针指向不同对象，使用时强制转换回原始类型或兼容类型。这样做的缺陷是绕过了编译器的类型检查，如果错误转换了类型并使用，会造成程序崩溃等严重问题。</li>
<li>C++ 通过使用基类指针或引用来代替 void* 的使用，避免了这个问题（其实也是体现了类继承的多态性）。</li>
</ul>
</li>
<li>增加了面向对象的机制<ul>
<li>类classes（包括构造函数和析构函数），封装，继承，多态，虚函数（动态绑定）等等。</li>
</ul>
</li>
<li>增加了泛型编程的机制（template）<ul>
<li>所谓泛型编程，简而言之就是不同的类型采用相同的方式来操作。在 C++ 的使用过程中，直接 template 用的不多，但是用 template 写的库是不可能不用的。</li>
<li>意味着您不是在编写按原样编译的源代码，而是编写源代码的“模板”，这些模板在编译过程中会转换为源代码。</li>
</ul>
</li>
<li><strong>增加了异常处理</strong><ul>
<li><strong>C 语言</strong>不提供对错误处理的直接支持，但它以<strong>返回值的形式</strong>允许程序员访问底层数据。</li>
<li><strong>C++ 提供了一系列标准的异常</strong>，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。</li>
</ul>
</li>
<li><strong>增加了重载的机制</strong><ul>
<li>函数重载、运算符重载</li>
</ul>
</li>
<li>增加了标准模板库（STL）</li>
</ul>
<h4 id="4-具体版本"><a href="#4-具体版本" class="headerlink" title="4.具体版本"></a>4.具体版本</h4><ol>
<li>C是面向过程的语言，而C++是面向对象的语言</li>
<li>C和C++动态管理内存的方法不一样，C是使用malloc、free函数，而C++不仅有malloc&#x2F;free，还有new&#x2F;delete关键字</li>
<li>C++的类是C中没有的，C中的struct可以在C++中等同类来使用，struct和类的差别是，struct的成员默认访问修饰符是public，而类默认是private。</li>
<li>C++支持重载，而C不支持重载，C++支持重载在于C++名字的修饰符与C不同，例如在C++中函数 int f(int) 经过名字修饰之后变为<code>_f_int</code>,而C是<code>_f</code>，所以C++才会支持不同的参数调用不同的函数。</li>
<li>C++中有引用，而C没有</li>
<li>C++全局变量的默认连接属性是外链接，而C是内链接。</li>
<li>C中用const修饰的变量不可以用在定义数组时的大小，但是C++用const修饰的变量可以。</li>
<li>C++有很多特有的输入输出流。</li>
<li>C++具有封装、继承和多态三种特性</li>
<li>C++相比C，增加多许多类型安全的功能，比如强制类型转换、</li>
<li>C++支持范式编程，比如模板类、函数模板等</li>
</ol>
<h3 id="4-说一说c-中四种cast转换"><a href="#4-说一说c-中四种cast转换" class="headerlink" title="4.说一说c++中四种cast转换"></a>4.说一说c++中四种cast转换</h3><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<h4 id="1、const-cast，移除变量的常量性（将底层const指针变为非const指针）"><a href="#1、const-cast，移除变量的常量性（将底层const指针变为非const指针）" class="headerlink" title="1、const_cast，移除变量的常量性（将底层const指针变为非const指针）"></a>1、const_cast，移除变量的常量性（将底层const指针变为非const指针）</h4><ul>
<li>1.常量指针 被强转为 非常量指针，且仍然指向原来的对象；</li>
<li>2.常量引用 被强转为 非常量引用，且仍然指向原来的对象；</li>
<li>3.常量对象 被强转为 非常量对象。</li>
</ul>
<p>用于将const变量转为非const,移除变量的常量性</p>
<p>const_cast不是万能的，它可以修改指向一个值的指针，但修改const值的结果是不确定的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">high bar;
const High* pbar&#x3D;&amp;bar;
High* pb&#x3D;const_cast&lt;High*&gt; (pbar);&#x2F;&#x2F;正确
const Low* pl&#x3D;const_cat&lt;const Low*&gt; (pbar);&#x2F;&#x2F;不正确，只能够修改const，不能变成其他类型（从原来的const high*变成const low*）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2、static-cast，静态转型"><a href="#2、static-cast，静态转型" class="headerlink" title="2、static_cast，静态转型"></a>2、static_cast，静态转型</h4><p><strong>相当于传统的C语言里的强制转换</strong></p>
<ul>
<li>（1）主要用于内置数据类型之间的相互转换；<ul>
<li>double转int，float转long等各种数值转换</li>
</ul>
</li>
<li>（2）用于自定义类时，静态转换会判断转换类型之间的关系，如果转换类型之间没有任何关系，则编译器会报错，不可转换；<ul>
<li><strong>多态向上转化。</strong>从派生类指针转成基类指针（dynamic_cast也可以）</li>
<li><strong>多态向下转化。</strong>从基类指针转成派生类指针（dynamic_cast有时行，行的情况见3.（5）。用dynamic_cast将更安全）。</li>
</ul>
</li>
<li>（3）把void类型指针转为目标类型指针（不安全）。</li>
<li>（4）把任何类型的表达式转换成void类型</li>
<li>（5）还有各种隐式转换，比如非const转const等。(const转非const是const_cast)</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;static_cast.cpp
&#x2F;&#x2F;内置类型的转换
double dValue &#x3D; 12.12;
float fValue &#x3D; 3.14; &#x2F;&#x2F; VS2013 warning C4305: “初始化”从“double”到“float”截断
int nDValue &#x3D; static_cast&lt;int&gt;(dValue); &#x2F;&#x2F; 12
int nFValue &#x3D; static_cast&lt;int&gt;(fValue); &#x2F;&#x2F; 3
&#x2F;&#x2F;自定义类的转换
class A&#123;&#125;;
class B : public A&#123;&#125;;
class C&#123;&#125;;
void main()&#123;
    A *pA &#x3D; new A;
    B *pB &#x3D; static_cast&lt;B*&gt;(pA); &#x2F;&#x2F; 编译不会报错, B类继承于A类。这是从基类指针转换成派生类指针
    pB &#x3D; new B;
    pA &#x3D; static_cast&lt;A*&gt;(pB); &#x2F;&#x2F; 编译不会报错, B类继承于A类。这是从派生类指针转换成基类指针
    C *pC &#x3D; static_cast&lt;C*&gt;(pA); &#x2F;&#x2F; 编译报错, C类与A类没有任何关系。error C2440: “static_cast”: 无法从“A *”转换为“C *”
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3、dynamic-cast，向上转换-或者安全地向下转化（下行可能不安全，上行是百分百安全的）"><a href="#3、dynamic-cast，向上转换-或者安全地向下转化（下行可能不安全，上行是百分百安全的）" class="headerlink" title="3、dynamic_cast，向上转换 或者安全地向下转化（下行可能不安全，上行是百分百安全的）"></a>3、dynamic_cast，向上转换 或者安全地向下转化（下行可能不安全，上行是百分百安全的）</h4><ul>
<li><p>（1）<strong>dynamic_cast是运行时处理的，运行时要进行类型检查，而其他三种都是编译时完成的；</strong></p>
<ul>
<li>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</li>
<li>成功则指针有值。失败则是nullptrs</li>
</ul>
</li>
<li><p>（2）不能用于内置基本数据类型间的强制转换；(但是static_cast可以）</p>
</li>
<li><p>（3）使用dynamic_cast进行转换时，<strong>基类中一定要有虚函数，否则编译不通过；</strong></p>
</li>
<li><p>（4）dynamic_cast转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL；</p>
</li>
<li><p>（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，<strong>dynamic_cast具有类型检查的功能，比static_cast更安全</strong>。向下转换的成败取决于将要转换的类型，即要强制转换的指针所指向的对象实际类型与将要转换后的类型一定要相同，否则转换失败。</p>
<ul>
<li><p><strong>向下转换成功本质上是：本来使用了一个 “”基类指针”” c 指向派生类对象，然后将这个”指向 派生类对象 的基类指针”c 强制转换成 “派生类指针”d</strong></p>
</li>
<li><pre><code class="c++">//举例
class base &#123;
public:
    virtual void show() &#123;//必须有个虚函数，否则dynamic_cast那一行无法编译通过
        cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;
    &#125;
&#125;;
class  derived: public base &#123;
public:
    virtual void show() &#123;
        cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main() &#123;
    base* a = new base;
    derived* b = new derived;
    base* c = new derived;//要强制转换的指针所指向的对象实际类型与将要转换后的类型一定要相同。比如原来这个base指针就是指向derived对象的。
    c-&gt;show();
    derived* d = dynamic_cast&lt;derived*&gt; (c);//原来这个base指针就是指向derived对象的。那么我把它变成了derived指针指向原来的derived对象，完全合理
    if (d == nullptr)
        cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; endl;
    else
        d-&gt;show();
    return 0;
&#125;
//输出
derived
derived
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  &#x2F;&#x2F;举例
  class base &#123;
  public:
  	virtual void show() &#123;
  		cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;
  	&#125;
  &#125;;
  class  derived: public base &#123;
  public:
  	virtual void show() &#123;
  		cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl;
  	&#125;
  &#125;;
  
  int main() &#123;
  	base* a &#x3D; new base;
  	derived* b &#x3D; new derived;
  	base* c &#x3D; new derived;&#x2F;&#x2F;
  	c-&gt;show();
  	derived* d &#x3D; dynamic_cast&lt;derived*&gt; (a);&#x2F;&#x2F;base指针a本来指向的就是base对象，现在想用一个derived指针去指向base对象，完全不合理。所以转化失败，d是nullptr
  	if (d &#x3D;&#x3D; nullptr)
  		cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; endl;
  	else
  		d-&gt;show();
  	return 0;
  &#125;
  &#x2F;&#x2F;输出
  derived
  nullptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>dynamic_cast和static_cast的区别</strong></p>
</li>
<li><p>对于向上转化，dynamic_cast和static_cast都可以。对于向下转化二者的处理方式不同。</p>
<ul>
<li><p>向下成功时，二者无异。</p>
</li>
<li><p>dynamic_cast失败时，将变成nullptr，而static_cast可不会</p>
</li>
<li><pre><code class="c++">class base &#123;
public:
    virtual void show() &#123;
        cout &lt;&lt; &quot;base&quot; &lt;&lt; endl;
    &#125;
&#125;;
class  derived: public base &#123;
public:
    virtual void show() &#123;
        cout &lt;&lt; &quot;derived&quot; &lt;&lt; endl;
    &#125;
&#125;;

int main()&#123;
    base* a = new base;
    derived* b = new derived;
    base* c = new derived;//
    c-&gt;show();
    derived* d = dynamic_cast&lt;derived*&gt; (c);//这种成功情况与derived* d = static_cast&lt;derived*&gt; (c) 无异
    
    derived* e = dynamic_cast&lt;derived*&gt; (a);//e将是nullptr
    derived* f = static_cast&lt;derived*&gt; (a);//f将有值，将发生不可思议的，一个派生类指针指向了一个基类对象的情况。这是不安全的
    f-&gt;show();//将输出base
&#125;
<pre class="line-numbers language-none"><code class="language-none">
    

#### 4、**reinterpret_cast， 重新解释转型**:

- 几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
- new_type a &#x3D; reinterpret_cast &lt;new_type&gt; (value)
  - 将value的值转成new_type类型的值，a和value的值一模一样。比特位不变

更具体的：

- 从指针类型到一个足够大的整数类型
- 从整数类型或者枚举类型到指针类型
- 从一个指向函数的指针到另一个不同类型的指向函数的指针
- 从一个指向对象的指针到另一个不同类型的指向对象的指针
- 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针
- 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针

#### 5、为什么不使用C的强制转换？

C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

#### 6.总结

- const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
- static_cast：完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。
- dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常
- reinterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证

### 5.请你说一下你理解的c++中的smart pointer四个智能指针:shared_ptr,unique_ptr,weak_ptr,auto_ptr

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

#### 1.C++11智能指针介绍

**智能指针主要用于管理在堆上分配的内存**，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。**对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针**。并可以通过get函数获得普通指针。

#### 2.为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以**智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。**

#### 3.auto_ptr

（C++98的方案，C++11已经抛弃）采用所有权模式。

&#96;&#96;&#96;c++
auto_ptr&lt;string&gt; p1 (new string (&quot;I reigned lonely as a cloud.&quot;)); 
auto_ptr&lt;string&gt; p2; 
p2 &#x3D; p1; &#x2F;&#x2F;赋值auto_ptr不会报错，编译会通过
cout&lt;&lt;*p2&lt;&lt;endl;&#x2F;&#x2F;正常输出
cout&lt;&lt;*p1&lt;&lt;endl;&#x2F;&#x2F;程序崩溃<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>此时不会报错，<strong>p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</strong></p>
<h4 id="4-unique-ptr（替换auto-ptr，仅允许单个指针指向某个资源）"><a href="#4-unique-ptr（替换auto-ptr，仅允许单个指针指向某个资源）" class="headerlink" title="4.unique_ptr（替换auto_ptr，仅允许单个指针指向某个资源）"></a>4.unique_ptr（替换auto_ptr，仅允许单个指针指向某个资源）</h4><p>（替换auto_ptr）unique_ptr实现独占式拥有或严格拥有概念，<strong>保证同一时间内只有一个智能指针可以指向该对象</strong>。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>
<p>采用所有权模式，还是上面那个例子</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));   &#x2F;&#x2F;#4
unique_ptr&lt;string&gt; p4；                       &#x2F;&#x2F;#5
p4 &#x3D; p3;&#x2F;&#x2F;赋值unique_ptr此时会报错！！编译就通不过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>编译器认为p4&#x3D;p3非法，避免了p3不再指向有效数据的问题。<strong>尝试复制p3时会编译期出错</strong>，而auto_ptr能通过编译期从而在运行期埋下出错的隐患。因此，<strong>unique_ptr比auto_ptr更安全</strong>。</p>
<p>另外unique_ptr还有更聪明的地方：<strong>当程序试图将一个 unique_ptr 赋值给另一个时</strong>，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;)); 
unique_ptr&lt;string&gt; pu2; 
pu2 &#x3D; pu1;                                      &#x2F;&#x2F; #1 不允许。

unique_ptr&lt;string&gt; pu3; 
pu3 &#x3D; unique_ptr&lt;string&gt;(new string (&quot;You&quot;));   &#x2F;&#x2F; #2 允许

pu1&#x3D;unique_ptr&lt;string&gt;(new string (&quot;me&quot;));  &#x2F;&#x2F;成立。
&#x2F;&#x2F;赋值operator&#x3D;调用之前被unique_ptr对象拥有的任何对象都将被删除（就像调用了unique_ptr的析构函数一样）。
&#x2F;&#x2F;也就是说，hello world会先被安全地delete，赋值操作相当于先reset一下，然后赋值成新的&quot;me&quot;，不会造成资源泄露<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p>
<p><strong>注：如果确实想执行类似与#1的操作（也就是保存旧值，再重新赋值。如果只是想重新赋值，那直接重新赋值就行，参看上边的new string(“me”)，当然不能是用另一个unique来赋值这个unique,参看上边的pu2&#x3D;pu1，因为这样将有两个指针指向同一地方。）</strong>，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。尽管转移所有权后 还是有可能出现原有指针调用（调用就崩溃）的情况。但是这个语法能强调你是在转移所有权，让你清晰的知道自己在做什么，从而不乱调用原有指针。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;保存旧值，再重新赋值
&#x2F;&#x2F;如果只是想重新赋值，那直接重新赋值就行，参看上边的new string(&quot;me&quot;)，不会发生资源泄露
unique_ptr&lt;string&gt; ps1, ps2;
ps1 &#x3D; demo(&quot;hello&quot;);
ps2 &#x3D; move(ps1);&#x2F;&#x2F;ps1的旧值赋给了ps2，ps1里边就是nullptr了
ps1 &#x3D; demo(&quot;alexia&quot;);&#x2F;&#x2F;ps1重新赋值
cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>另外：reset与release的区别，只有unique_ptr才有这两个。shared_ptr仅有reset</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;)); 
pu1.reset();&#x2F;&#x2F;那么&quot;hello world&quot;资源将被释放，pu1指向空
string* temp&#x3D;pu1.release();&#x2F;&#x2F;剥离pu1与其内部指针的联系，并将内部指针返回回来，然后pu1指向空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h4 id="5-shared-ptr（共享指针，允许多个指针指向同一资源）"><a href="#5-shared-ptr（共享指针，允许多个指针指向同一资源）" class="headerlink" title="5.shared_ptr（共享指针，允许多个指针指向同一资源）"></a>5.shared_ptr（共享指针，允许多个指针指向同一资源）</h4><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了<strong>资源可以被多个指针共享</strong>，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。<strong>除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造</strong>。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>成员函数：</p>
<ul>
<li><p>use_count 返回引用计数的个数</p>
</li>
<li><p>unique 返回是否是独占所有权( use_count 为 1)</p>
</li>
<li><p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p>
</li>
<li><p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p>
</li>
<li><p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如</p>
<ul>
<li><pre><code class="c++">shared_ptr&lt;int&gt; sp(new int(1)); 
<pre class="line-numbers language-none"><code class="language-none">
- sp 与 sp.get()是等价的。

**重点问题：**

- 多个智能指针可以指向相同对象，仅限于复制构造智能指针和赋值！

- 因为每个只能指针构造时，会new一个counter

- &#96;&#96;&#96;c++
  int main()
  &#123;
  	string* s1 &#x3D; new string(&quot;s1&quot;);
  
  	shared_ptr&lt;string&gt; ps1(s1);
  	shared_ptr&lt;string&gt; ps2(ps1);&#x2F;&#x2F;复制构造，正确！
  	&#x2F;&#x2F;shared_ptr&lt;string&gt; ps2;&#x2F;&#x2F;或者赋值，正确！
  	&#x2F;&#x2F;ps2 &#x3D; ps1;
  	cout &lt;&lt; ps1.use_count() &lt;&lt; endl;	&#x2F;&#x2F;2
  	cout &lt;&lt; ps2.use_count() &lt;&lt; endl;	&#x2F;&#x2F;2
  	cout &lt;&lt; ps1.unique() &lt;&lt; endl;	&#x2F;&#x2F;0
  	cout &lt;&lt; ps2.unique() &lt;&lt; endl;	&#x2F;&#x2F;0
  	return 0;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><pre><code class="c++">//这样是各计数各的！并且会有大bug，s1被delete两次，引发异常
int main()
&#123;
    string* s1 = new string(&quot;s1&quot;);

    shared_ptr&lt;string&gt; ps1(s1);//构造，
    shared_ptr&lt;string&gt; ps2(s1);//构造，这样写是个大bug!

    cout &lt;&lt; ps1.use_count() &lt;&lt; endl;	//1
    cout &lt;&lt; ps2.use_count() &lt;&lt; endl;	//1
    cout &lt;&lt; ps1.unique() &lt;&lt; endl;	//1
    cout &lt;&lt; ps2.unique() &lt;&lt; endl;	//1
    return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  &#x2F;&#x2F;空指针的use_count是0，unique也是0
  int main()
  &#123;
  	string* s1 &#x3D; new string(&quot;s1&quot;);
  
  	shared_ptr&lt;string&gt; ps1(s1);
  	shared_ptr&lt;string&gt; ps2;&#x2F;&#x2F;空指针
  
  	cout &lt;&lt; ps1.use_count() &lt;&lt; endl;	&#x2F;&#x2F;1
  	cout &lt;&lt; ps2.use_count() &lt;&lt; endl;	&#x2F;&#x2F;0
  	cout &lt;&lt; ps1.unique() &lt;&lt; endl;	&#x2F;&#x2F;1
  	cout &lt;&lt; ps2.unique() &lt;&lt; endl;	&#x2F;&#x2F;0
  	return 0;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
<p><strong>share_ptr的简单例子：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
	string *s1 &#x3D; new string(&quot;s1&quot;);

	shared_ptr&lt;string&gt; ps1(s1);
	shared_ptr&lt;string&gt; ps2;
	ps2 &#x3D; ps1;

	cout &lt;&lt; ps1.use_count()&lt;&lt;endl;	&#x2F;&#x2F;2
	cout&lt;&lt;ps2.use_count()&lt;&lt;endl;	&#x2F;&#x2F;2
	cout &lt;&lt; ps1.unique()&lt;&lt;endl;	&#x2F;&#x2F;0

	string *s3 &#x3D; new string(&quot;s3&quot;);
	shared_ptr&lt;string&gt; ps3(s3);

	cout &lt;&lt; (ps1.get()) &lt;&lt; endl;	&#x2F;&#x2F;033AEB48
	cout &lt;&lt; ps3.get() &lt;&lt; endl;	&#x2F;&#x2F;033B2C50
	swap(ps1, ps3);	&#x2F;&#x2F;交换所拥有的对象
	cout &lt;&lt; (ps1.get())&lt;&lt;endl;	&#x2F;&#x2F;033B2C50
	cout &lt;&lt; ps3.get() &lt;&lt; endl;	&#x2F;&#x2F;033AEB48

	cout &lt;&lt; ps1.use_count()&lt;&lt;endl;	&#x2F;&#x2F;1
	cout &lt;&lt; ps2.use_count() &lt;&lt; endl;	&#x2F;&#x2F;2
	ps2 &#x3D; ps1;
	cout &lt;&lt; ps1.use_count()&lt;&lt;endl;	&#x2F;&#x2F;2
	cout &lt;&lt; ps2.use_count() &lt;&lt; endl;	&#x2F;&#x2F;2
	ps1.reset();	&#x2F;&#x2F;放弃ps1的拥有权，引用计数的减少
	cout &lt;&lt; ps1.use_count()&lt;&lt;endl;	&#x2F;&#x2F;0
	cout &lt;&lt; ps2.use_count()&lt;&lt;endl;	&#x2F;&#x2F;1
    cout &lt;&lt; ps3.use_count() &lt;&lt; endl;&#x2F;&#x2F;1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>shared_ptr造成资源泄露的情况:</strong></p>
<p>虽然a和b智能指针析构了，但是没有删除对应的两个对象</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;memory&gt;
#include &lt;iostream&gt;

class TA
&#123;
public:
	~TA()&#123;
		std::cout &lt;&lt; &quot;de TA&quot; &lt;&lt; std::endl;
	&#125;
	std::shared_ptr&lt;TB&gt; tb;
&#125;;

class TB
&#123;
public:
	~TB()&#123;
		std::cout &lt;&lt; &quot;de TB&quot; &lt;&lt; std::endl;
	&#125;
	std::shared_ptr&lt;TA&gt; ta;
&#125;;

int main()
&#123;
	&#123;
		TA* yydA&#x3D;new TA;
		TB* yydB&#x3D;new TB;
		shared_ptr&lt;TA&gt; a &#x3D; shared_ptr&lt;TA&gt;(yydA); &#x2F;&#x2F; step1
		shared_ptr&lt;TB&gt; b &#x3D; shared_ptr&lt;TB&gt;(yydB); &#x2F;&#x2F; step2

		a-&gt;tb &#x3D; b; &#x2F;&#x2F; step3,等同于a-&gt;tb&#x3D;shared_ptr&lt;TB&gt;(yydB);
		b-&gt;ta &#x3D; a; &#x2F;&#x2F; step4，等同于b-&gt;ta&#x3D;shared_ptr&lt;TA&gt;(yydA);
        &#x2F;&#x2F; step 5
        &#x2F;&#x2F;那么，在离开作用域后，pA和pB的引用计数都是1，彼此都在等待对方释放，两个指针的引用计数永远不可能下降为0,资源永远不会释放，造成资源的泄露
&#x2F;&#x2F;两个shared_ptr相互引用，死锁问题
	&#125; 
    &#x2F;&#x2F; step6
	return 0;
&#125;
&#x2F;&#x2F;在程序执行到 step1 的时候, 创建智能指针a，并赋值yydA，yydA指向的TA对象引用加1；
&#x2F;&#x2F;在程序执行到 step2 的时候，创建智能指针b，并赋值yydB，yydB指向的TB对象引用加1；
&#x2F;&#x2F;在程序执行到 step3 的时候，给a-&gt;tb赋值TB的对象，yydB指向的TB对象引用加1；
&#x2F;&#x2F;在程序执行到 step4 的时候，给b-&gt;ta赋值TA的对象，yydA指向的TA对象引用加1；
&#x2F;&#x2F;在程序执行到 step5 的时候，yydA指向的TA对象引用为2，yydB指向的TB对象引用为2；
&#x2F;&#x2F;在程序执行到 step6 的时候，b智能指针超出作用域开始析构，yydB指向的TB对象引用减1；a智能指针超出作用域开始析构，yydA指向的TA对象引用减1；
&#x2F;&#x2F;此时TA对象引用为1，TB的对象引用为1；
&#x2F;&#x2F;虽然a和b智能指针析构了，记录这个引用次数的内存（在堆上）还在，它还记着至今都各还有一次引用,所以a，b指针析构时，没有删除对应的两个对象，堆上的TA TB对象泄露了，因为再也没有指针指向它们。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-weak-ptr（配合shared-ptr使用，它不会计数-它不可以直接访问它管理的对象，转化成shared-ptr才行）"><a href="#6-weak-ptr（配合shared-ptr使用，它不会计数-它不可以直接访问它管理的对象，转化成shared-ptr才行）" class="headerlink" title="6.weak_ptr（配合shared_ptr使用，它不会计数; 它不可以直接访问它管理的对象，转化成shared_ptr才行）"></a>6.weak_ptr（配合shared_ptr使用，它不会计数; 它不可以直接访问它管理的对象，转化成shared_ptr才行）</h4><p>share_ptr虽然已经很好用了，<strong>但是有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</strong></p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作**, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少<strong>。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。**</p>
<p><strong>只要把上边两个类内的任意一个shared_ptr改为weak_ptr就可以避免这个死锁问题。因为weak_ptr将不引起计数的改变</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;memory&gt;
#include &lt;iostream&gt;
using namespace std;
class TB;

class TA
&#123;
public:
	~TA() &#123;
		std::cout &lt;&lt; &quot;de TA&quot; &lt;&lt; std::endl;
	&#125;
	std::weak_ptr&lt;TB&gt; tb;&#x2F;&#x2F;
&#125;;

class TB
&#123;
public:
	~TB() &#123;
		std::cout &lt;&lt; &quot;de TB&quot; &lt;&lt; std::endl;
	&#125;
	std::shared_ptr&lt;TA&gt; ta;
&#125;;

int main()
&#123;
	&#123;
		TA* yydA&#x3D;new TA;
		TB* yydB&#x3D;new TB;
		shared_ptr&lt;TA&gt; a &#x3D; shared_ptr&lt;TA&gt;(yydA); &#x2F;&#x2F; step1
		shared_ptr&lt;TB&gt; b &#x3D; shared_ptr&lt;TB&gt;(yydB); &#x2F;&#x2F; step2

		a-&gt;tb &#x3D; b; &#x2F;&#x2F; step3
		b-&gt;ta &#x3D; a; &#x2F;&#x2F; step4
		&#x2F;&#x2F; step 5
	&#x2F;&#x2F; step6
	return 0;
&#125;
&#x2F;&#x2F;在程序执行到 step1 的时候, 创建智能指针a，并赋值yydA，yydA指向的TA对象引用加1；
&#x2F;&#x2F;在程序执行到 step2 的时候，创建智能指针b，并赋值yydB，yydB指向的TB对象引用加1；
&#x2F;&#x2F;在程序执行到 step3 的时候，给a-&gt;tb赋值TB的对象，yydB指向的TB对象引用不增加；因为weak_ptr
&#x2F;&#x2F;在程序执行到 step4 的时候，给b-&gt;ta赋值TA的对象，yydA指向的TA对象引用加1；
&#x2F;&#x2F;在程序执行到 step5 的时候，yydA指向的TA对象引用为2，yydB指向的TB对象引用为1；
&#x2F;&#x2F;在程序执行到 step6 的时候，b智能指针超出作用域开始析构，yydB指向的TB对象引用减1；a智能指针超出作用域开始析构，yydA指向的TA对象引用减1；
&#x2F;&#x2F;此时TA对象引用为1，TB的对象引用为0；
&#x2F;&#x2F;a和b智能指针先析构，b指针析构时发现TB对象引用为0，TB对象被析构，TB对象里的ta指针也被析构，所以TA对象引用减为0，然后TA对象也析构了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：</strong></p>
<ul>
<li><p><strong>我们不能通过weak_ptr直接访问对象的方法</strong></p>
</li>
<li><p>也就是这个指针不能访问它存的对象，得通过lock转化成shared_ptr才能访问</p>
</li>
<li><p>比如</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">weak_ptr&lt;TA&gt; a&#x3D;shared_ptr&lt;TA&gt;(new TA);
a-&gt;tb;&#x2F;&#x2F;错误，就禁止-&gt;这个用法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><p>weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象. 注意, weak_ptr 在使用前需要检查合法性.</p>
</li>
<li><pre><code class="c++">weak_ptr&lt;TA&gt; a = shared_ptr&lt;TA&gt;(new TA);
shared_ptr&lt;TA&gt; temp = a.lock();//通过lock转化成shared_ptr才能访问
temp-&gt;tb;
<pre class="line-numbers language-none"><code class="language-none">
- expired 用于检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false.

- lock 用于获取所管理的对象的强引用(shared_ptr). 如果 expired 为 true, 也就是对象已经释放，那么返回一个空的 shared_ptr; 否则返回一个 shared_ptr, 其内部对象指向与 weak_ptr 相同.
- use_count 返回与 shared_ptr 共享的对象的引用计数.
- reset 将 weak_ptr 置空.
- weak_ptr 支持拷贝或赋值, 但不会影响对应的 shared_ptr 内部对象的计数.

### 6.智能指针有没有内存泄露的情况，如何解决

参看6.里的shared_ptr部分，解决方法是，两个类内的任意一个shared_ptr改为weak_ptr就可以避免这个死锁问题。因为weak_ptr将不引起计数的改变。

### 7.请你来说一说重载和重写覆盖

#### 1.重载（overload）（同名，入参一定要不一样，返回值随意）

重载：在同一作用域中，同名函数的形式参数（参数个数、类型或者顺序）不同时，构成函数重载，返回值类型没有要求。

&#96;&#96;&#96;c++
class A
&#123;
public:
	int 	func(int a);
	void 	func(int a, int b);
	void 	func(int a, int b, int c);    	
	int 	func(char* pstr, int a);&#x2F;&#x2F;四个函数均构成重载。
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li><strong>函数返回值类型与构成重载无任何关系</strong></li>
<li><strong>类的静态成员函数与普通成员函数可以形成重载</strong></li>
<li><strong>函数重载发生在同一作用域，如类成员函数之间的重载、全局函数之间的重载</strong></li>
</ol>
<p>对于重载，最出名的应该就是<strong>运算符重载</strong>了吧。</p>
<h4 id="2-隐藏（hiding）-同名就可以覆盖，无论入参和返回值"><a href="#2-隐藏（hiding）-同名就可以覆盖，无论入参和返回值" class="headerlink" title="2.隐藏（hiding）(同名就可以覆盖，无论入参和返回值)"></a>2.隐藏（hiding）(同名就可以覆盖，无论入参和返回值)</h4><p>隐藏定义：<strong>指不同作用域中定义的同名函数构成隐藏（不要求函数返回值和函数参数类型相同，只要同名就行）</strong>。比如派生类成员函数隐藏与其同名的基类成员函数、类成员函数隐藏全局外部函数。</p>
<p>重写继承而来的非虚函数，就构成了隐藏。但是也可以通过HideA::hidefunc();把隐藏的函数给调出来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void hidefunc(char* pstr)
&#123;
	cout &lt;&lt; &quot;global function: &quot; &lt;&lt; pstr &lt;&lt; endl;
&#125;

class HideA
&#123;
public:
	void hidefunc()
	&#123;
		cout &lt;&lt; &quot;HideA function&quot; &lt;&lt; endl;
	&#125;

	void usehidefunc()
	&#123;
		&#x2F;&#x2F;隐藏外部函数hidefunc，使用外部函数时要加作用域
		hidefunc();
		::hidefunc(&quot;lvlv&quot;);
	&#125;
&#125;;

class HideB : public HideA
&#123;
public:
	void hidefunc()
	&#123;
		cout &lt;&lt; &quot;HideB function&quot; &lt;&lt; endl;
	&#125;

	void usehidefunc()
	&#123;
		&#x2F;&#x2F;隐藏基类函数hidefunc，使用外部函数时要加作用域
		hidefunc();
		HideA::hidefunc();
	&#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-重写-x2F-覆盖（override）（一般是同名，入参，返回值都要相同-除了协变返回类型，就是说返回类型可以改变，首先得是返回指针，且指针指向需要是之前返回的指针指向类型的子类型）"><a href="#3-重写-x2F-覆盖（override）（一般是同名，入参，返回值都要相同-除了协变返回类型，就是说返回类型可以改变，首先得是返回指针，且指针指向需要是之前返回的指针指向类型的子类型）" class="headerlink" title="3.重写&#x2F;覆盖（override）（一般是同名，入参，返回值都要相同;除了协变返回类型，就是说返回类型可以改变，首先得是返回指针，且指针指向需要是之前返回的指针指向类型的子类型）"></a>3.重写&#x2F;覆盖（override）（一般是同名，入参，返回值都要相同;除了协变返回类型，就是说返回类型可以改变，首先得是返回指针，且指针指向需要是之前返回的指针指向类型的子类型）</h4><ul>
<li>重写的定义：<strong>派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写</strong>。</li>
<li><strong>重写（覆盖）要求具有相同的参数和返回值</strong>。而这个规则对于协变则会放松。需要注意的是，这里有一个特殊情况，即<strong>协变返回类型</strong>。</li>
<li>定义是：<strong>如果虚函数返回指针或者引用时（不包括value语义），子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型</strong>。这样的类型称为协变返回类型（Covariant returns type)。看示例代码：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;B是A的子类型才行
class Base
&#123;
public:
    virtual A&amp; show()
    &#123;
        cout&lt;&lt;&quot;In Base&quot;&lt;&lt;endl;
        return *(new A);
    &#125;
&#125;;

class Derived : public Base
&#123;
public:
     &#x2F;&#x2F;返回值协变，构成虚函数重写
     B&amp; show()
     &#123;
        cout&lt;&lt;&quot;In Derived&quot;&lt;&lt;endl;
        return *(new B);
    &#125;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对比覆盖和隐藏，不难发现<strong>函数覆盖其实是函数隐藏的特例</strong>。如果派生类中定义了一个与基类虚函数同名但是参数列表不同的非virtual函数，则此函数是一个普通成员函数，并形成对基类中同名虚函数的隐藏，而非虚函数覆盖。</p>
<p><strong>隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象，而覆盖则是为了实现动态联编，是一个动态概念</strong>。</p>
<h4 id="4-final和override说明符"><a href="#4-final和override说明符" class="headerlink" title="4.final和override说明符"></a>4.final和override说明符</h4><p>final 和 override 说明符出现在形参列表以及尾置返回类型之后。</p>
<p>final 还可以跟在类的后面，意思这个类不能当做其它类的基类。</p>
<h5 id="1-override写在子类里"><a href="#1-override写在子类里" class="headerlink" title="1.override写在子类里"></a>1.override写在子类里</h5><p>通过上面的介绍，<strong>我们知道派生类可以定义一个函数与基类中虚函数的名字相同但是形参列表不同的函数（隐藏，看清了这种情况是隐藏，没有覆盖，入参不一样）</strong>。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。</p>
<p>但是我们在写虚函数时，想让派生类中的虚函数覆盖掉基类虚函数，有时我们会不小心写错，造成了隐藏（派生类函数与基类中虚函数的名字相同但是形参列表不同），这不是我们想要看到的结果。所以<strong>C++ 11新标准中我们可以使用override关键字来说明派生类中的虚函数</strong>。</p>
<p><strong>如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class B
&#123;
	virtual void f1( int ) const;
	virtual void f2();
	void f3();
&#125;;
class C : B
&#123;
	void f1( int ) const override;	&#x2F;&#x2F;正确，f1与基类中的f1匹配
	void f2( int ) override;		&#x2F;&#x2F;错误：B没有形如f2（int）的函数。如果不加override，将不会报错，你以为可以实现多态了，其实是你写错了隐藏了！并没有多态性
	void f3() override;			&#x2F;&#x2F;错误：f3不是虚函数
	void f4() override;			&#x2F;&#x2F;错误：B中没有名为f4的函数
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用override是希望能覆盖基类中的虚函数，如果不符合则编译器报错。</p>
<h5 id="2-final写在上一级（父类）的类里"><a href="#2-final写在上一级（父类）的类里" class="headerlink" title="2.final写在上一级（父类）的类里"></a>2.final写在上一级（父类）的类里</h5><p>我们还能把某个函数指点为 <strong>final</strong> ，意味着任何尝试覆盖该函数的操作都将引发错误：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class D : B
&#123;
	&#x2F;&#x2F;从B继承 f2() 和 f3()，覆盖 f1( int )
	void f1( int ) const final; &#x2F;&#x2F;不允许后续的其它类覆盖 f1（int）
&#125;;
class E : D
&#123;
	void f2();				&#x2F;&#x2F;正确：覆盖从间接类B继承而来的f2
	void f1( int ) const;	&#x2F;&#x2F;错误：D已经将 f2 声明成 final
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>在讨论相关概念的区别时，抓住定义才能区别开来。C++中函数重载、隐藏和覆盖的区别并不难。</p>
<p>在这里，牢记以下几点，就可区分函数重载、函数隐藏、函数覆盖和函数重写的区别：</p>
<ol>
<li><strong>函数重载发生在相同作用域</strong></li>
<li><strong>函数隐藏发生在不同作用域</strong></li>
<li><strong>函数覆盖就是函数重写。准确地叫做虚函数覆盖和虚函数重写，也是函数隐藏的特例</strong></li>
</ol>
<p>关于三者的对比，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">三者</th>
<th align="left">作用域</th>
<th>有无virtual</th>
<th>函数名</th>
<th>形参列表</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">重载（函数重载，运算符重载）</td>
<td align="left">相同</td>
<td>可有可无</td>
<td>相同</td>
<td>不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td align="left">隐藏（变量隐藏，函数隐藏）</td>
<td align="left">不同</td>
<td>可有可无</td>
<td>相同</td>
<td>可同可不同</td>
<td>可同可不同</td>
</tr>
<tr>
<td align="left">覆盖重写（虚函数覆盖和虚函数重写）</td>
<td align="left">不同</td>
<td>有</td>
<td>相同</td>
<td>相同</td>
<td>相同（协变可以不同）</td>
</tr>
</tbody></table>
<h3 id="8-说一说strcpy和strlen"><a href="#8-说一说strcpy和strlen" class="headerlink" title="8.说一说strcpy和strlen"></a>8.说一说strcpy和strlen</h3><h4 id="1-strcpy"><a href="#1-strcpy" class="headerlink" title="1.strcpy"></a>1.strcpy</h4><ul>
<li>strcpy<ul>
<li>strcpy是字符串拷贝函数，原型：<code>char *strcpy(char* dest, const char *src);</code></li>
<li>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</li>
</ul>
</li>
<li>安全版本strncpy<ul>
<li>安全版本<strong>char *strncpy(char *dest, const char *src, size_t n)</strong> </li>
<li>把 <strong>src</strong> 所指向的字符串复制到 <strong>dest</strong>，最多复制 <strong>n</strong> 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。</li>
</ul>
</li>
</ul>
<h4 id="2-strlen"><a href="#2-strlen" class="headerlink" title="2.strlen"></a>2.strlen</h4><ul>
<li><p>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p>
</li>
<li><p>strlen(“hello”)返回的结果是5，是<strong>不包含字符串结尾处的‘\0’</strong>，但是strcpy(str1,str2)，<strong>会拷贝str2中的‘\0’</strong>。</p>
</li>
<li><p>建议在使用strcpy的时候，目标数组（第一个参数）的大小应该设置为strlen（）函数返回值+1 的值，或者建议使用如下的初始化数组方式：</p>
<ul>
<li><pre><code class="c++"> char char_array[sizeof(&quot;hello&quot;)];//sizeof(&quot;hello&quot;)=6
 char * char_array_two = new char[strlen(str) + 1];//strlen(str)=5
<pre class="line-numbers language-none"><code class="language-none">
### 9.回答一下++i和i++的区别

- ++i先自增1，再返回

  - &#96;&#96;&#96;c++
    int&amp;  int::operator++（）
    &#123;
    *this +&#x3D;1；
    return *this；
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>i++先返回i,再自增1</p>
<ul>
<li><pre><code class="c++">const int  int::operator（int）
&#123;
int oldValue = *this；
++（*this）；
return oldValue；//返回旧值
&#125;
<pre class="line-numbers language-none"><code class="language-none">
### 10.请你来写个函数在main函数执行前先运行

#### 方案1：通过gcc关键字

在 gcc 中可以使用 __attribute__ 关键字指定如下（在编译器编译的时候就决定了）

&#96;&#96;&#96;c++
#include &lt;stdio.h&gt;

void startt() __attribute__((constructor));&#x2F;&#x2F;__attribute__((constructor)) void startt();也行
void endd() __attribute__((destructor));

void startt() &#123;
    printf(&quot;this is function %s\n&quot;, __func__);
    return;
&#125;

void endd() &#123;
    printf(&quot;this is function %s\n&quot;, __func__);
    return;
&#125;

int main() &#123;
    printf(&quot;this is function %s\n&quot;, __func__);
    return 0;
&#125;

&#x2F;&#x2F; 输出结果
&#x2F;&#x2F; this is function before
&#x2F;&#x2F; this is function main
&#x2F;&#x2F; this is function after<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="方案2：通过全局变量-lambda函数"><a href="#方案2：通过全局变量-lambda函数" class="headerlink" title="方案2：通过全局变量+lambda函数"></a>方案2：通过全局变量+lambda函数</h4><p><strong>全局static变量</strong>的初始化在程序初始阶段，先于main函数的执行，所以可以利用这一点。</p>
<p>注意x是全局静态变量，不是函数。最后一个()的意思就是执行</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static int x &#x3D; []() &#123;&#x2F;&#x2F;不加static，因为普通全局变量和static全局变量的区别就是外部链接性和内部链接性的区别，初始化和生命期是一样的
    cout &lt;&lt; &quot;before main&quot; &lt;&lt; endl;
    return 2;
&#125;();&#x2F;&#x2F;[]()&#123;&#125;是定义了一个lambda函数，然后再()就是执行了这个函数，x是其返回值2。
int main()
&#123;
    cout&lt;&lt;&quot;main&quot;&lt;&lt;endl;
    return0;
&#125;
&#x2F;&#x2F;输出
&#x2F;&#x2F;before main
&#x2F;&#x2F;main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>趁此演示一下lambda函数的用法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static int x &#x3D; []() &#123;
    cout &lt;&lt; &quot;before main&quot; &lt;&lt; endl;
    return 2;
&#125;();&#x2F;&#x2F;[]()&#123;&#125;是定义了一个lambda函数，然后再()就是执行了这个函数，x是其返回值2
int main()
&#123;
    cout&lt;&lt;&quot;main&quot;&lt;&lt;endl;
    cout&lt;&lt;x&lt;&lt;endl;&#x2F;&#x2F;2
    &#x2F;&#x2F;底下演示一下lambda函数用法
    
    auto func &#x3D; []() &#123;&#x2F;&#x2F;注意，它没有运行
     	cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;
        return;
    &#125;;
    func();&#x2F;&#x2F;hello
    
    []() &#123;
        cout &lt;&lt; &quot;yyd&quot; &lt;&lt; endl;
    &#125;();&#x2F;&#x2F;yyd
    return 0;
&#125;
&#x2F;&#x2F;输出
&#x2F;&#x2F;before main
&#x2F;&#x2F;main
&#x2F;&#x2F;2
&#x2F;&#x2F;hello
&#x2F;&#x2F;yyd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;注意：这里的func就是个函数。
auto func&#x3D;[]()&#123;
    return 1;
&#125;;&#x2F;&#x2F;对于没有运行的纯lambda函数，必须使用auto来承接，不管你返回什么类型，或者不返回
auto func2&#x3D;[]()&#123;
    return 1.2;
&#125;
int a&#x3D;func();
double b&#x3D;func2();


&#x2F;&#x2F;对于这种直接执行了的，它返回的就是个数值！
auto a&#x3D;[]()&#123;
    return 1;
&#125;();&#x2F;&#x2F;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="方案3：通过全局变量-类的构造函数"><a href="#方案3：通过全局变量-类的构造函数" class="headerlink" title="方案3：通过全局变量+类的构造函数"></a>方案3：通过全局变量+类的构造函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BeforeMain &#123;
public:
    BeforeMain() &#123;
        cout &lt;&lt; &quot;Before main&quot; &lt;&lt; endl;
    &#125;;
&#125;;
BeforeMain bM; &#x2F;&#x2F; 利用全局变量和构造函数的特性,通过全局变量的构造函数执行

int main()
&#123;
    cout &lt;&lt; &quot;main&quot; &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F;输出
&#x2F;&#x2F;before main
&#x2F;&#x2F;main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="11-有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello"><a href="#11-有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello" class="headerlink" title="11.有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello?"></a>11.有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello?</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i &lt; 20; i--) 
	cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>答案：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i &#x3D; 0; i + 20; i--)
cout &lt;&lt; &quot;hello&quot; &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="12-shared-ptr和weak-ptr的核心实现"><a href="#12-shared-ptr和weak-ptr的核心实现" class="headerlink" title="12.shared_ptr和weak_ptr的核心实现"></a>12.shared_ptr和weak_ptr的核心实现</h3><h4 id="1-方案一-一个counter，只有一个问题，无法实现weakPtr-expired-（这种写法比较简单）"><a href="#1-方案一-一个counter，只有一个问题，无法实现weakPtr-expired-（这种写法比较简单）" class="headerlink" title="1.方案一:一个counter，只有一个问题，无法实现weakPtr::expired()!（这种写法比较简单）"></a>1.方案一:一个counter，只有一个问题，无法实现weakPtr::expired()!（这种写法比较简单）</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt;
class WeakPtr;

template&lt;class T&gt;
class SharePtr
&#123;
friend class WeakPtr&lt;T&gt;;&#x2F;&#x2F;方便weak_ptr与share_ptr设置引用计数和赋值
public:
	SharePtr(T* p &#x3D; nullptr) :_ptr(p)&#x2F;&#x2F;构造函数
	&#123;
		cnt &#x3D; new int(0);
		if (p)
			*cnt &#x3D; 1;&#x2F;&#x2F;传入非空指针，将share_ptr计数从0置为1，
	&#125;

	~SharePtr()&#x2F;&#x2F;析构函数
	&#123;		
		reset();
	&#125;

	SharePtr(SharePtr&lt;T&gt; const&amp; s) :_ptr(s._ptr), cnt(s.cnt)&#x2F;&#x2F;复制构造
	&#123;
		(*cnt)++;
	&#125;

	SharePtr(WeakPtr&lt;T&gt; const&amp; w) &#x2F;&#x2F;为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用
	&#123;
		_ptr &#x3D; w._ptr;
		cnt &#x3D; w.cnt;
		(*cnt)++;
	&#125;

	SharePtr&lt;T&gt;&amp; operator&#x3D;(SharePtr&lt;T&gt;&amp; s)&#x2F;&#x2F;赋值
	&#123;
		if (this !&#x3D; &amp;s)&#x2F;&#x2F;处理自我赋值
		&#123;
			reset();
			_ptr &#x3D; s._ptr;
			cnt &#x3D; s.cnt;
			(*cnt)++;
		&#125;
		return *this;
	&#125;

	T&amp; operator*()
	&#123;
		return *_ptr;
	&#125;

	T* operator-&gt;() &#123;
		return _ptr;
	&#125;


	void reset()
	&#123;
        if (cnt !&#x3D; nullptr)
        &#123;
            (*cnt)--;
            if ((*cnt) &lt;&#x3D; 0)
            &#123;
                delete _ptr;
                delete cnt;
            &#125;
            _ptr &#x3D; nullptr;
            cnt &#x3D; nullptr;
        &#125;
	&#125;

private:
	T* _ptr;&#x2F;&#x2F;管理的对象的raw指针
	int* cnt;&#x2F;&#x2F;引用计数
&#125;;


template&lt;class T&gt;
class WeakPtr
&#123;
friend class SharePtr&lt;T&gt;;&#x2F;&#x2F;写friend class SharePtr不行，必须得有&lt;T&gt;
public:

	WeakPtr()
	&#123;
		_ptr &#x3D; nullptr;
		cnt &#x3D; nullptr;
	&#125;

	WeakPtr(SharePtr&lt;T&gt;&amp; s) :_ptr(s._ptr), cnt(s.cnt) &#123;&#125;;
	WeakPtr(WeakPtr&lt;T&gt;&amp; w) :_ptr(w._ptr), cnt(w.cnt) &#123;&#125;;
	~WeakPtr()
	&#123;
		reset();
	&#125;
	void reset()
	&#123;
		_ptr &#x3D; nullptr;
		cnt &#x3D; nullptr;
	&#125;

	WeakPtr&lt;T&gt;&amp; operator&#x3D;(WeakPtr&lt;T&gt;&amp; w)
	&#123;
		_ptr &#x3D; w._ptr;
		cnt &#x3D; w.cnt;
		return *this;
	&#125;

	WeakPtr&lt;T&gt;&amp; operator&#x3D;(SharePtr&lt;T&gt;&amp; s)
	&#123;
		cnt &#x3D; s.cnt;
		_ptr &#x3D; s._ptr;
		return *this;
	&#125;

	SharePtr&lt;T&gt; lock()
	&#123;
		return SharePtr&lt;T&gt;(*this);
	&#125;

	&#x2F;*bool expired()&#x2F;&#x2F;这个无法实现
	&#123;
		&#x2F;&#x2F;return _ptr &#x3D;&#x3D; nullptr;
	&#125;*&#x2F;

private:
	T* _ptr;
	int* cnt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-两个counter，一个记录share-ptr，一个记录weak-ptr（这个方案没深究，写起来比较复杂）"><a href="#2-两个counter，一个记录share-ptr，一个记录weak-ptr（这个方案没深究，写起来比较复杂）" class="headerlink" title="2.两个counter，一个记录share_ptr，一个记录weak_ptr（这个方案没深究，写起来比较复杂）"></a>2.两个counter，一个记录share_ptr，一个记录weak_ptr（这个方案没深究，写起来比较复杂）</h4><ul>
<li>可能纠结为什么counter的析构在shared_ptr中，其实因为weak_ptr总是依赖于shared_ptr构造的，所以weak_ptr总是比shared_ptr晚构造，也就比它先析构。所以shared_ptr中释放counter可以成立。但是你要是写成static weakptr()..这counter肯定没释放，资源泄露了。</li>
<li>这种写法可以实现weak_ptr::expired()</li>
<li>s是share_ptr的引用计数，w是weak_ptr的引用计数。s为0时，删除引用对象；当w为0时，删除Counter对象。</li>
</ul>
<h5 id="Counter简单实现"><a href="#Counter简单实现" class="headerlink" title="Counter简单实现"></a>Counter简单实现</h5><p>counter对象的目地就是用来申请一个块内存来存引用基数，s是share_ptr的引用计数，w是weak_ptr的引用计数，当w为0时，删除Counter对象。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Counter
&#123;
public:
    Counter() : s(0), w(0)&#123;&#125;;
    int s;	&#x2F;&#x2F;share_ptr的引用计数
    int w;	&#x2F;&#x2F;weak_ptr的引用计数
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="shared-ptr的简单实现"><a href="#shared-ptr的简单实现" class="headerlink" title="shared_ptr的简单实现"></a>shared_ptr的简单实现</h5><p>shared_ptr的给出的函数接口为：构造，拷贝构造，赋值，解引用，通过release来在引用计数为0的时候删除_ptr和cnt的内存。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt;
class WeakPtr; &#x2F;&#x2F;为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用

template &lt;class T&gt;
class SharePtr
&#123;
public:
    SharePtr(T* p &#x3D; 0) : _ptr(p)
    &#123;
        cnt &#x3D; new Counter();
        if (p)
            cnt-&gt;s &#x3D; 1;

    &#125;
    ~SharePtr()
    &#123;
        release();
    &#125;

    SharePtr(SharePtr&lt;T&gt; const&amp; s)
    &#123;

        _ptr &#x3D; s._ptr;
        (s.cnt)-&gt;s++;

        cnt &#x3D; s.cnt;
    &#125;
    SharePtr(WeakPtr&lt;T&gt; const&amp; w) &#x2F;&#x2F;为了用weak_ptr的lock()，来生成share_ptr用，需要拷贝构造用
    &#123;
        
        _ptr &#x3D; w._ptr;
        (w.cnt)-&gt;s++;
        cnt &#x3D; w.cnt;
    &#125;
    SharePtr&lt;T&gt;&amp; operator&#x3D;(SharePtr&lt;T&gt;&amp; s)
    &#123;
        if (this !&#x3D; &amp;s)
        &#123;
            release();
            (s.cnt)-&gt;s++;
            cnt &#x3D; s.cnt;
            _ptr &#x3D; s._ptr;
        &#125;
        return *this;
    &#125;
    T&amp; operator*()
    &#123;
        return *_ptr;
    &#125;
    T* operator-&gt;()
    &#123;
        return _ptr;
    &#125;
    friend class WeakPtr&lt;T&gt;; &#x2F;&#x2F;方便weak_ptr与share_ptr设置引用计数和赋值

    void release()
    &#123;
        if (cnt)
        &#123;
            cnt-&gt;s--;
            if (cnt-&gt;s &lt; 1)
            &#123;
                delete _ptr;
                _ptr &#x3D; nullptr;
                if (cnt-&gt;w &lt; 1)
                &#123;
                    delete cnt;
                    cnt &#x3D; NULL;
                &#125;
            &#125;
        &#125;
    &#125;

private:
    T* _ptr;
    Counter* cnt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="weak-ptr简单实现"><a href="#weak-ptr简单实现" class="headerlink" title="weak_ptr简单实现"></a>weak_ptr简单实现</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt;
class WeakPtr
&#123;
public: &#x2F;&#x2F;给出默认构造和拷贝构造，其中拷贝构造不能有从原始指针进行构造
    WeakPtr()
    &#123;
        _ptr &#x3D; nullptr;
        cnt &#x3D; nullptr;
    &#125;
    WeakPtr(const SharePtr&lt;T&gt;&amp; s) : _ptr(s._ptr), cnt(s.cnt)&#x2F;&#x2F;从shareptr构造weakptr
    &#123;
        if(cnt)
            cnt-&gt;w++;
    &#125;
    WeakPtr(const WeakPtr&lt;T&gt;&amp; w) : _ptr(w._ptr), cnt(w.cnt)&#x2F;&#x2F;从weakptr构造weakptr
    &#123;
        if(cnt)
        cnt-&gt;w++;
    &#125;
    ~WeakPtr()&#x2F;&#x2F;析构
    &#123;
        release();
    &#125;
    WeakPtr&lt;T&gt;&amp; operator&#x3D;(const WeakPtr&lt;T&gt;&amp; w)
    &#123;
        if (this !&#x3D; &amp;w)
        &#123;
            release();
            cnt &#x3D; w.cnt;
            cnt-&gt;w++;
            _ptr &#x3D; w._ptr;
        &#125;
        return *this;
    &#125;
    WeakPtr&lt;T&gt;&amp; operator&#x3D;(SharePtr&lt;T&gt;&amp; s)
    &#123;
        release();
        cnt &#x3D; s.cnt;
        cnt-&gt;w++;
        _ptr &#x3D; s._ptr;
        return *this;
    &#125;
    SharePtr&lt;T&gt; lock()
    &#123;
        return SharePtr&lt;T&gt;(*this);
    &#125;
    bool expired()
    &#123;
        if (cnt)
        &#123;
            if (cnt-&gt;s &gt; 0)
            &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
    friend class SharePtr&lt;T&gt;; &#x2F;&#x2F;方便weak_ptr与share_ptr设置引用计数和赋值

    void release()
    &#123;
        if (cnt)
        &#123;
            cnt-&gt;w--;
            _ptr &#x3D; nullptr;
            cnt &#x3D; nullptr;
        &#125;
    &#125;

private:
    T* _ptr;
    Counter* cnt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="13-内存"><a href="#13-内存" class="headerlink" title="13.内存"></a>13.内存</h3><h4 id="1-从系统层次上考虑"><a href="#1-从系统层次上考虑" class="headerlink" title="1.从系统层次上考虑"></a>1.从系统层次上考虑</h4><h4 id="1-1数据区、静态区、读写区（全局区）"><a href="#1-1数据区、静态区、读写区（全局区）" class="headerlink" title="1.1数据区、静态区、读写区（全局区）"></a>1.1数据区、静态区、读写区（全局区）</h4><ul>
<li>bss段：<strong>指那些没有初始化的和初始化为0的全局变量\静态变量。</strong><ul>
<li>bss类型的全局变量只占运行时的内存空间，而不占文件空间</li>
<li>os里指未初始化数据段。程序加载时会全部赋值为0。</li>
</ul>
</li>
<li>data段：<strong>data指那些初始化过（非零）的非const的全局变量\静态变量。</strong>（因为如果数据全是零，为了优化考虑，编译器把它当作bss处理）<ul>
<li>data类型的全局变量是即占文件空间，又占用运行时内存空间的</li>
<li>os里指已初始化数据段。</li>
</ul>
</li>
</ul>
<h4 id="1-2正文段、代码区、只读区"><a href="#1-2正文段、代码区、只读区" class="headerlink" title="1.2正文段、代码区、只读区"></a>1.2正文段、代码区、只读区</h4><ul>
<li><p>rodata段：ro代表<strong>read only</strong>，即只读数据(const)。</p>
</li>
<li><p>当<strong>const全局变量取地址或者使用extern时</strong>，会分配内存,const全局变量才会存放在rodata。(如果没有取地址操作，const全局变量就在符号表里。)</p>
</li>
<li><p>常量不一定就放在rodata里，有的立即数直接编码在指令里，存放在代码段(.text)中。</p>
<ul>
<li><pre><code>比如cout &lt;&lt; 1 &lt;&lt; endl;里的1
<pre class="line-numbers language-none"><code class="language-none">
- 对于字符串常量，编译器会**自动去掉重复的字符串**，保证一个字符串在一个可执行文件(EXE&#x2F;SO)中只存在一份拷贝。

  - &#96;&#96;&#96;
    chara[]&#x3D;&quot;123&quot;;
    charb[]&#x3D;&quot;123&quot;;
    &#x2F;&#x2F;“123”存在rodata里，但是只保留一份<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>text段：存放代码</p>
</li>
</ul>
<h4 id="1-3堆"><a href="#1-3堆" class="headerlink" title="1.3堆"></a>1.3堆</h4><h4 id="1-4栈"><a href="#1-4栈" class="headerlink" title="1.4栈"></a>1.4栈</h4><h4 id="2-C-中内存五区"><a href="#2-C-中内存五区" class="headerlink" title="2.C++中内存五区"></a>2.C++中内存五区</h4><p><img src="https://i.loli.net/2020/09/22/RxzAfspX2uKEhb6.png" alt="image.png"></p>
<ul>
<li>（1）<strong>栈区</strong>：局部变量，函数传参值，自动释放，效率高但内存少</li>
<li>（2）<strong>堆区</strong>：malloc函数从堆上申请内存，用free释放内存，若不释放，程序结束释放<ul>
<li>这个有点狭隘了，因为堆（heap）是C语言和操作系统的术语。</li>
<li><strong>或者叫自由存储区</strong>：自由存储区是C++基于new操作符的一个抽象概念。new操作符在此申请内存，用delete释放内存，若不释放，程序结束释放</li>
<li>自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</li>
<li>个人理解，自由存储区包含堆，因为new可以使用堆内存，也可以使用其他内存,比如静态区内存（需要你提前预分配内存，供给new使用）。</li>
</ul>
</li>
<li>（3）<strong>全局&#x2F;静态区</strong>：存储全局变量或静态变量。内存在编译时就分配好了（程序执行前），整个程序运行期间都存在，程序结束时释放。<ul>
<li>对应bss段和data段</li>
</ul>
</li>
<li>（4）<strong>常量存储区</strong>：存储常量（const），不允许修改。<ul>
<li>对应rodata段，包括<strong>const全局变量取地址或者使用extern时</strong>，会分配内存,const全局变量才会存放在rodata；</li>
<li>还有字符串</li>
</ul>
</li>
<li>（5）<strong>代码区</strong><ul>
<li>对应text段</li>
</ul>
</li>
</ul>
<p>堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。</p>
<h3 id="14-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#14-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="14.C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>14.C++里是怎么定义常量的？常量存放在内存的哪个位置？</h3><p><a href="https://blog.csdn.net/woainilixuhao/article/details/86521357">https://blog.csdn.net/woainilixuhao/article/details/86521357</a></p>
<ul>
<li><p>c语言</p>
<ul>
<li>c语言中const全局变量存储在只读数据段，编译期最初将其保存在符号表中，第一次使用时为其分配内存，在程序结束时释放。</li>
<li>而const局部变量（局部变量就是在函数中定义的一个const变量，）存储在栈中，代码块结束时释放。</li>
<li>在c语言中可以通过指针对const局部变量进行修改，而不可以对const全局变量进行修改。因为const全局变量是存储在只读数据段</li>
</ul>
</li>
<li><p>C++</p>
<ul>
<li><p><strong>在c++中，一个const不是必需创建内存空间，而在c中，一个const总是需要一块内存空间。</strong></p>
</li>
<li><p><strong>C++中的const全局变量</strong></p>
<ul>
<li>c++中<strong>是否要为const全局变量分配内存空间，取决于这个const变量的用途</strong></li>
<li><strong>如果是充当着一个值替换（即就是将一个变量名替换为一个值），那么就不分配内存空间（那它就是在符号表里）</strong></li>
<li><strong>不过当对这个const全局变量取地址或者使用extern时，会分配内存，存储在只读数据段(rodata段)。也是不能修改的。</strong></li>
</ul>
</li>
<li><p><strong>c++中的const局部变量</strong></p>
<ul>
<li><p>对于基础数据类型，也就是<strong>const int a &#x3D; 10这种，编译器会把它放到符号表中，不分配内存。如果当对其取地址时，会分配内存，在栈上</strong></p>
<ul>
<li><pre><code class="c++">const int B=100;
int main()
&#123;
    volatile const int A = 2;//const局部变量有取地址操作，分配到栈上
    int* p = (int*)&amp;A;
    *p = 1;
    cout &lt;&lt; A &lt;&lt; endl;//1
    cout &lt;&lt; *p &lt;&lt; endl;//1
    
    p = (int*)&amp;B;
    *p=200;//报错了，因为const全局变量有取地址操作时，会分配内存，分配在rodata段
    return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
    - 对于基础数据类型，如果用一个变量初始化const变量，如果const int a &#x3D; b,那么也是会给a分配内存到栈

    - 对于自定数据类型，比如类对象，那么也会分配内存到栈

**简略总结：**

- 对于普通的全局变量、静态变量，存放在数据区（.bss或者.data，区别就是有没有初始化）
  - 对于const全局变量取地址或者使用extern时，const全局变量存放在rodata。如果没有取地址或者使用extern，那它就在符号表，没有分配内存。
    - 符号表在哪？跟代码放在一块儿。
- 对于普通的局部变量，存放在栈
  - 对于const局部变量取地址时，const局部变量会存放在栈上。如果没有取地址操作时，那它就在符号表，没有分配内存。
    - 由编译器根据使用场景决定。比如没有取地址之类的操作的话，会优化为立即数。再者即使取地址操作了，也就是普通的栈变量，const是给编译器看的，毕竟C++不是虚拟机语言。
    - 其实在编译过程中，**对局部变量的符号比如&quot;a&quot;的操作就会被直接编译成对寄存器、栈的操作**，而原有的符号会消失（除非你开启了&#96;-g&#96;编译选项，那么编译器会保存局部变量到符号表用于调试）。
  - 还有两个情况也会分配内存（用一个变量初始化const变量或者是对于const局部自定义类对象）

### 15.顶层const和底层const

#### 1.底层const（指向常量的指针，其实只是不能通过指针来修改而已，只是对指针来看似乎是常量）

**指向常量的指针**：代表**不能改变其指向内容**的指针。声明时const可以放在类型名前后都可，拿int类型来说，声明时：const int和int const 是等价的。声明指向常量的指针也就是**底层const**，下面举一个例子：

&#96;&#96;&#96;c++
int num_a &#x3D; 1;
const int *p_a &#x3D; &amp;num_a; &#x2F;&#x2F;底层const
&#x2F;&#x2F;*p_a &#x3D; 2;  &#x2F;&#x2F;错误，指向“常量”的指针不能改变所指的对象
num_a &#x3D; 2;
cout &lt;&lt; *p_a &lt;&lt; endl;&#x2F;&#x2F;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过<strong>解引用符</strong>（操作符*）来改变它所指向的内容。上例中指针p_a指向的内容就不是常量，可以通过赋值语句：num_a&#x3D;2;  来改变它所指向的内容。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int a &#x3D; 1;  
&#x2F;&#x2F;int * pi &#x3D; &amp;a;  &#x2F;&#x2F;错误，&amp;a是底层const，不能赋值给非底层const 
const int * pi &#x3D; &amp;a; &#x2F;&#x2F;正确，&amp;a是底层const，可以赋值给底层const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="2-顶层const（指针常量，指针里的地址不能改变）"><a href="#2-顶层const（指针常量，指针里的地址不能改变）" class="headerlink" title="2.顶层const（指针常量，指针里的地址不能改变）"></a>2.顶层const（指针常量，指针里的地址不能改变）</h4><p>代表指针本身是常量，声明时必须初始化，之后<strong>它存储的地址值就不能再改变</strong>。声明时const必须放在指针符号<code>*</code>后面，即：<code>*const</code> 。声明常量指针就是<strong>顶层const</strong>，下面举一个例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int num_b &#x3D; 2;
int *const p_b &#x3D; &amp;num_b; &#x2F;&#x2F;顶层const
&#x2F;&#x2F;p_b &#x3D; &amp;num_a;  &#x2F;&#x2F;错误，常量指针不能改变存储的地址值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="3-区分"><a href="#3-区分" class="headerlink" title="3.区分"></a>3.区分</h4><ul>
<li><p>1.执行对象拷贝时有限制，<strong>常量的底层const不能赋值给非常量的底层const</strong>。也就是说，你只要能正确区分顶层const和底层const，你就能避免这样的赋值错误。下面举一个例子：</p>
<ul>
<li><pre><code class="c++">int num_c = 3;
const int *p_c = &amp;num_c;  //p_c为底层const的指针
//int *p_d = p_c;  //错误，不能将底层const指针赋值给非底层const指针。自己理解一下，因为你本来就无法通过p_c来修改num_c，如果这条通过编译了，那么将允许p_d去修改num_c。这显然不合理。但是可以通过const_cast来获取该权限
const int *p_d = p_c; //正确，可以将底层const指针复制给底层const指针
<pre class="line-numbers language-none"><code class="language-none">
- 2 使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为**const_cast只能改变运算对象的底层const**。下面举一个例子：

  - &#96;&#96;&#96;c++
    int num_e &#x3D; 4;
    const int *p_e &#x3D; &amp;num_e;
    &#x2F;&#x2F;*p_e &#x3D; 5;  &#x2F;&#x2F;错误，不能改变底层const指针指向的内容
    int *p_f &#x3D; const_cast&lt;int *&gt;(p_e);  &#x2F;&#x2F;正确，const_cast可以改变运算对象的底层const。但是使用时一定要知道num_e不是const的类型。
    *p_f &#x3D; 5;  &#x2F;&#x2F;正确，非顶层const指针可以改变指向的内容
    cout &lt;&lt; num_e;  &#x2F;&#x2F;输出5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="16-隐式类型转换"><a href="#16-隐式类型转换" class="headerlink" title="16.隐式类型转换"></a>16.隐式类型转换</h3><h4 id="1-内置数据类型"><a href="#1-内置数据类型" class="headerlink" title="1.内置数据类型"></a>1.内置数据类型</h4><p>在数据类型上表现是<strong>少字节数据类型，转换成多字节数据类型</strong>，保证数据的完整性；</p>
<p>或者说低精度的变量给高精度变量赋值会发生隐式类型转换</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i&#x3D;3;
double j &#x3D; 3.1;
i+j;&#x2F;&#x2F;i会被转换成double类型，然后才做加法运算。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="2-类类型"><a href="#2-类类型" class="headerlink" title="2.类类型"></a>2.类类型</h4><p>对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<ul>
<li><strong>可以用 单个形参来调用 的构造函数定义了从 形参类型 到 该类类型 的一个隐式转换。</strong></li>
<li>“可以用单个形参进行调用” 并不是指构造函数只能有一个形参，而是它<strong>可以有多个形参，但那些形参都是有默认实参</strong>的。(<strong>可以使用一个实参进行调用，不是指构造函数只能有一个形参。</strong>)</li>
<li><strong>explicit只能用于类内部构造函数的声明。</strong></li>
<li><strong>隐式类类型转换容易引起错误，除非你有明确理由使用隐式类类型转换，否则，将可以用一个实参进行调用的构造函数都声明为explicit来防止隐式转换。</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test
&#123;
	public:
		Test(int i,double j&#x3D;2.0);
&#125;;

Test t1 &#x3D; 1;&#x2F;&#x2F;正确，由于强制类型转换，1先被Test构造函数构造成Test对象，然后才被赋值给t1
Test t2(1);&#x2F;&#x2F;正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test
&#123;
	public:
		explicit Test(int i,double j&#x3D;2.0);
&#125;;

Test t1 &#x3D; 1;&#x2F;&#x2F;错误！由于禁止隐式转换，不存在由&#39;int&#39;到&#39;Test&#39;的适当构造函数
Test t2(1);&#x2F;&#x2F;正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="17-C-函数栈空间的最大值"><a href="#17-C-函数栈空间的最大值" class="headerlink" title="17.C++函数栈空间的最大值"></a>17.C++函数栈空间的最大值</h3><p>windows默认是1M，不过可以调整。</p>
<p>linux默认是8M。这个函数栈其实就是主线程栈，每个子线程也会有新的8M。ulimit -s这个命令可以查看系统默认的线程栈空间</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;windows下
int main()
&#123;
    char a[1024*1024];&#x2F;&#x2F;1M，直接报错
    &#x2F;&#x2F;vector&lt;char&gt; a(1024*1024);&#x2F;&#x2F;这绝对不会报错，因为动态数组，数据存在堆上
    return 0;
&#125;
&#x2F;&#x2F;linux下
int main()
&#123;
    char a[8*1024*1024];&#x2F;&#x2F;8M，直接报错
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="18-extern的用法-与存储持续性、作用域和链接性有重复"><a href="#18-extern的用法-与存储持续性、作用域和链接性有重复" class="headerlink" title="18.extern的用法(与存储持续性、作用域和链接性有重复)"></a>18.extern的用法(与存储持续性、作用域和链接性有重复)</h3><p>extern关键字有两个作用</p>
<h4 id="1-告知编译器extern-“C”"><a href="#1-告知编译器extern-“C”" class="headerlink" title="1.告知编译器extern “C”"></a>1.告知编译器extern “C”</h4><ul>
<li>当它与”C”一起连用时，如: extern “C” void fun(int a, int b);则<strong>告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的。</strong></li>
<li>因为C++支持函数的重载，所以<strong>C++的规则在翻译这个函数名时会把fun这个名字变得面目全非</strong>（为了区分不同的重载函数），可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的”脾气”了(不同的编译器采用的方法不一样)。</li>
<li>而C不支持，这就导致了C++在编译的时候，C++的函数名会和参数一起被编成函数名，<strong>而C只是函数名</strong>。</li>
<li>所以在链接的时候，找不到我们定义的那个函数。（指的是c文件中编写的函数实现，而我们cpp文件中无法正确调用）</li>
</ul>
<p><strong>举例：</strong></p>
<p>我们有一个函数是.c文件即c语言写的，之前写好的，我们现在要在另一个cpp文件里调用它</p>
<p>错误版本：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.c
int foo() &#123;
	return 1;
&#125;

&#x2F;&#x2F;b.cpp
#include&lt;iostream&gt;
using namespace std;
int foo();&#x2F;&#x2F;没有extern&quot;C“声明时

int main()
&#123;
    cout &lt;&lt; foo() &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F;可以通过编译!但是链接时报错:b.obj中无法解析的外部符号&quot;int_cdecl foo(void)&quot; (?foo@@YAHXZ)，函数main中引用了该符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>正确版本：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.c
int foo() &#123;
	return 1;
&#125;

&#x2F;&#x2F;b.cpp
#include&lt;iostream&gt;
using namespace std;
extern&quot;C&quot; &#123;
    int foo();
&#125;

int main()
&#123;
    cout &lt;&lt; foo() &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F;运行正确！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>典型的写法：在头文件中加入</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif

&#x2F;*add somethings*&#x2F;

#ifdef __cplusplus
&#125;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-共享-参见一、1-extern的跨文件用法"><a href="#2-共享-参见一、1-extern的跨文件用法" class="headerlink" title="2.共享(参见一、1.extern的跨文件用法)"></a>2.共享(参见一、1.extern的跨文件用法)</h4><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</p>
<p>extern:该变量&#x2F;函数是从别的文件来的，或者该变量&#x2F;函数可以被别的文件使用。</p>
<p><code>extern int yyd;//这是声明</code></p>
<p><code>extern int yyd=1;//这是定义</code></p>
<p>1.两个文件都加上extern声明，不过只能有一个定义。正确</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd &#x3D; 1;
void test2();
int main() &#123;
    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd;
void test2() &#123;
    cout &lt;&lt; yyd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.第一个文件里没有extern，第二个文件extern声明。正确</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
int yyd &#x3D; 1;
void test2();
int main() &#123;
    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
extern int yyd;
void test2() &#123;
    cout &lt;&lt; yyd&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>3.各种错误实例</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
int yyd;
&#x2F;&#x2F;b.cpp
int yyd;&#x2F;&#x2F;错误!


&#x2F;&#x2F;a.cpp
extern int yyd&#x3D;0;
&#x2F;&#x2F;b.cpp
int yyd;&#x2F;&#x2F;错误！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>总结：</strong></p>
<ul>
<li>只能有一个份定义。定义时加不加extern都行</li>
<li>定义<ul>
<li><code>extern int  yyd=1;</code></li>
<li>或者</li>
<li><code>int yyd=1;</code></li>
</ul>
</li>
<li>声明<ul>
<li><code>extern int yyd;</code></li>
</ul>
</li>
</ul>
<h4 id="3-extern-和-static"><a href="#3-extern-和-static" class="headerlink" title="3. extern 和 static"></a>3. extern 和 static</h4><ul>
<li>(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.</li>
<li>(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.</li>
</ul>
<p><strong>区别：</strong>这两个相当于水火不容，一个是为了限制在本文件内，一个是为了跨文件</p>
<ul>
<li>extern和static不能同时修饰一个变量</li>
<li>static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了。<ul>
<li>extern修饰的全局变量，声明和定义可以分开。</li>
</ul>
</li>
<li>static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它。<ul>
<li>extern就是为跨文件而生</li>
</ul>
</li>
</ul>
<p><strong>全局静态变量的作用</strong></p>
<ul>
<li><p>如果文件a定义了一个静态外部变量（全局静态变量），其名称与另一个文件b中声明的常规外部变量（普通全局变量）相同，则在该文件a中，全局静态变量将隐藏外部的全局变量.</p>
</li>
<li><p>可使用链接性为内部的静态变量（全局静态变量）<strong>在同一个文件</strong>中的多个函数之间共享数据。</p>
</li>
<li><p>如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。</p>
</li>
<li><p>其实总结就是用static将变量的链接性变为了内部的，使之只能在一个文件中使用。</p>
</li>
<li><p>用static也可以将函数的链接性变为了内部的，使之只能在一个文件中使用。要知道<strong>函数，默认都是自带extern的。使用static可以将函数只能在本文件使用</strong>。</p>
<ul>
<li><pre><code class="c++">//a.cpp
static int parivate(double x);
...
static int private(double x);
<pre class="line-numbers language-none"><code class="language-none">
&#96;&#96;&#96;c++
- extern和static肯定是不能同时出现的。因为extern是为了说明这是个跨文件的变量。而static则是限定，这是个只支持在本文件使用的变量。二者是矛盾和对立的。

​&#96;&#96;&#96;c++
&#x2F;&#x2F;a.cpp
int yyd&#x3D;20;&#x2F;&#x2F;普通的全局变量
&#x2F;&#x2F;b.cpp
static int yyd&#x3D;10;&#x2F;&#x2F;你要是写int yyd&#x3D;10;会报错的
&#x2F;&#x2F;你要是写extern int yyd;&#x2F;&#x2F;那就是引入了a文件的变量
&#x2F;&#x2F;而写static int yyd&#x3D;10，则是不会报错，隐藏了a文件的普通全局变量yyd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
#include &lt;iostream&gt;
using namespace std;
int yyd&#x3D;1;
void test2();
int main() &#123;

    test2();
    return 0;
&#125;
&#x2F;&#x2F;b.cpp
#include &lt;iostream&gt;
using namespace std;
static int yyd;
void test2() &#123;
    int yyd &#x3D; 2;
    cout &lt;&lt; &quot;局部变量：&quot;&lt;&lt;yyd&lt;&lt;endl;
    cout &lt;&lt; &quot;全局变量:&quot; &lt;&lt; ::yyd &lt;&lt; endl;
&#125;
&#x2F;&#x2F;输出
&quot;局部变量：&quot; 2
&quot;全局变量:&quot;  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;a.cpp
int tom&#x3D;3;
int dick&#x3D;30;
static int harry&#x3D;300;

&#x2F;&#x2F;b.cpp
extern int tom;
static int dick&#x3D;10;
int harry&#x3D;200;

&#x2F;&#x2F;两个文件使用了同一个tom变量，但使用了不同的dick和harry变量。两个tom变量的地址相同，而两个dick和harry变量的地址不同。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-extern-和const"><a href="#4-extern-和const" class="headerlink" title="4.extern 和const"></a>4.extern 和const</h4><ul>
<li>默认const全局变量的链接性是内部的，如同自带static。如果你希望是外部的，需要定义里自己加上extern</li>
<li>一般的全局变量的链接性为外部的，但是const全局变量的链接性是内部的。也就是说，在C++看来，全局const定义，就如同自带static一样</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a&#x3D;1;&#x2F;&#x2F;全局变量，链接性是外部的
static int b&#x3D;2;&#x2F;&#x2F;全局静态变量，链接性是内部的
const int c&#x3D;3;&#x2F;&#x2F;全局const变量，链接性是内部的
extern const int d&#x3D;4;&#x2F;&#x2F;全局const变量，链接性是外部的
const char* g_str&#x3D;&quot;123456&quot;;&#x2F;&#x2F;特别注意！这是个普通的全局const变量，链接性是外部的。因为const修饰的是char*而不是g_str
int mian()
&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>特别注意</strong>：<code>const char* g_str = &quot;123456&quot;</code>，g_str只是一个普通的全局变量，不是const全局变量，链接性是外部，因为const修饰的是char*而不是g_str;</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">我只是想提醒你，
 const char* g_str &#x3D; &quot;123456&quot; 与 const char g_str[] &#x3D;&quot;123465&quot;是不同的， 前面那个const 修饰的是char *而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你像让char*g_str遵守const的全局常量的规则，最好这么定义
 const char* const g_str&#x3D;&quot;123456&quot;.
    
&#x2F;&#x2F;a.cpp
const char* g_str&#x3D;&quot;123456&quot;;&#x2F;&#x2F;特别注意！这是个普通的全局const变量，链接性是外部的。因为const修饰的是char*而不是g_str
const int a&#x3D;1;&#x2F;&#x2F;全局const变量，链接性是内部的
extern const int b&#x3D;1;&#x2F;&#x2F;全局const变量，链接性是外部的
&#x2F;&#x2F;b.cpp
extern const char* g_str;&#x2F;&#x2F;正确
extern const int a;&#x2F;&#x2F;错误！链接时找不到
extern const int b;&#x2F;&#x2F;正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="19-回答一下new与malloc的区别是什么"><a href="#19-回答一下new与malloc的区别是什么" class="headerlink" title="19.回答一下new与malloc的区别是什么"></a>19.回答一下new与malloc的区别是什么</h3><p>在这里注意了，free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重 要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，释放内存后应把把指针指向NULL，防止指针在后面不小心又被使用，造成无法估计的后果。</p>
<h4 id="1-申请的内存所在位置（一个自由存储区一个堆）"><a href="#1-申请的内存所在位置（一个自由存储区一个堆）" class="headerlink" title="1.申请的内存所在位置（一个自由存储区一个堆）"></a>1.申请的内存所在位置（一个自由存储区一个堆）</h4><p>new操作符从<strong>自由存储区（free store）</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆</strong>上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
<p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，（或者栈也都有可能）这都看operator new()在哪里为对象分配内存。</p>
<p><strong>举例：new从静态存储区分配内存的例子。思路就是提前分配好一块静态区内存，供给new使用。（其实内存不是new分配的，而是new来定位）</strong></p>
<p>堆上new的对象需要手动delete，而静态区上new的无需自己管理。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
#include &lt;new&gt;&#x2F;&#x2F;需要添加该头文件
using namespace std;
const int ARRLEN &#x3D; 100;
int static_buf[ARRLEN];&#x2F;&#x2F;提前分配好一块静态区内存，供给new使用。
const int N &#x3D; 5;
int main()
&#123;
    int* p1;&#x2F;&#x2F;指针变量p1存在栈中,存储的地址指向堆。p1需要手动释放，即delete[]
    int* p2; &#x2F;&#x2F;指针变量p2存在栈中，存储的地址指向静态区。p2自动释放，无需手动delete，因为内存在静态区，静态区的内存程序员从来不需要管理。
    &#x2F;&#x2F;避免了内存泄露，但是牺牲了内存访问的独立性（第二次new的时候，第一次new产生的数据的没了）。
    cout &lt;&lt; &quot;   static_buf address:&quot; &lt;&lt; static_buf &lt;&lt; endl;
    for (int j &#x3D; 0; j &lt; 3; j++)
    &#123;
        cout &lt;&lt; &quot;\n\n\n&quot;;
        p1 &#x3D; new int[N];
        p2 &#x3D; new (static_buf)int[N];&#x2F;&#x2F;从指定区域static_buf地址分配内存，这里是从静态区分配。其
        &#x2F;&#x2F;实这就是定位new，内存不是new来分配的，而是之前分配好的，new只是起到了定位的作用。new (static_buf)int[N]; new (static_buf)将地址static_buf变成void*，然后再进行对象初始化，即int[N]初始化，整个表达式返回一个int*
        for (int i &#x3D; 0; i &lt; N; i++)
        &#123;
            p1[i] &#x3D; p2[i] &#x3D; i;
            cout &lt;&lt; &quot;   p1--&gt;&quot; &lt;&lt; &amp;p1[i] &lt;&lt; &quot;   value:&quot; &lt;&lt; p1[i] &lt;&lt; &quot;  &quot;;
            cout &lt;&lt; &quot;   p2--&gt;&quot; &lt;&lt; &amp;p2[i] &lt;&lt; &quot;   value:&quot; &lt;&lt; p2[i] &lt;&lt; endl;&#x2F;&#x2F;打印出每个元素的地址和值
        &#125;

        delete[]p1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上边的代码，反复执行了3次heap new和3次静态区new。每次在堆上new的地址都不一样，而使用静态区内存new，每次new都是使用的同一个静态区（你自己预留的内存）。</p>
<p><img src="https://i.loli.net/2020/09/09/j3z9RilNWLBf8cJ.png" alt="image.png"></p>
<p><strong>定位new：（new从静态存储区分配内存的例子其实用的就是这个，内存不是new分配的，而是提前分配好的，new只是来定位）</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">new (place_address) type&#x2F;&#x2F;第一步，new将place_address转换成void*，然后在该地址处进行对象初始化工作，即type
&#x2F;&#x2F;举例：
int* p &#x3D; new (static_buf)int[N];  new (static_buf)将地址static_buf变成void*，然后再进行对象初始化，即int[N]初始化，整个表达式返回一个int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* operator new(size_t,void*) &#x2F;&#x2F;不允许重定义这个版本的operator new<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个operator new<strong>不分配任何的内存</strong>，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p>
<p>简单来说就是<strong>定位new</strong>运算符只是返回传递给它的地址，并将其强制转换为void *，以便能够赋给任何指针类型。</p>
<h4 id="2-返回类型安全性（new是类型安全性操作符，无需类型转换，而malloc需要强制转换）"><a href="#2-返回类型安全性（new是类型安全性操作符，无需类型转换，而malloc需要强制转换）" class="headerlink" title="2.返回类型安全性（new是类型安全性操作符，无需类型转换，而malloc需要强制转换）"></a>2.返回类型安全性（new是类型安全性操作符，无需类型转换，而malloc需要强制转换）</h4><ul>
<li><strong>new操作符内存分配成功时，返回的是对象类型的指针</strong>，类型严格与对象匹配，无须进行类型转换，故new是符合<strong>类型安全</strong>性的操作符。</li>
<li>而*<em>malloc内存分配成功则是返回void *** ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</li>
</ul>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p>
<h4 id="3-内存分配失败时的返回值（new失败抛出bad-allloc异常，malloc失败返回NULL）"><a href="#3-内存分配失败时的返回值（new失败抛出bad-allloc异常，malloc失败返回NULL）" class="headerlink" title="3.内存分配失败时的返回值（new失败抛出bad_allloc异常，malloc失败返回NULL）"></a>3.内存分配失败时的返回值（new失败抛出bad_allloc异常，malloc失败返回NULL）</h4><ul>
<li>new内存分配失败时，会抛出bad_alloc异常，它<strong>不会返回NULL</strong>；</li>
<li>malloc分配内存失败时返回NULL。</li>
</ul>
<p>在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *a  &#x3D; (int *)malloc ( sizeof (int ));
if(a&#x3D;&#x3D;NULL)&#x2F;&#x2F;说明malloc分配失败
&#123;
    ...
&#125;
else
&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * a &#x3D; new int();
if(a&#x3D;&#x3D;NULL)
&#123;
    ...
&#125;
else
&#123;   
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实际上这样做<strong>一点意义也没有</strong>。因为c++里的new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">try
&#123;
    int *a &#x3D; new int();
&#125;
catch (bad_alloc)
&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-是否需要指定内存大小（new编译器会自行根据类型计算所需内存空间，malloc需要人工显式地指出所需空间）"><a href="#4-是否需要指定内存大小（new编译器会自行根据类型计算所需内存空间，malloc需要人工显式地指出所需空间）" class="headerlink" title="4.是否需要指定内存大小（new编译器会自行根据类型计算所需内存空间，malloc需要人工显式地指出所需空间）"></a>4.是否需要指定内存大小（new编译器会自行根据类型计算所需内存空间，malloc需要人工显式地指出所需空间）</h4><ul>
<li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算</li>
<li>而malloc则需要显式地指出所需内存的尺寸。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* p1&#x3D;new int;
int* p2&#x3D;(int*)malloc(sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;...&#125;
A * ptr &#x3D; new A;
A * ptr &#x3D; (A *)malloc(sizeof(A)); &#x2F;&#x2F;需要显式指定所需内存大小sizeof(A);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。</p>
<h4 id="5-是否调用构造函数-x2F-析构函数（new将分配内存，且调用构造函数。malloc只是机械的与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，它并没有进行构造函数的调用）"><a href="#5-是否调用构造函数-x2F-析构函数（new将分配内存，且调用构造函数。malloc只是机械的与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，它并没有进行构造函数的调用）" class="headerlink" title="5.是否调用构造函数&#x2F;析构函数（new将分配内存，且调用构造函数。malloc只是机械的与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，它并没有进行构造函数的调用）"></a>5.是否调用构造函数&#x2F;析构函数（new将分配内存，且调用构造函数。malloc只是机械的与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，它并没有进行构造函数的调用）</h4><ul>
<li><p>new的功能是在堆区新建一个对象，并返回该对象的指针。</p>
<ul>
<li>所谓的【新建对象】的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。</li>
</ul>
</li>
<li><p>而malloc只是机械的分配一块内存，如果用mallco在堆区创建一个对象的话，是不会调用构造函数的</p>
<ul>
<li>严格说来用malloc不能算是新建了一个对象，只能说是与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事（Malloc不做任何解释，只是机械的分配一块某大小的内存，然后返回void*，解释是程序员强制转换的结果）</li>
</ul>
</li>
<li><p>同样的，用delete去释放一个堆区的对象，会调用该对象的析构函数</p>
</li>
<li><p>用free去释放一个堆区的对象，不会调用该对象的析构函数</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;malloc.h&gt;

class TEST
&#123;
private:
    int num1;
    int num2;
public:
    TEST()
    &#123;
        num1 &#x3D; 10;
        num2 &#x3D; 20;
    &#125;
    void Print()
    &#123;
        std::cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; std::endl;
    &#125;
&#125;;

int main(void)
&#123;
    &#x2F;&#x2F; 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间
    &#x2F;&#x2F; 解释为是一个TEST类对象，这不会调用TEST的默认构造函数
    TEST * pObj1 &#x3D; (TEST *)malloc(sizeof(TEST));&#x2F;&#x2F;Malloc不做任何解释，返回void*,解释是程序员强制转换的结果
    pObj1-&gt;Print();

    &#x2F;&#x2F; 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数
    TEST * pObj2 &#x3D; new TEST;
    pObj2-&gt;Print();

    return 0;
&#125;
&#x2F;*
运行结果：

-----------------------------
-842150451 -842150451       |
10 20                       |
请按任意键继续. . .         |
-----------------------------

我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值。因为没有经过构造函数构造。
而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这也是上面我为什么说使用malloc&#x2F;free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造&#x2F;析构的类型通通不合适（比如string）。</p>
<h4 id="6-对数组的处理（C-提供了new-与delete-来专门处理数组类型，new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。但是malloc就只会给你一个原始内存，并且还需要我们手动自定数组的大小）"><a href="#6-对数组的处理（C-提供了new-与delete-来专门处理数组类型，new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。但是malloc就只会给你一个原始内存，并且还需要我们手动自定数组的大小）" class="headerlink" title="6.对数组的处理（C++提供了new[]与delete[]来专门处理数组类型，new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。但是malloc就只会给你一个原始内存，并且还需要我们手动自定数组的大小）"></a>6.对数组的处理（C++提供了new[]与delete[]来专门处理数组类型，new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。但是malloc就只会给你一个原始内存，并且还需要我们手动自定数组的大小）</h4><p>C++提供了new[]与delete[]来专门处理数组类型:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A* ptr &#x3D; new A[10];&#x2F;&#x2F;分配10个A对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用new[]分配的内存必须使用delete[]进行释放：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">delete[] ptr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>
<p>至于malloc，它并不知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * ptr &#x3D; (int *) malloc( 10*sizeof(int) );&#x2F;&#x2F;分配一个10个int元素的数组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="7-new与malloc是否可以相互调用（operator-new-的实现可以基于malloc，而malloc的实现不可以去调用new）"><a href="#7-new与malloc是否可以相互调用（operator-new-的实现可以基于malloc，而malloc的实现不可以去调用new）" class="headerlink" title="7.new与malloc是否可以相互调用（operator new() 的实现可以基于malloc，而malloc的实现不可以去调用new）"></a>7.new与malloc是否可以相互调用（operator new() 的实现可以基于malloc，而malloc的实现不可以去调用new）</h4><p>operator new &#x2F;operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new &#x2F;operator delete 的一种简单方式，其他版本也与之类似：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void * operator new (sieze_t size)
&#123;
    void * mem &#x3D; malloc(size)
    if(mem!&#x3D;NULL)
        return mem;
    else
        throw bad_alloc();
&#125;
void operator delete(void *mem) noexcept
&#123;
    free(mem);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="8-是否可以被重载-new-operator不可以重载，但operator-new-可以，就是负责内存分配的那个函数，返回void"><a href="#8-是否可以被重载-new-operator不可以重载，但operator-new-可以，就是负责内存分配的那个函数，返回void" class="headerlink" title="8.是否可以被重载(new operator不可以重载，但operator new()可以，就是负责内存分配的那个函数，返回void*)"></a>8.是否可以被重载(new operator不可以重载，但operator new()可以，就是负责内存分配的那个函数，返回void*)</h4><p>new operator 是 C++ 保留关键字，我们无法改变其含义，但我们可以改变new完成它功能时调用的两个函数，operator new() 和 placement new()。</p>
<p>opeartor new &#x2F;operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;这些版本可能抛出异常
void * operator new(size_t);&#x2F;&#x2F;分配某大小的内存，返回void*，这是new operator的第一步
void * operator new[](size_t);
void * operator delete (void * )noexcept;
void * operator delete[](void *0)noexcept;
&#x2F;&#x2F;这些版本承诺不抛出异常
void * operator new(size_t ,nothrow_t&amp;) noexcept;
void * operator new[](size_t, nothrow_t&amp; );
void * operator delete (void *,nothrow_t&amp; )noexcept;
void * operator delete[](void *0,nothrow_t&amp;)noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new &#x2F;operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>
<p>而malloc&#x2F;free并<strong>不允许重载</strong>。</p>
<h4 id="9-能够直观地重新分配内存（malloc分配后的内存，如果后来觉得内存不足，可以realloc函数进行内存重新分配实现内存的扩充。new不行）"><a href="#9-能够直观地重新分配内存（malloc分配后的内存，如果后来觉得内存不足，可以realloc函数进行内存重新分配实现内存的扩充。new不行）" class="headerlink" title="9. 能够直观地重新分配内存（malloc分配后的内存，如果后来觉得内存不足，可以realloc函数进行内存重新分配实现内存的扩充。new不行）"></a>9. 能够直观地重新分配内存（malloc分配后的内存，如果后来觉得内存不足，可以realloc函数进行内存重新分配实现内存的扩充。new不行）</h4><p>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>
<p>new没有这样直观的配套设施来扩充内存。</p>
<h4 id="10-客户处理内存分配不足（分配内存时内存不足时，在抛出异常之前，对于new，客户能够指定处理函数或重新制定分配器，而malloc内存不足就只会呆呆地返回NULL，无法通过用户代码进行处理）"><a href="#10-客户处理内存分配不足（分配内存时内存不足时，在抛出异常之前，对于new，客户能够指定处理函数或重新制定分配器，而malloc内存不足就只会呆呆地返回NULL，无法通过用户代码进行处理）" class="headerlink" title="10.客户处理内存分配不足（分配内存时内存不足时，在抛出异常之前，对于new，客户能够指定处理函数或重新制定分配器，而malloc内存不足就只会呆呆地返回NULL，无法通过用户代码进行处理）"></a>10.客户处理内存分配不足（分配内存时内存不足时，在抛出异常之前，对于new，客户能够指定处理函数或重新制定分配器，而malloc内存不足就只会呆呆地返回NULL，无法通过用户代码进行处理）</h4><p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是<strong>new-handler</strong>。new_handler是一个指针类型：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace std
&#123;
    typedef void (*new_handler)();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace std
&#123;
    new_handler set_new_handler(new_handler p ) throw();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>
<p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>特征</th>
<th>new&#x2F;delete</th>
<th>malloc&#x2F;free</th>
</tr>
</thead>
<tbody><tr>
<td>分配内存的位置</td>
<td>自由存储区（抽象概念，可以是堆、静态区等等）</td>
<td>堆</td>
</tr>
<tr>
<td>函数的返回值</td>
<td>完整类型指针（指new operator）</td>
<td>void*</td>
</tr>
<tr>
<td>内存分配失败返回值</td>
<td>默认抛出异常（这其实就是operator new()与malloc的区别）</td>
<td>返回NULL</td>
</tr>
<tr>
<td>分配内存时内存不足，<br />抛出异常之前</td>
<td>客户能够指定处理函数或重新制定分配器</td>
<td>无法通过用户代码进行处理</td>
</tr>
<tr>
<td>分配内存的大小</td>
<td>由编译器根据类型计算得出</td>
<td>必须显式指定字节数</td>
</tr>
<tr>
<td>处理数组</td>
<td>有处理数组的new版本new[]</td>
<td>需要用户计算数组的大小后进行内存分配</td>
</tr>
<tr>
<td>已分配内存的扩充</td>
<td>无法直观地处理</td>
<td>使用realloc简单完成</td>
</tr>
<tr>
<td>是否相互调用</td>
<td>可以，看具体的operator new&#x2F;delete实现（operator new()可以调用malloc）</td>
<td>不可调用new</td>
</tr>
<tr>
<td>函数重载</td>
<td>允许(operator new()允许)</td>
<td>不允许</td>
</tr>
<tr>
<td>构造函数与析构函数</td>
<td>调用(new operator调用)</td>
<td>不调用</td>
</tr>
</tbody></table>
<h3 id="20-C-new的三种形态"><a href="#20-C-new的三种形态" class="headerlink" title="20.C++ new的三种形态"></a>20.C++ new的三种形态</h3><h4 id="1-new-operator（new运算符，包含三个步骤）"><a href="#1-new-operator（new运算符，包含三个步骤）" class="headerlink" title="1.new operator（new运算符，包含三个步骤）"></a>1.new operator（new运算符，包含三个步骤）</h4><p>new的第一种形态是new operator，它是语言内建的， 是C++ 保留关键字，不能重载。new operator完成以下三件工作：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1. allocate memory for this object.&#x2F;&#x2F;1.为对象分配内存。类似于malloc的工作，其实是由operator new完成,分配内存，返回void*，但是一定要区别于new operator

2. call constructor to init that memory.&#x2F;&#x2F;2.调用构造函数来初始化这块儿内存。通过placement new完成

3. return the pointer of this object.&#x2F;&#x2F;3.返回指向该对象的指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如：<code>string *pStr = new string(“Memory Management”);</code></p>
<p>它实际完成以下三件事：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 1. 为string对象分配raw内存

void *memroy &#x3D; operator new( sizeof(string) );&#x2F;&#x2F;operator new就类似于malloc，分配内存，返回void*，但是一定要区别于new operator

&#x2F;&#x2F; 2. 调用构造函数初始化内存中的对象

call string::string() on memory

&#x2F;&#x2F; 3. 获得对象指针

string *pStr &#x3D; static_cast&lt;string *&gt;(memory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第1步申请内存，通过operator new完成；第2步在指定的内存上调用构造函数初始化对象，通过placement new完成。这便是new的另外两种形态。</p>
<h4 id="2-operator-new-（operator-new-函数，仅仅是分配内存而已，也是输入需要的内存byte，然后返回void-。类似于malloc，区别就在于分配失败时异常还是返回NULL）"><a href="#2-operator-new-（operator-new-函数，仅仅是分配内存而已，也是输入需要的内存byte，然后返回void-。类似于malloc，区别就在于分配失败时异常还是返回NULL）" class="headerlink" title="2.operator new()（operator new()函数，仅仅是分配内存而已，也是输入需要的内存byte，然后返回void *。类似于malloc，区别就在于分配失败时异常还是返回NULL）"></a>2.operator new()（operator new()函数，仅仅是分配内存而已，也是输入需要的内存byte，然后返回void *。类似于malloc，区别就在于分配失败时异常还是返回NULL）</h4><p>operator new是普通操作符，和加减乘除操作符的地位一样，可以重载。</p>
<p>默认情况下，operator new尝试从堆上申请内存，如果成功则返回内存指针，如果失败会调用new_handler，然后继续重复前面过程，直到抛出异常（bad_alloc）为止。</p>
<p>operator new函数原型：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void * operator new(size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>operator new可以重载，可以为某个类单独重载，也可以全局重载（将改变所有operator new的行为方式）。如果重载了operator new，应该重载operator delete。</p>
<p>它跟malloc的区别就在于，内存分配失败时是产生异常，还是返回NULL</p>
<h4 id="3-placement-new（定位new，不分配内存，仅用于定位内存并进行对象的构造）"><a href="#3-placement-new（定位new，不分配内存，仅用于定位内存并进行对象的构造）" class="headerlink" title="3.placement new（定位new，不分配内存，仅用于定位内存并进行对象的构造）"></a>3.placement new（定位new，不分配内存，仅用于定位内存并进行对象的构造）</h4><p>（定位new）在已分配的原始内存中初始化一个对象。它与new的其他版本的不同之处在于，<strong>它不分配内存</strong>。相反，它接受指向已分配但未构造的内存的指针，并在该内存中初始化一个对象。<strong>placement new表达式能够在特定的、预分配的内存地址上构造一个对象</strong>。</p>
<p>placement new是c++标准库的一部分，使用时需包含<code>&lt;new&gt;</code>头文件。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void *s &#x3D; operator new( sizeof(A) );
A *p &#x3D; (A*)s;
new(p) A(2013); &#x2F;&#x2F; p-&gt;A::A(2013);，它其实会返回一个A*的指针
&#x2F;&#x2F; processing code…
p-&gt;~A();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果显示的调用placement new，也应该显示的调用与之对应的placement delete：p-&gt;~A();。这份工作本来应该由编译器自动完成：在使用new operator时，编译器会自动生成调用placement new的代码。所以，除非特别必要，不要直接使用placement new。只有当默认的new operator对内存的管理不能满足需要，希望自己手动管理内存时，才考虑使用placement new。就像STL中的allocator一样，它借助placement new来实现更灵活有效的内存管理。</p>
<h4 id="4-综合实例"><a href="#4-综合实例" class="headerlink" title="4.综合实例"></a>4.综合实例</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
#include &lt;new&gt;&#x2F;&#x2F;需要添加该头文件
using namespace std;
char test[1024];&#x2F;&#x2F;预分配静态区内存
class A &#123;
public:
    explicit A(int i &#x3D; 0):temp(i) &#123; cout &lt;&lt; &quot;构造&quot; &lt;&lt; endl; &#125;;
    void func() &#123; cout &lt;&lt; temp &lt;&lt; endl; &#125;
    ~A() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
private:
    int temp;
&#125;;
int main()
&#123;
    void* a &#x3D; new A(1);&#x2F;&#x2F;new operator
    ((A*)a)-&gt;func();&#x2F;&#x2F;使用c风格的强制转换其实不合适，应该用static_cast。
	&#x2F;&#x2F; static_cast&lt;A*&gt;(a)-&gt;func();
    A* b &#x3D; new A(2);&#x2F;&#x2F;new oprtator
    b-&gt;func();

    void* c &#x3D; operator new(sizeof(A));&#x2F;&#x2F;oprator new()分配内存
    new(c)A(3);&#x2F;&#x2F;定位new进行初始化，使用预分配的堆内存
    ((A*)c)-&gt;func();

    new(test)A(4);&#x2F;&#x2F;&#x2F;&#x2F;定位new进行初始化，使用静态区内存
    ((A*)test)-&gt;func();

    delete (A*)a;
    delete b;
    delete (A*)c;
    ((A*)test)-&gt;~A();&#x2F;&#x2F;使用静态区的，手动析构，或者等系统自己收回也行
    return 0;
&#125;
&#x2F;*
构造
1
构造
2
构造
3
构造
4
析构
析构
析构
析构
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="21-C-中的RTTI机制详解（运行时类型信息，与typeid、dynamic-cast相关，多态的实现是靠虚函数表，其实虚表里就有RTTI机制，因为虚函数表的第一个位置存放了指向type-info的指针，它包含了运行时类型信息）"><a href="#21-C-中的RTTI机制详解（运行时类型信息，与typeid、dynamic-cast相关，多态的实现是靠虚函数表，其实虚表里就有RTTI机制，因为虚函数表的第一个位置存放了指向type-info的指针，它包含了运行时类型信息）" class="headerlink" title="21.C++ 中的RTTI机制详解（运行时类型信息，与typeid、dynamic_cast相关，多态的实现是靠虚函数表，其实虚表里就有RTTI机制，因为虚函数表的第一个位置存放了指向type_info的指针，它包含了运行时类型信息）"></a>21.C++ 中的RTTI机制详解（运行时类型信息，与typeid、dynamic_cast相关，多态的实现是靠虚函数表，其实虚表里就有RTTI机制，因为虚函数表的第一个位置存放了指向type_info的指针，它包含了运行时类型信息）</h3><h4 id="1-RTTI概念"><a href="#1-RTTI概念" class="headerlink" title="1.RTTI概念"></a>1.RTTI概念</h4><p>RTTI是”Runtime Type Information”的缩写，意思是<strong>运行时类型信息，它提供了运行时确定对象类型的方法</strong>。即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。</p>
<h4 id="2-RTTI机制的产生"><a href="#2-RTTI机制的产生" class="headerlink" title="2.RTTI机制的产生"></a>2.RTTI机制的产生</h4><p>C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。<strong>和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制</strong>，并且C++最终生成的代码是直接与机器相关的。</p>
<p>（Java中任何一个类都可以通过反射机制来获取类的基本信息（接口、父类、方法、属性、Annotation等），而且Java中还提供了一个关键字，可以在运行时判断一个类是不是另一个类的子类或者是该类的对象，Java可以生成字节码文件，再由JVM（Java虚拟机）加载运行，字节码文件中可以含有类的信息。）</p>
<h4 id="3-typeid函数"><a href="#3-typeid函数" class="headerlink" title="3.typeid函数"></a>3.typeid函数</h4><ul>
<li><p>typeid的主要作用就是让用户知道当前的变量是什么类型的，对于内置数据类型以及自定义数据类型都生效，比如以下代码：</p>
<ul>
<li><pre><code class="c++">int main()
&#123;
    short s = 2;
    unsigned ui = 10;
    int i = 10;
    char ch = &#39;a&#39;;
    wchar_t wch = L&#39;b&#39;;
    float f = 1.0f;
    double d = 2;

    cout &lt;&lt; typeid(s).name() &lt;&lt; endl; // short
    cout &lt;&lt; typeid(ui).name() &lt;&lt; endl; // unsigned int
    cout &lt;&lt; typeid(i).name() &lt;&lt; endl; // int
    cout &lt;&lt; typeid(ch).name() &lt;&lt; endl; // char
    cout &lt;&lt; typeid(wch).name() &lt;&lt; endl; // wchar_t
    cout &lt;&lt; typeid(f).name() &lt;&lt; endl; // float
    cout &lt;&lt; typeid(d).name() &lt;&lt; endl; // double

    return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- 对于我们自定义的结构体、类，tpyeid都能支持
  - &#96;&#96;&#96;c++
    class A
    &#123;
    public:
         void Print() &#123; cout&lt;&lt;&quot;This is class A.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    class B : public A
    &#123;
    public:
         void Print() &#123; cout&lt;&lt;&quot;This is class B.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    struct C
    &#123;
         void Print() &#123; cout&lt;&lt;&quot;This is struct C.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    int main()
    &#123;
         A *pA1 &#x3D; new A();
         A a2;
      
         cout&lt;&lt;typeid(pA1).name()&lt;&lt;endl; &#x2F;&#x2F; class A *
         cout&lt;&lt;typeid(a2).name()&lt;&lt;endl; &#x2F;&#x2F; class A
      
         B *pB1 &#x3D; new B();
         cout&lt;&lt;typeid(pB1).name()&lt;&lt;endl; &#x2F;&#x2F; class B *
      
         C *pC1 &#x3D; new C();
         C c2;
      
         cout&lt;&lt;typeid(pC1).name()&lt;&lt;endl; &#x2F;&#x2F; struct C *
         cout&lt;&lt;typeid(c2).name()&lt;&lt;endl; &#x2F;&#x2F; struct C
      
         return 0;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>实质上typeid函数是一个返回类型为type_info类型</strong>的函数。而name()只是一个type_info类里的一个成员函数。</p>
</li>
<li><p><strong>type_info类：</strong></p>
</li>
<li><p>在type_info类中，复制构造函数和赋值运算符都是私有的，同时也没有默认的构造函数；所以，我们没有办法创建type_info类的变量，例如type_info A;这样是错误的。</p>
<ul>
<li><pre><code class="c++">class type_info
&#123;
public:
    virtual ~type_info();
    bool operator==(const type_info&amp; _Rhs) const; // 用于比较两个对象的类型是否相等
    bool operator!=(const type_info&amp; _Rhs) const; // 用于比较两个对象的类型是否不相等
    bool before(const type_info&amp; _Rhs) const;
  
    // 返回对象的类型名字，这个函数用的很多
    const char* name(__type_info_node* __ptype_info_node = &amp;__type_info_root_node) const;
    const char* raw_name() const;
private:
    void *_M_data;
    char _M_d_name[1];
    type_info(const type_info&amp; _Rhs);
    type_info&amp; operator=(const type_info&amp; _Rhs);
    static const char * _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    static void _Type_info_dtor(type_info *);
&#125;;
<pre class="line-numbers language-none"><code class="language-none">
- 观察以下两个例子，体会RTTI

  - &#96;&#96;&#96;c++
    &#x2F;&#x2F;例一
    #include &lt;iostream&gt;
    #include &lt;typeinfo&gt;
    using namespace std;
      
    class A
    &#123;
    public:
         void Print() &#123; cout&lt;&lt;&quot;This is class A.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    class B : public A
    &#123;
    public:
         void Print() &#123; cout&lt;&lt;&quot;This is class B.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    int main()
    &#123;
         A *pA &#x3D; new B();
         cout&lt;&lt;typeid(pA).name()&lt;&lt;endl; &#x2F;&#x2F; class A *
         cout&lt;&lt;typeid(*pA).name()&lt;&lt;endl; &#x2F;&#x2F; class A
         return 0;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><pre><code class="c++">//例二
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
using namespace std;
  
class A
&#123;
public:
     virtual void Print() &#123; cout&lt;&lt;&quot;This is class A.&quot;&lt;&lt;endl; &#125;//变成了虚函数
&#125;;
  
class B : public A
&#123;
public:
     void Print() &#123; cout&lt;&lt;&quot;This is class B.&quot;&lt;&lt;endl; &#125;
&#125;;
  
int main()
&#123;
     A *pA = new B();
     cout&lt;&lt;typeid(pA).name()&lt;&lt;endl; // class A *
     cout&lt;&lt;typeid(*pA).name()&lt;&lt;endl; // class B
     return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
  - pA是一个&#96;A*&#96;的指针，这个毋庸置疑。但是基类指针pA指向的对象其实都是派生类B，一个&#96;*pA&#96;被认定为class A，一个&#96;*pA&#96;被认定为class B。

  - 这就是RTTI在捣鬼了，**当类中不存在虚函数时，typeid是编译时期的事情，也就是静态类型，就如上面的cout&lt;&lt;typeid(\*pA).name()&lt;&lt;endl;输出class A一样；当类中存在虚函数时，typeid是运行时期的事情，也就是动态类型，就如上面的cout&lt;&lt;typeid(\*pA).name()&lt;&lt;endl;输出class B一样**，关于这一点，我们在实际编程中，经常会出错，一定要谨记。

  - 这就类似于，虚函数，运行时绑定。

- 使用type_info类中重载的&#x3D;&#x3D;和!&#x3D;比较两个对象的类型是否相等

  - &#96;&#96;&#96;c++
    class type_info
    &#123;
    public:
        virtual ~type_info();
        bool operator&#x3D;&#x3D;(const type_info&amp; _Rhs) const; &#x2F;&#x2F; 用于比较两个对象的类型是否相等
        bool operator!&#x3D;(const type_info&amp; _Rhs) const; &#x2F;&#x2F; 用于比较两个对象的类型是否不相等
    private:
        ...
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>这个会经常用到，通常用于比较两个带有虚函数的类的对象是否相等，例如以下代码： </p>
</li>
<li><pre><code class="c++">class A
&#123;
public:
     virtual void Print() &#123; cout&lt;&lt;&quot;This is class A.&quot;&lt;&lt;endl; &#125;
&#125;;
  
class B : public A
&#123;
public:
     void Print() &#123; cout&lt;&lt;&quot;This is class B.&quot;&lt;&lt;endl; &#125;
&#125;;
  
class C : public A
&#123;
public:
     void Print() &#123; cout&lt;&lt;&quot;This is class C.&quot;&lt;&lt;endl; &#125;
&#125;;
  
void Handle(A *a)
&#123;
     if (typeid(*a) == typeid(A))//typeid(*a)和typeid(A)都是一个type_info对象，也就是调用了type_info类中重载的 bool operator==(const type_info&amp; _Rhs) const; 
     &#123;
          cout&lt;&lt;&quot;I am a A truly.&quot;&lt;&lt;endl;
     &#125;
     else if (typeid(*a) == typeid(B))
     &#123;
          cout&lt;&lt;&quot;I am a B truly.&quot;&lt;&lt;endl;
     &#125;
     else if (typeid(*a) == typeid(C))
     &#123;
          cout&lt;&lt;&quot;I am a C truly.&quot;&lt;&lt;endl;
     &#125;
     else
     &#123;
          cout&lt;&lt;&quot;I am alone.&quot;&lt;&lt;endl;
     &#125;
&#125;
  
int main()
&#123;
     A *pA = new B();
     Handle(pA);//I am a B truly.
     delete pA;
     pA = new C();
     Handle(pA);//I am a C truly.
     return 0;
&#125;
这里输出的结果为：
I am a B truly.
I am a C truly.
<pre class="line-numbers language-none"><code class="language-none">
#### 4.dynamic_cast的内幕

- 先看个例子

  - &#96;&#96;&#96;c++
    #include &lt;iostream&gt;
    #include &lt;typeinfo&gt;
    using namespace std;
      
    class A
    &#123;
    public:
         virtual void Print() &#123; cout&lt;&lt;&quot;This is class A.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    class B
    &#123;
    public:
         virtual void Print() &#123; cout&lt;&lt;&quot;This is class B.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    class C : public A, public B
    &#123;
    public:
         void Print() &#123; cout&lt;&lt;&quot;This is class C.&quot;&lt;&lt;endl; &#125;
    &#125;;
      
    int main()
    &#123;
         A *pA &#x3D; new C;
         &#x2F;&#x2F;C *pC &#x3D; pA; &#x2F;&#x2F; Wrong
         C *pC &#x3D; dynamic_cast&lt;C *&gt;(pA);
         if (pC !&#x3D; NULL)
         &#123;
              pC-&gt;Print();
         &#125;
         delete pA;
    &#125;
    &#x2F;&#x2F;这里输出为：This is class C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>在上面代码中，如果我们直接将pA赋值给pC，这样编译器就会提示错误，而当我们加上了dynamic_cast之后，一切就ok了。那么dynamic_cast在后面干了什么呢？</p>
</li>
<li><p>dynamic_cast主要用于在多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转换类型，<strong>把基类指针（引用）转换为派生类指针（引用）(这叫做安全地下行转换，上行是百分百安全的)<strong>。我在《<a href="https://www.jb51.net/article/55881.htm">COM编程——接口的背后</a>》这篇博文中总结的那样，</strong>当类中存在虚函数时，编译器就会在类的成员变量中添加一个指向虚函数表的vptr指针</strong>，每一个class所关联的type_info类型的object也经由virtual table被指出来，通常这个type_info object放在表格的第一个slot。当我们进行dynamic_cast时，编译器会帮我们进行语法检查。如果指针的静态类型和目标类型相同，那么就什么事情都不做；否则，首先对指针进行调整，使得它指向vftable，并将其和调整之后的指针、调整的偏移量、静态类型以及目标类型传递给内部函数。其中最后一个参数指明转换的是指针还是引用。<strong>两者唯一的区别是，如果转换失败，前者（指指针）返回NULL，后者（指引用）抛出bad_cast异常</strong>。</p>
</li>
<li><p>总结起来dynamic_cast的原理就是，<strong>虚表中会存放有一个也就是type_info类型的指针，它代表了该虚表到底是哪个类（基类还是派生）的虚表</strong>，通过name()调用可以获取真实类型，也就是说虚表中存放了该指针指向真正的对象类型（其实也就是运行时类型信息获取），用于dynamic_cast下行转换时的比较。(也就是比如<code>dynamic_cast&lt;C *&gt;</code>，就把<code>C*</code>与那个虚表中真实存放的类型比较一下)。如果一致，那就转化成功了。如果不一致，那就返回nullptr，或者是对于引用就抛出异常</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-简介版回答RTTI"><a href="#5-简介版回答RTTI" class="headerlink" title="5.简介版回答RTTI"></a>5.简介版回答RTTI</h4><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的第一个位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info。</p>
<ul>
<li><p>typeid查询type_info类型是为了人工获得该指针的真正指向类型</p>
</li>
<li><p>dynamic_cast查询type_info类型是是为了编译器获取该指针的真正指向类型（其实也就是运行时类型信息获取），以判断是否能够安全地下行转换。能则转换，不能则返回Nullptr</p>
<ul>
<li><pre><code class="c++">A *pA = new C;
//C *pC = pA; // Wrong
C *pC = dynamic_cast&lt;C *&gt;(pA);
<pre class="line-numbers language-none"><code class="language-none">
  - **pA是一个基类指针，dynamic_cast的具体操作是，查询pA地址里指向的对象（看代码可以看到其实是个派生类C对象），对象里存着一个虚指针，虚指针指向了派生类C对应的虚表，虚表首项是type_info指针，然后通过该type_info获得真实.name()是C。&#96;dynamic_cast&lt;C *&gt;&#96;欲转化的是&#96;C*&#96;类型，所以可以安全地向下转化。（从基类指针转化成派生类指针）**

### 22.函数调用（栈、栈帧）

**栈**就是CPU寄存器里的**某个指针所指向的一片内存区域**。这里所说的“某个指针”通常位于x86&#x2F;x64平台的&#96;ESP寄存器&#96;

操作栈的最常见的指令时&#96;PUSH&#96;（压栈）和&#96;POP&#96;（弹栈）。&#96;PUSH&#96;指令会对&#96;ESP&#96;**寄存器的值**进行减法运算，使之**减去4（32位）或8（64位）（这是因为栈的生长方向从高地址到低地址）**，然后将操作数**写到**ESP寄存器里的指针所指向的**内存中**。

#### 1.栈在进程中的作用如下：

1. 暂时保存函数内的局部变量。
2. 调用函数时传递参数。
3. 保存函数返回的地址。

#### 2.栈帧

**栈帧**也叫过程活动记录，是编译器用来实现过程&#x2F;函数调用的一种数据结构。简言之，**栈帧**就是利用&#96;EBP&#96;（**帧指针EBP**，请注意不是ESP，）寄存器访问局部变量、参数、函数返回地址等的手段。

每一次函数的调用，都会在&#96;调用栈&#96;（call stack）上维护一个独立的&#96;栈帧&#96;（stack frame）。每个独立的栈帧一般包括：

- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文

**栈是从高地址向低地址延伸**，一个函数的栈帧用EBP和ESP这两个寄存器来划定范围。

- EBP寄存器又被称为&#96;帧指针&#96;（Frame Pointer），指向**当前栈帧**的底部（高地址）。
- ESP寄存器又被称为&#96;栈指针&#96;（Stack Pointer），**始终指向**栈帧的顶部（低地址）。

![image.png](https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;09&#x2F;17&#x2F;pDEqVHBd8YykiIK.png)

#### 3.函数调用的过程

- 其实在编译过程中，**对局部变量的符号的操作就会被直接编译成对寄存器、栈的操作**，而原有的符号会消失（除非你开启了&#96;-g&#96;编译选项，那么编译器会保存局部变量到符号表用于调试）。
- a 只是个名字，为了让你方便使用，程序编译之后a这个名字是不存在了，变成了一个具体的内存地址，这个内存地址里的值是 15.如果C语言语法允许，你也可以写成这样，直接指定固定的地址。int [0x1000xxxx] &#x3D; 15；

以实例分析：

&#96;&#96;&#96;c++
void swap(int* a,int* b)
&#123;
    int c;
    c&#x3D;*a;
    *a&#x3D;*b;
    *b&#x3D;c;
&#125;
int main()&#123;
    int a,b;
    a&#x3D;16;
   	b&#x3D;32;
    swap(&amp;a,&amp;b);
    return(a-b);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>下面是这个过程对应的栈结构（栈的生长方向是从高地址到低地址）</p>
<p>可以看出，在调用swap函数后，会为更改栈指针esp和帧指针ebp的指向，为swap分配一个栈帧结构。</p>
<p>&amp;b &amp;a是函数参数</p>
<p><img src="https://i.loli.net/2020/09/17/o1nsrRuEd25FWD8.png" alt="image.png"></p>
<p><strong>调用swap函数过程做了什么？</strong></p>
<ul>
<li><strong>1、将函数参数压栈</strong>（&amp;b,&amp;a）<ul>
<li>从右到左传参，即从右到左入栈</li>
</ul>
</li>
<li>2、<strong>将返回地址压栈</strong><ul>
<li>就是调用完swap函数之后，接下来该执行哪个指令或者哪句代码了，即下一句代码（下一条指令）的地址，该地址应该是在代码区</li>
</ul>
</li>
<li>3、<strong>将当前帧指针所指的地址（ebp寄存器的值）压栈</strong><ul>
<li>用于函数调用完了，恢复到之前调用者（比如main函数）的栈帧去</li>
</ul>
</li>
<li>4、<strong>移动帧指针（修改ebp寄存器）与栈指针（修改esp寄存器），为swap函数创建一个栈帧结构</strong><ul>
<li>由于将参数(&amp;b,&amp;a)压入栈中，所以在swap函数要访问**&amp;a<strong>和</strong>&amp;b<strong>时，可以通过</strong>%(ebp+8)<strong>与</strong>%(ebp+12)**访问。 swap函数结束后，会恢复帧指针与栈指针，然后继续运行。</li>
</ul>
</li>
</ul>
<h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h4><p>在所有函数之外进行加减乘除运算、使用 if…else 语句、调用一个函数等都是没有意义的，这些代码位于整个函数调用链条之外，永远都不会被执行到。C语言也禁止出现这种情况，会报语法错误，请看下面的代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
int a &#x3D; 10, b &#x3D; 20, c;

&#x2F;&#x2F;错误：不能出现加减乘除运算
c &#x3D; a + b;

&#x2F;&#x2F;错误：不能出现对其他函数的调用
printf(&quot;c.biancheng.net&quot;);

int main()&#123;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-牛客网的答案"><a href="#5-牛客网的答案" class="headerlink" title="5.牛客网的答案"></a>5.牛客网的答案</h4><ul>
<li>每一个函数调用都会分配函数栈帧，在栈内进行函数执行过程。</li>
<li>调用前，先把返回地址压栈，然后把当前栈帧的ebp指针压栈。</li>
<li>然后移动帧指针（修改ebp寄存器）与栈指针（修改esp寄存器），为函数创建新的栈帧</li>
</ul>
<h3 id="23-C语言函数传参的压栈顺序？"><a href="#23-C语言函数传参的压栈顺序？" class="headerlink" title="23.C语言函数传参的压栈顺序？"></a>23.C语言函数传参的压栈顺序？</h3><p>从右到左</p>
<h3 id="24-左值右值？（具体例子见25-右值引用里的例子）"><a href="#24-左值右值？（具体例子见25-右值引用里的例子）" class="headerlink" title="24.左值右值？（具体例子见25.右值引用里的例子）"></a>24.左值右值？（具体例子见25.右值引用里的例子）</h3><ul>
<li>左值是存储单元内的值，即是有实际存储地址的；</li>
<li>右值则不是存储单元内的值，比如它可能是寄存器内的值也可能是立即数。</li>
<li>左值就是一切有存放位置的值（内存，寄存器）。右值就是一切没有存放位置的值，现在又多出一种xvalue，代表一切有临时存放位置但马上要销毁的值（返回值等）。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/111826434">https://zhuanlan.zhihu.com/p/111826434</a></p>
<p><a href="https://www.cnblogs.com/Philip-Tell-Truth/p/6370019.html">https://www.cnblogs.com/Philip-Tell-Truth/p/6370019.html</a></p>
<h4 id="1-概念-左值是存储单元内的值，即是有实际存储地址的；右值就是一切没有存放位置的值-xvalue，代表一切有临时存放位置但马上要销毁的值（返回值等）"><a href="#1-概念-左值是存储单元内的值，即是有实际存储地址的；右值就是一切没有存放位置的值-xvalue，代表一切有临时存放位置但马上要销毁的值（返回值等）" class="headerlink" title="1.概念(左值是存储单元内的值，即是有实际存储地址的；右值就是一切没有存放位置的值;xvalue，代表一切有临时存放位置但马上要销毁的值（返回值等）)"></a>1.概念(左值是存储单元内的值，即是有实际存储地址的；右值就是一切没有存放位置的值;xvalue，代表一切有临时存放位置但马上要销毁的值（返回值等）)</h4><p>每一个C++表达式(带有运算对象的运算符、字面值[literal]、变量名等)都有两个独立的属性———— 型别[type]和值类型[value categories，就是底下那5种]。</p>
<p>可以通过两个方面来对值类型进行分类：</p>
<ul>
<li><p>1.有”身份”[has identity]：能够确定某个表达式是否和另一个表达式指涉[refers to]同一个实体，例如，通过比较它们标识[identify]出来的函数或者对象的地址(直接或间接得到的)。也可以说叫做具名</p>
</li>
<li><p>2.能被移动[can be moved from]：能够被移动构造函数、移动赋值操作符或者其它实现[implement]移动语义[move semantics]的重载函数绑定[bind to]。</p>
</li>
<li><ol>
<li>有”身份”但是不能”被移动”的表达式被称为左值表达式[lvalue expression];</li>
</ol>
</li>
<li><ol start="2">
<li>有”身份”同时能”被移动”的表达式被称为x值表达式[xvalue expression];</li>
</ol>
</li>
<li><ol start="3">
<li>没有”身份”但是能”被移动”的表达式被称为纯右值表达式[prvalue expression];</li>
</ol>
</li>
<li><ol start="4">
<li>C++没有既没有”身份”也不能”被移动”的表达式；</li>
</ol>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/18/7EsaV4R9WHSuPLU.png" alt="image.png"></p>
<ul>
<li><p>glvalue：泛左值，可能是lvalue或者xvalue</p>
</li>
<li><p>lvalue：传统意义上的左值，（历史上称为左值是因为左值可以出现在赋值表达式的左侧），指一个函数或者对象</p>
<ul>
<li><p>作用域中变量或函数的名称，与类型无关，例如：std::cin，std::endl.</p>
</li>
<li><p>运算符重载并且返回值是引用的方法，例如：std::getline(std::cin, str), std::cout &lt;&lt; 1, str1 &#x3D; str2, or ++it; </p>
</li>
<li><p>内建类型和组合类型是左值，例如：a &#x3D; b, a +&#x3D; b, a %&#x3D; b</p>
</li>
<li><p>前自增或者前自减是左值，可以取地址，即&amp;++a。（因为前置++的返回值是引用，后置++的返回值是非引用）</p>
</li>
<li><p>内建指针类型</p>
</li>
<li><p>C++规定字符串是左值，such as “Hello, world!”;</p>
</li>
<li><p><strong>注意等号左边的值不一定是左值，这个不是绝对的</strong></p>
</li>
<li><p>简单的来说，能取地址的变量一定是左值，有名字的变量也一定是左值，最经典的void fun(p&amp;&amp; shit)，其中shit也是左值，因为右值引用是左值（所以才会有move，forward这些函数的产生，其中move出来一定是右值，forward保持变量形式和之前的不变，就是为了解决右值引用是左值的问题）。至于为什么不能把等号左边看成左值，因为在C++中，等号是可以运算符重载的，等号完全可以重载成为等号左边为右值的形式。</p>
</li>
<li><p><strong>有名字的一定是左值，哪怕你声明他的时候用的是右值引用</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Fuck</span><span class="token punctuation">(</span>Shit<span class="token operator">&amp;&amp;</span> shit<span class="token punctuation">)</span> <span class="token comment">// shit在函数体里面仍然是左值，类型是Shit&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
</li>
<li><p>xvalue：消亡值，通过右值引用产生</p>
<ul>
<li>本质上，消亡值就是通过右值引用产生的值。右值一定会在表达式结束后被销毁，比如return x（x被copy以后会被销毁）, 1+2（3这个中间值会被销毁）。</li>
</ul>
</li>
<li><p>rvalue：传统意义上的右值</p>
</li>
<li><p>prvalue：纯右值</p>
<ul>
<li>字面值常量，除了字符串，都是纯右值，包括空指针，true和false，例如：42, true or nullptr; </li>
<li>返回值是非引用的表达式是纯右值，such as str.substr(1, 2), str1 + str2, or it++; （后置++ –的返回值是非引用）</li>
<li>a + b, a % b, a &amp; b, a &lt;&lt; b，和其他的内置数学运算</li>
<li>a &amp;&amp; b, a || b, ~a，内置逻辑运算</li>
<li>a &lt; b, a &#x3D;&#x3D; b, a &gt;&#x3D; b，内置比较运算</li>
<li>取地址表达式是一个纯右值，因为地址本身是纯右值，&amp;a</li>
<li>this指针也是纯右值，因为this也是一个地址</li>
<li>lambda表达式是纯右值</li>
<li>纯右值是传统右值的一部分，纯右值是表达式产生的中间值，不能取地址。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">i - has identity 具名
m - is movable 可移动
   	
   glvalue  - i          具名    
lvalue   - i &amp; !m     具名、不可移动
  	xvalue   - i &amp; m      具名、可移动
   rvalue   - m          可移动
prvalue  - !i &amp; m     不具名、可移动


int x;
std::move(x);  &#x2F;&#x2F; 把x转为xvalue，具名且可移动。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h4><h5 id="1-lvalue-可被操作（如取地址、赋值）的“实体”，如定义好的变量"><a href="#1-lvalue-可被操作（如取地址、赋值）的“实体”，如定义好的变量" class="headerlink" title="1.lvalue - 可被操作（如取地址、赋值）的“实体”，如定义好的变量"></a>1.lvalue - 可被操作（如取地址、赋值）的“实体”，如定义好的变量</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 666;   &#x2F;&#x2F; ok<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-rvalue-不可被操作（如取地址、赋值）的“值”，如字符常量、临时变量"><a href="#2-rvalue-不可被操作（如取地址、赋值）的“值”，如字符常量、临时变量" class="headerlink" title="2.rvalue - 不可被操作（如取地址、赋值）的“值”，如字符常量、临时变量"></a>2.rvalue - 不可被操作（如取地址、赋值）的“值”，如字符常量、临时变量</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int y;
666 &#x3D; y; &#x2F;&#x2F; error!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="3-函数返回值可以是左值或右值"><a href="#3-函数返回值可以是左值或右值" class="headerlink" title="3.函数返回值可以是左值或右值"></a>3.函数返回值可以是左值或右值</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int setValue()
&#123;
    int a&#x3D;1;
    return a;&#x2F;&#x2F;返回右值
&#125;
setValue() &#x3D; 3; &#x2F;&#x2F; error!

int global &#x3D; 100;
int&amp; setGlobal()
&#123;
    return global;&#x2F;&#x2F;返回左值    
&#125;
setGlobal() &#x3D; 400; &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="4-令lvalue-x3D-rvalue很常见-lvalue-to-rvalue-conversion"><a href="#4-令lvalue-x3D-rvalue很常见-lvalue-to-rvalue-conversion" class="headerlink" title="4. 令lvalue&#x3D; rvalue很常见 [lvalue-to-rvalue conversion]"></a>4. 令lvalue&#x3D; rvalue很常见 [lvalue-to-rvalue conversion]</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 1;		&#x2F;&#x2F;ok
int y &#x3D; 3;		&#x2F;&#x2F;ok
int z &#x3D; x + y;   &#x2F;&#x2F; ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="5-令rvalue-x3D-lvalue不允许-rvalue-to-lvalue-conversion-is-no-allowed"><a href="#5-令rvalue-x3D-lvalue不允许-rvalue-to-lvalue-conversion-is-no-allowed" class="headerlink" title="5.令rvalue&#x3D;lvalue不允许 [rvalue-to-lvalue conversion is no allowed]"></a>5.令rvalue&#x3D;lvalue不允许 [rvalue-to-lvalue conversion is no allowed]</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x&#x3D;1;
int y&#x3D;2;
(x+y)&#x3D;10;&#x2F;&#x2F;error!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="6-lvalue-reference很常见"><a href="#6-lvalue-reference很常见" class="headerlink" title="6. lvalue reference很常见"></a>6. lvalue reference很常见</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 1;
int&amp; refa &#x3D; a;
refa &#x3D; 20; &#x2F;&#x2F; now a is 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="7-rvalue-to-lvalue-reference不允许"><a href="#7-rvalue-to-lvalue-reference不允许" class="headerlink" title="7. rvalue to lvalue reference不允许"></a>7. rvalue to lvalue reference不允许</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f(int&amp; x)&#123; 
return x; &#x2F;&#x2F; x is a reference to lvalue. 
&#125;
int a &#x3D; 10;
f(a);  &#x2F;&#x2F; ok
f(10); &#x2F;&#x2F; error! rvalue convert to lvalue reference is not allowed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="8-rvalue-to-const-lvalue-reference可以用（很常见）"><a href="#8-rvalue-to-const-lvalue-reference可以用（很常见）" class="headerlink" title="8.rvalue to const lvalue reference可以用（很常见）"></a>8.rvalue to const lvalue reference可以用（很常见）</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int f(const int &amp;x) &#123;
return x;
&#125;
int a &#x3D; 10;
f(a);  &#x2F;&#x2F; ok
f(10); &#x2F;&#x2F; ok now. a rvalue-to-const-lvalue-reference has happened.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="9-现在我们有了一个图。越往上可修改性越弱。下一级可以转为上一级。"><a href="#9-现在我们有了一个图。越往上可修改性越弱。下一级可以转为上一级。" class="headerlink" title="9.现在我们有了一个图。越往上可修改性越弱。下一级可以转为上一级。"></a>9.现在我们有了一个图。越往上可修改性越弱。下一级可以转为上一级。</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">不可修改    const-lvalue-reference &lt;------ rvalue
             ↑
可修改      lvalue &lt;--- lvalue-reference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="10-C-OX后，引入rvalue-reference-右值引用-使得上图发生变化、右下角的空白被补全了。下面这段代码背后，临时变量所在的内存单元被固化下来了，可供程序后续使用。"><a href="#10-C-OX后，引入rvalue-reference-右值引用-使得上图发生变化、右下角的空白被补全了。下面这段代码背后，临时变量所在的内存单元被固化下来了，可供程序后续使用。" class="headerlink" title="10.C++OX后，引入rvalue-reference(右值引用)使得上图发生变化、右下角的空白被补全了。下面这段代码背后，临时变量所在的内存单元被固化下来了，可供程序后续使用。"></a>10.C++OX后，引入rvalue-reference(右值引用)使得上图发生变化、右下角的空白被补全了。下面这段代码背后，临时变量所在的内存单元被固化下来了，可供程序后续使用。</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SomeType&amp;&amp;  rref &#x3D; 10;  &#x2F;&#x2F; make temporary variable can be used.
rref &#x3D; 12; &#x2F;&#x2F; ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">不可修改    const-lvalue-reference &lt;-------------- rvalue
              ↑                                     ↓
可修改      lvalue &lt;--- lvalue-reference           rvalue-reference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="11-lvalue-—-gt-rvalue-现在左值也可以转为右值了，便是通过std-move"><a href="#11-lvalue-—-gt-rvalue-现在左值也可以转为右值了，便是通过std-move" class="headerlink" title="11. lvalue —&gt; rvalue 现在左值也可以转为右值了，便是通过std::move."></a>11. lvalue —&gt; rvalue 现在左值也可以转为右值了，便是通过<code>std::move</code>.</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i;
std::move(i),int;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="3-简单判别方法"><a href="#3-简单判别方法" class="headerlink" title="3.简单判别方法"></a>3.简单判别方法</h4><h5 id="1-方法1（能取地址一定是左值，但是有的左值不可以取地址）"><a href="#1-方法1（能取地址一定是左值，但是有的左值不可以取地址）" class="headerlink" title="1.方法1（能取地址一定是左值，但是有的左值不可以取地址）"></a>1.方法1（能取地址一定是左值，但是有的左值不可以取地址）</h5><p>C++11开始，表达式一般分为三类：左值（lvalue）、消亡值（xvalue）、纯右值（prvalue），其中左值和消亡值统称泛左值（glvalue），消亡值和纯右值统称右值（rvalue）。</p>
<p>判断表达式是否是左值，有一个简单的办法，就是<strong>看看能否取它的地址</strong>，能取地址的就是左值。(除了类内初始化的static const member是左值，但是不可取地址 )。能取地址一定是左值，但是有的左值不可以取地址，充分不必要。</p>
<ul>
<li>左值可看作是<strong>“对象”</strong>，右值可看作是<strong>“值”</strong> (Lvalues represent objects and rvalues represent values)</li>
<li>左值到右值的转换可看做<strong>“读出对象的值”</strong> (Lvalue-to-rvalue conversion represents reading the value of an object)</li>
<li>std::move 允许把任何表达式以“值”的方式处理 (allows you to treat any expression as though it represents a value)<ul>
<li>std::move（）实现移动语义，将传入参数全部无条件转换为右值引用。它其实就是一个static_cast，具体是否移动了对象，要看是否发生了移动构造或者移动赋值</li>
</ul>
</li>
<li>std::forward 允许在处理的同时，保留表达式为“对象”还是“值”的特性 (allows you to preserve whether an expression represented an object or a value)<ul>
<li>std::forward() 实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。</li>
</ul>
</li>
</ul>
<p>那么这里的“对象” (object) 和 “值” (value) 是什么意思呢？任何一个有价值的 C++ 程序都是如此：a) 反复地操作各种类型的对象 b) 这些对象在运行时创建在明确的内存范围内 c) 这些对象内存储着值。 (Every useful C++ program revolves around the manipulation of objects, which are regions of memory created at runtime in which we store values.)</p>
<p>这一句话的解释实际上就指向了上面的第一条方法——只有特定的内存区域才可以被取地址。</p>
<p>作者：顾露<br>链接：<a href="https://www.zhihu.com/question/39846131/answer/85277628">https://www.zhihu.com/question/39846131/answer/85277628</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h5 id="2-方法2（有名字的一定是左值，哪怕你声明他的时候用的是右值引用；所有临时变量都是右值，譬如说表达式里面的函数返回值）"><a href="#2-方法2（有名字的一定是左值，哪怕你声明他的时候用的是右值引用；所有临时变量都是右值，譬如说表达式里面的函数返回值）" class="headerlink" title="2.方法2（有名字的一定是左值，哪怕你声明他的时候用的是右值引用；所有临时变量都是右值，譬如说表达式里面的函数返回值）"></a>2.方法2（有名字的一定是左值，哪怕你声明他的时候用的是右值引用；所有临时变量都是右值，譬如说表达式里面的函数返回值）</h5><p>有名字的一定是左值，哪怕你声明他的时候用的是右值引用</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Fuck</span><span class="token punctuation">(</span>Shit<span class="token operator">&amp;&amp;</span> shit<span class="token punctuation">)</span> <span class="token comment">// shit在函数体里面仍然是左值，类型是Shit&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>左值引用的右值引用，或者右值引用的左值引用，都是左值引用。这一条是专门为了模板元编程发明的。</p>
<p>所有临时变量都是右值，譬如说表达式里面的函数返回值。</p>
<p>左值引用不能传递到需要右值引用的地方。除非你强行使用<code>std::move&lt;T&gt;(x)</code>，不过你看一下代码就知道其实里面就一个强制类型转换。注意move和forward的区别。move永远把东西变成右值，而forward则保持不变——这是为了解决“shit在函数体里面仍然是左值”的问题。</p>
<p>右值引用和返回值优化经常被很多人混在一起，而且最要命的是如果开了优化的话，其实多半输出的代码是一样的。</p>
<p>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/39846131/answer/83386143">https://www.zhihu.com/question/39846131/answer/83386143</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="4-std-move-和std-forward"><a href="#4-std-move-和std-forward" class="headerlink" title="4.std::move()和std::forward()"></a>4.std::move()和std::forward()</h4><h4 id="强调一下，为啥有时候你move完了，发现对象还有，并没有移动。因为move只是一个强制类型转换，真正实现移动的是移动构造函数和移动赋值函数。你要具体再想想移动构造函数到底有没有实现，或者说移动构造函数里做了什么。"><a href="#强调一下，为啥有时候你move完了，发现对象还有，并没有移动。因为move只是一个强制类型转换，真正实现移动的是移动构造函数和移动赋值函数。你要具体再想想移动构造函数到底有没有实现，或者说移动构造函数里做了什么。" class="headerlink" title="(强调一下，为啥有时候你move完了，发现对象还有，并没有移动。因为move只是一个强制类型转换，真正实现移动的是移动构造函数和移动赋值函数。你要具体再想想移动构造函数到底有没有实现，或者说移动构造函数里做了什么。)"></a>(强调一下，为啥有时候你move完了，发现对象还有，并没有移动。因为move只是一个强制类型转换，真正实现移动的是移动构造函数和移动赋值函数。你要具体再想想移动构造函数到底有没有实现，或者说移动构造函数里做了什么。)</h4><p>std::move() 与 std::forward()本质上就是一个转换函数，在<strong>编译期</strong>对传入参数进行类型转换</p>
<ul>
<li>std::move() 实现移动语义，将传入参数全部无条件转换为右值引用</li>
<li>std::forward() 实现完美转发，传入左值即返回左值引用，传入右值即返回右值引用</li>
</ul>
<p>当参数都为右值时，二者等价。</p>
<p><a href="https://blog.csdn.net/qq_29983883/article/details/107238389">https://blog.csdn.net/qq_29983883/article/details/107238389</a></p>
<h5 id="1-std-move-实现移动语义，将传入参数全部无条件转换为右值引用"><a href="#1-std-move-实现移动语义，将传入参数全部无条件转换为右值引用" class="headerlink" title="1.std::move()实现移动语义，将传入参数全部无条件转换为右值引用"></a>1.std::move()实现移动语义，将传入参数全部无条件转换为右值引用</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;std::move()的作用实例    
void func(int &amp;&amp;args) &#123;&#x2F;&#x2F;右值引用

      std::cout &lt;&lt; args &lt;&lt; std::endl;

  &#125;

  int a &#x3D; 10;

  func(20);    &#x2F;&#x2F; ok

  func(a);      &#x2F;&#x2F; error, 右值引用不能绑定左值

  func(std::move(a));    &#x2F;&#x2F; ok
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;std::move()的作用实例 
void func(string&amp;&amp; arg) &#123;
    cout &lt;&lt; arg &lt;&lt; endl;
&#125;
int main() &#123;

    string str &#x3D; &quot;asdf&quot;;
    func(move(str));
    cout &lt;&lt; str &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F;asdf
&#x2F;&#x2F;asdf
&#x2F;&#x2F;没有发生移动构造，所以str的内容还保留了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;std::move()的作用实例 
void func(string arg) &#123;
    cout &lt;&lt; arg &lt;&lt; endl;
&#125;
int main() &#123;

    string str &#x3D; &quot;asdf&quot;;
    func(move(str));
    cout &lt;&lt; str &lt;&lt; endl;
    return 0;
&#125;
&#x2F;&#x2F;asdf
&#x2F;&#x2F;
&#x2F;&#x2F;发生移动构造，所以str的内容被转移走了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;std::move()的源码剖析
&#x2F;&#x2F; FUNCTION TEMPLATE move
template &lt;class _Ty&gt;
_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept &#123; &#x2F;&#x2F; forward _Arg as movable
    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);
&#125;

&#x2F;&#x2F;std::move() 只是一个转换函数，并没有move任何东西，只是在编译期将传入参数转换为右值引用，在运行期不执行任何操作。
&#x2F;&#x2F;remove_reference_t&lt;_Ty&gt; 会将传入类型 _Ty 中引用属性去除，然后利用 static_cast() 将 _Ty 转换为右值引用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>为什么可以无论什么情况，move函数都可以转化成右值引用？因为引用折叠的规则。</strong></p>
<p>首先，函数参数_Ty&amp;&amp;是一个指向模板类型参数的右值引用（<strong>这其实叫universal reference，不是右值引用</strong>），通过引用折叠，此参数可以与任何类型的实参匹配（可以传递左值或右值，这是std::move主要使用的两种场景)。关于引用折叠如下：</p>
<ul>
<li><p>X&amp; &amp; &#x3D;&#x3D;X &amp; &amp;&amp; &#x3D;&#x3D; X&amp;&amp; &amp; &#x3D;&#x3D; X&amp;，用于处理左值</p>
<ul>
<li><pre><code class="c++">template&lt;typename T&gt; void f(T&amp;&amp;);
int i;
f(i);
//这样编译器推断T为int &amp;类型
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  string s(&quot;hello&quot;);
  std::move(s) 编译器推断&#x3D;&gt;形参T为string&amp; ，所以std::move(string&amp; &amp;&amp;) &#x3D;&gt; 折叠后 std::move(string&amp; )
  此时：T的类型为string&amp;
  typename remove_reference&lt;T&gt;::type为string 
  整个std::move被实例化如下
  string&amp;&amp; move(string&amp; t) &#x2F;&#x2F;t为左值，移动后不能在使用t
  &#123;
      &#x2F;&#x2F;通过static_cast将string&amp;强制转换为string&amp;&amp;
      return static_cast&lt;string&amp;&amp;&gt;(t); 
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>X&amp;&amp; &amp;&amp; &#x3D;&#x3D; X&amp;&amp;，用于处理右值</p>
<ul>
<li><pre><code class="c++">std::move(string(&quot;hello&quot;)) 编译器推断=&gt;T是string&amp;&amp;类型， std::move(string&amp;&amp;)
//此时：T的类型为string 
//     remove_reference&lt;T&gt;::type为string 
//整个std::move被实例如下
string&amp;&amp; move(string&amp;&amp; t) //t为右值
&#123;
    return static_cast&lt;string&amp;&amp;&gt;(t);  //返回一个右值引用
&#125;
<pre class="line-numbers language-none"><code class="language-none">
有了这两个引用折叠的规则，move就可以接受任何类型的实参，从而获得一个右值引用。

**注意：**

- std::move只是将参数转换为右值引用而已,它从来不会移动什么.真正的移动操作是在移动构造函数或者移动赋值操作符中发生的:

  - 

  &#96;&#96;&#96;c++
  T (T&amp;&amp; rhs);
  T&amp; operator&#x3D; (T&amp;&amp; rhs);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>std::move的作用只是为了让调用构造函数的时候告诉编译器去选择移动构造函数.</p>
<p>- </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;

    string str &#x3D; &quot;asdf&quot;;
    string&amp; lr &#x3D; str;&#x2F;&#x2F;左值引用，它跟str是一码事，两个名字而已
    string&amp;&amp; rr &#x3D; std::move(str);&#x2F;&#x2F;rr是右值引用，但它其实还是个左值，因为它有名字。与普通的左值引用lr没差别

    rr[0] &#x3D; &#39;b&#39;;
    lr[1] &#x3D; &#39;z&#39;;
    cout &lt;&lt; rr &lt;&lt; &#39;\t&#39; &lt;&lt; lr &lt;&lt; &#39;\t&#39; &lt;&lt; str &lt;&lt; endl;
    cout &lt;&lt; &amp;str &lt;&lt; &#39;\t&#39; &lt;&lt; &amp;lr &lt;&lt; &#39;\t&#39; &lt;&lt; &amp;rr &lt;&lt; endl;

    return 0;
&#125;
&#x2F;&#x2F;bzdf    bzdf    bzdf
&#x2F;&#x2F;0103FE20        0103FE20        0103FE20
&#x2F;&#x2F;可以看出，str、lr、rr三个东西地址都完全一样，就是一个东西<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><pre><code class="c++">int main() &#123;

    string str = &quot;asdf&quot;;
    string&amp; lr = str;//左值引用，它跟str是一码事，两个名字而已
    string rr = std::move(str);//move(str)的返回值是一个string&amp;&amp;，所以将调用string类的移动构造函数去构造rr，那么str和lr的对象就被移动走了，str和lr变为了空。rr是一个全新的对象。

    //rr[0] = &#39;b&#39;;
    //lr[1] = &#39;z&#39;;
    cout &lt;&lt; str &lt;&lt; &#39;\t&#39; &lt;&lt; lr &lt;&lt; &#39;\t&#39; &lt;&lt; rr &lt;&lt; endl;
    cout &lt;&lt; &amp;str &lt;&lt; &#39;\t&#39; &lt;&lt; &amp;lr &lt;&lt; &#39;\t&#39; &lt;&lt; &amp;rr &lt;&lt; endl;

    return 0;
&#125;
//                asdf                        可以看到，str和lr没有输出，因为内容被移动构造给rr了
//00CFFE2C        00CFFE2C        00CFFDFC    rr跟他们两个的地址不同
<pre class="line-numbers language-none"><code class="language-none">
**总结：**

- move()的作用，就是一个static&lt;&gt;强制转换成右值引用！
- 它可以把所有类型（不管你原来是个左值、右值）都转换成右值引用的原理是，由于引用折叠规则！
- move()函数调用完，内容是否保留了，这要取决于是否发生了移动构造！
- move本身只是将参数转换为右值引用而已,它从来不会移动什么。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的。

##### 2.std::forward()实现了完美转发

std::forward() 实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。

&#96;&#96;&#96;c++
    void func(int &amp;arg) &#123;&#x2F;&#x2F;左值引用
       std::cout &lt;&lt; &quot;func lvalue&quot; &lt;&lt; std::endl;
   &#125;

   void func(int &amp;&amp;arg) &#123;&#x2F;&#x2F;右值引用
       std::cout &lt;&lt; &quot;func rvalue&quot; &lt;&lt; std::endl;
   &#125;

   template &lt;typename T&gt;
   void wrapper(T &amp;&amp;args) &#123;&#x2F;&#x2F;universal reference，需要参照引用叠加规则
       func(args);
   &#125;

   int main() &#123;
       int a &#x3D; 10; 

       wrapper(a);&#x2F;&#x2F;a是int型，void wrapper(T &amp;&amp;args)将自动推断T为int&amp; 所以args是int&amp; &amp;&amp;&#x3D;int&amp;
       wrapper(20);&#x2F;&#x2F;20是一个右值，void wrapper(T &amp;&amp;args)将自动推断T为int，所以args是int&amp;&amp;，是右值调用。但是在wrapper()函数内部，无论如何，args都是一个左值，在调用func()函数的时候，调用的func()原型总是func(int &amp;)。

       return 0;
   &#125;
&#x2F;&#x2F;通过引用叠加，分析以上示例可知，调用wrapper()时，wrapper(a) 是调用的原型是 wrapper(int &amp;)，是左值调用；wrapper(20)调用的原型是wrapper(int &amp;&amp;)，是右值调用。但是在wrapper()函数内部，无论如何，args都是一个左值，在调用func()函数的时候，调用的func()原型总是func(int &amp;)。
&#x2F;&#x2F;func lvalue
&#x2F;&#x2F;func lvalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>因此，根本原因其实是，右值引用属性不能被转发。所以，C++11提供了std::forward()函数用于完美转发。即，在转发过程中，左值引用在被转发之后仍然保持左值属性，右值引用在被转发之后依然保持右值属性。修改之后的代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> void func(int &amp;arg) &#123;
        std::cout &lt;&lt; &quot;func lvalue&quot; &lt;&lt; std::endl;
    &#125;

    void func(int &amp;&amp;arg) &#123;
        std::cout &lt;&lt; &quot;func rvalue&quot; &lt;&lt; std::endl;
    &#125;

    template &lt;typename T&gt;
    void wrapper(T &amp;&amp;args) &#123;
        func(std::forward&lt;T&gt;(args));&#x2F;&#x2F;forward&lt;T&gt;(args)用于保留args的左右值属性，要不然args一定永远是左值
    &#125;

    int main() &#123;
        int a &#x3D; 10; 

        wrapper(a);
        wrapper(20);

        return 0;
    &#125;
&#x2F;&#x2F;通过引用叠加，分析以上示例可知，调用wrapper()时，wrapper(a) 是调用的原型是 wrapper(int &amp;)，是左值调用；wrapper(20)调用的原型是wrapper(int &amp;&amp;)，是右值调用。现在在wrapper()函数内部，args保留了原有的左右值属性，在调用func()函数的时候,wrapper(20)时，std::forward&lt;T&gt;(args)结果是一个int类型的右值。
&#x2F;&#x2F;    func lvalue
&#x2F;&#x2F;    func rvalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="5-一定要注意，带模板的-T-amp-amp-是universal-reference，它有引用叠加规则。（不可以有const-volatile限定符）"><a href="#5-一定要注意，带模板的-T-amp-amp-是universal-reference，它有引用叠加规则。（不可以有const-volatile限定符）" class="headerlink" title="5.一定要注意，带模板的 T&amp;&amp;是universal reference，它有引用叠加规则。（不可以有const-volatile限定符）"></a>5.一定要注意，带模板的 T&amp;&amp;是universal reference，它有引用叠加规则。（不可以有const-volatile限定符）</h4><ul>
<li>X&amp; &amp; &#x3D;&#x3D;X &amp; &amp;&amp; &#x3D;&#x3D; X&amp;&amp; &amp; &#x3D;&#x3D; X&amp;，用于处理左值</li>
<li>X&amp;&amp; &amp;&amp; &#x3D;&#x3D; X&amp;&amp;，用于处理右值</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
void f(T&amp;&amp; para) &#123;
	&#x2F;&#x2F; do something;
&#125;
int x;
int &amp;&amp;a &#x3D; 10; &#x2F;&#x2F;a的类型是int&amp;&amp;，右值引用，但a是一个左值。(int&amp;&amp;a&#x3D;10，与int a&#x3D;10，好像差别不大，因为这样写了以后a都是左值)
int &amp;b  &#x3D; x;  &#x2F;&#x2F;b的类型是int&amp;，左值引用 
f(10); &#x2F;&#x2F; 10是右值，para的类型是右值引用，T是10的原生类型也就是int,函数f会实例化为 f(int&amp;&amp; para)
&#x2F;&#x2F;你也可以理解为，T被推断为int&amp;&amp;，所以f(int&amp;&amp; &amp;&amp;para)&#x3D;f(int&amp;&amp; para)。其实应该是上边那种理解
f(x);  &#x2F;&#x2F; x是左值，para的类型是左值引用，T是左值引用，即T被编译器推断为int&amp;，函数f会实例化为 f(int&amp; &amp;&amp; para)&#x3D;f(int&amp; para)
f(a);  &#x2F;&#x2F; a是右值引用，本身是左值，T是左值引用，即T被编译器推断为int&amp;，函数f会实例化为 f(int&amp; &amp;&amp; para)&#x3D;f(int&amp; para)
f(b);  &#x2F;&#x2F; b是左值引用，本身是左值，T是左值引用，即T被编译器推断为int&amp;，函数f会实例化为 f(int&amp; &amp;&amp; para)&#x3D;f(int&amp; para)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>结论就是，void f(T&amp;&amp; para) 可以接受所有类型参数？</p>
<ul>
<li>当universal reference被lvalue初始化时，universal reference最终是左值引用.</li>
<li>当universal reference被rvalue初始化时，universal reference最终是右值引用.</li>
</ul>
<h3 id="25-左值引用、const引用、右值引用"><a href="#25-左值引用、const引用、右值引用" class="headerlink" title="25.左值引用、const引用、右值引用"></a>25.左值引用、const引用、右值引用</h3><p>具体地，配合修饰符（const 和 volatile），C++ 中最常用的 3 种组合是：<code>&amp;</code>（左值引用）, <code>const&amp;</code>（const 引用） 和 <code>&amp;&amp;</code>（右值引用）。为什么要把引用和修饰符放在一起讨论呢？这是因为他们都属于编译时的上下文信息。除此之外合法的组合还有 5 种，分别是 <code>const&amp;&amp;</code>, <code>volatile&amp;</code>, <code>volatile&amp;&amp;</code>, <code>const volatile&amp;</code> 以及 <code>const volatile&amp;&amp;</code>，这些组合基本没有应用价值，这里不再赘述。下面我们简单讨论一下 <code>&amp;</code>, <code>const&amp;</code> 和 <code>&amp;&amp;</code> 的使用场景。</p>
<p><img src="https://i.loli.net/2020/09/20/sVLYIwulOJZeHcj.png" alt="image.png"></p>
<h4 id="1-左值引用-用做函数的参数也不是不行，不推荐而已；用于函数内部返回的堆对象的引用"><a href="#1-左值引用-用做函数的参数也不是不行，不推荐而已；用于函数内部返回的堆对象的引用" class="headerlink" title="1.左值引用(用做函数的参数也不是不行，不推荐而已；用于函数内部返回的堆对象的引用)"></a>1.左值引用(用做函数的参数也不是不行，不推荐而已；用于函数内部返回的堆对象的引用)</h4><p><strong>左值引用不推荐用于函数参数</strong>，是因为左值引用与普通的拷贝传值，在函数调用上区分不开，容易写错</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool do_something(int arg0, double arg1, result_t&amp; result);

int arg0 &#x3D; 1;
double arg1 &#x3D; 2.34;
result_t my_result;
bool ok &#x3D; do_something(1, 2.34, my_result);
&#x2F;&#x2F;这里三个参数传参方式一模一样，但对于前两个参数 do_something 使用的是一个拷贝，不会修改调用方 arg0 和 arg1 的值，但第三个参数确实很有可能要修改的，这样就可能产生歧义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>左值引用经常用于函数返回值</strong>，比如返回在函数内部堆上分配的对象的引用（返回栈上的引用是大错特错的）</p>
<h4 id="2-const引用（一般用做函数的参数，即变量只读）"><a href="#2-const引用（一般用做函数的参数，即变量只读）" class="headerlink" title="2.const引用（一般用做函数的参数，即变量只读）"></a>2.const引用（一般用做函数的参数，即变量只读）</h4><p>与 <code>&amp;</code> 相反，<code>const&amp;</code> 作为函数形参是很常见的，因为其具有“只读”语义，<strong>也就是说其实参类型甚至可以是一个纯右值</strong>，这一点是指针做不到的。由于其无副作用且对于用户来说使用成本最低，很多<strong>非</strong>模板库都使用 <code>const&amp;</code> 传递上下文只读参数。</p>
<ul>
<li><pre><code class="c++">void func( int&amp; temp) &#123;
    cout &lt;&lt; temp &lt;&lt; endl;
&#125;
int main() &#123;

    int a = 10;
    int&amp;&amp; b=20;//b也是个左值，与int b=20无差
    func(a);
    func(b);
    func(100);//错误！这就像int&amp; c=1000;错误一样，非常量引用的初始值必须是左值。或者说右值无法转换成左值引用
    
    return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  void func(const int&amp; temp) &#123;
      cout &lt;&lt; temp &lt;&lt; endl;
  &#125;
  int main() &#123;
  
      int a &#x3D; 10;
      int&amp;&amp; b&#x3D;20;&#x2F;&#x2F;b也是个左值，与int b&#x3D;20无差
      func(a);
      func(b);
      func(100);&#x2F;&#x2F;正确！
      
      return 0;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
<h4 id="3-右值引用（一般只用作移动构造或者移动赋值函数的参数，以及“中间层”的函数模板参数。）"><a href="#3-右值引用（一般只用作移动构造或者移动赋值函数的参数，以及“中间层”的函数模板参数。）" class="headerlink" title="3.右值引用（一般只用作移动构造或者移动赋值函数的参数，以及“中间层”的函数模板参数。）"></a>3.右值引用（一般只用作移动构造或者移动赋值函数的参数，以及“中间层”的函数模板参数。）</h4><ul>
<li><p>右值引用一般只用作移动构造或者动赋值函数的参数，以及“中间层”的函数模板参数</p>
<ul>
<li>中间层就是说，善用 <code>std::forward()</code> ，保留传入参数其值属性，然后完美转发</li>
</ul>
</li>
<li><p>右值引用一般不作为任何函数的返回值（当然<code>std::move()</code>, <code>std::forward()</code> 等特殊函数除外，move()一定是把右值引用作为返回值，forward看情况，左值引用在被转发之后仍然保持左值属性，右值引用在被转发之后依然保持右值属性，也就是返回值可能是右值引用也可能是左值引用）</p>
</li>
<li><p>在什么情况下我们“真的需要右值引用”呢？</p>
<ul>
<li><p>最常见的就是用做移动构造函数和移动赋值函数中的函数参数</p>
<ul>
<li>比如一个 <code>std::vector</code> 对象生命周期即将结束，但我们希望保存其中的所有元素到一个新的 <code>std::vector</code> 对象，相比起“拷贝数组中所有元素”我们不如直接把原来 <code>std::vector</code> 对象中保存的数组指针“偷”到新的对象中去，这样我们就免去了复制整个数组的“代价”。有些情况下“没有拷贝选项”的设计是考虑到资源所有权的问题，例如一个经典设计 <code>std::unique_ptr</code>，它不支持拷贝是为了保证一个堆对象指针的所有者只能有一个，以避免程序员使用指针时的经典车祸现场。</li>
</ul>
</li>
<li><p>另一种右值引用的用法就是用做中间层的函数模板参数，善用 <code>std::forward()</code> 即可</p>
<p>- </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> void func(int &amp;arg) &#123;
        std::cout &lt;&lt; &quot;func lvalue&quot; &lt;&lt; std::endl;
    &#125;

    void func(int &amp;&amp;arg) &#123;
        std::cout &lt;&lt; &quot;func rvalue&quot; &lt;&lt; std::endl;
    &#125;

    template &lt;typename T&gt;
    void wrapper(T &amp;&amp;args) &#123;&#x2F;&#x2F;作为中间层的函数模板参数
        func(std::forward&lt;T&gt;(args));&#x2F;&#x2F;forward&lt;T&gt;(args)用于保留args的左右值属性，要不然args一定永远是左值
    &#125;

    int main() &#123;
        int a &#x3D; 10; 

        wrapper(a);
        wrapper(20);

        return 0;
    &#125;
&#x2F;&#x2F;    func lvalue
&#x2F;&#x2F;    func rvalue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h4 id="4-关于右值引用的几个实例思考（深刻理解右值引用。右值是右值，而右值引用一般是左值）"><a href="#4-关于右值引用的几个实例思考（深刻理解右值引用。右值是右值，而右值引用一般是左值）" class="headerlink" title="4.关于右值引用的几个实例思考（深刻理解右值引用。右值是右值，而右值引用一般是左值）"></a>4.关于右值引用的几个实例思考（深刻理解右值引用。右值是右值，而右值引用一般是左值）</h4><p>强调一下，为啥有时候你move完了，发现对象还有，并没有移动。因为move只是一个强制类型转换，真正实现移动的是移动构造函数和移动赋值函数。你要具体再想想移动构造函数到底有没有实现，或者说移动构造函数里做了什么。</p>
<ul>
<li>move完发生了什么，那要看移动构造到底发生了什么，还是人为定义的。</li>
<li>对于string类、vector类等等的，它肯定都写好了移动构造函数的</li>
<li>你自己写的移动构造函数，没有做出正确的处理（比如你发现移动完了，并没有真的发生移动），那是你的事情，你的移动构造函数实现里根本就没这个功能</li>
</ul>
<p><strong>例子1：这个例子不太需要关注，这是没有移动构造的时候。移动构造函数被explicit了(或者没有实现移动构造函数时，会由复制构造函数接替它本该出现的地方)</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X
&#123;
public:
	X(int i &#x3D; 0) :temp(i)&#123; std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl; &#125;
	X(const X&amp; x) &#123; std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; &#125;
	explicit X(X&amp;&amp; x) &#123; std:: cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125;&#x2F;&#x2F;被explict，跟没实现移动构造几乎没区别
	X&amp; operator&#x3D;(const X&amp;) &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
	~X() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
	void show()&#123;cout&lt;&lt;temp&lt;&lt;endl;&#125;
	int temp;
&#125;;

int main()
&#123;
	X test(10);&#x2F;&#x2F;construct
	X test2&#x3D;move(test);&#x2F;&#x2F;copy复制，因为移动构造函数被禁止隐式转换了，理论上它一般是接受隐式转换的。右值引用被转成了const左值引用
	X test3 &#x3D; test2;&#x2F;&#x2F;copy复制
	X &amp;&amp;test4&#x3D;move(test);&#x2F;&#x2F;相当于此时test4是test的一个普通左值引用，test4并没有构造
	cout&lt;&lt;&amp;test&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc84
	cout&lt;&lt;&amp;test2&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc88
	cout&lt;&lt;&amp;test3&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc8c
	cout&lt;&lt;&amp;test4&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc84
	cout &lt;&lt; &quot;123&quot; &lt;&lt; endl;
	test.show();&#x2F;&#x2F;10
	test4.show();&#x2F;&#x2F;10
	return 0;
    &#x2F;&#x2F;test析构
	&#x2F;&#x2F;test2析构
	&#x2F;&#x2F;test3析构
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例子2：移动构造函数没有explicit时（也可以说是实现了移动构造时），与底下例子3联系着看，对于内置类型来说是一码事</strong></p>
<p>看起来用了移动构造，但因为你的类里移动构造啥也没做，所以就算有移动语义，也没真的移动</p>
<p>你像string类这种，它肯定内部真的实现了移动构造函数的，封装好了</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X
&#123;
public:
	X()&#123;&#125;
	X(int i) :temp(i)&#123; std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl; &#125;
	X(const X&amp; x) &#123; std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; &#125;
	X(X&amp;&amp; x) &#123; std:: cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125;
	X&amp; operator&#x3D;(const X&amp;) &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
	~X() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
	void show()&#123;cout&lt;&lt;temp&lt;&lt;endl;&#125;
	int temp;
&#125;;

int main()
&#123;
	X test(10);&#x2F;&#x2F;construct
	X test2&#x3D;move(test);&#x2F;&#x2F;隐式转换，move construct（如果没有移动构造，那将使用复制构造），但是你会发现，上边的移动构造，其实是空的，什么也没做，也就是说没有实现移动语义
	X test3 &#x3D; test2;&#x2F;&#x2F;隐式转换，copy复制
	X &amp;&amp;test4&#x3D;move(test);&#x2F;&#x2F;没有调用到移动构造函数，相当于此时test4是test的一个普通左值引用，test4并没有构造
	X &amp;&amp;test5&#x3D;100;&#x2F;&#x2F;construct，与X test5&#x3D;100无异
    const X&amp; test6 &#x3D; move(test);&#x2F;&#x2F;没有调用到任何构造函数，相当于此时test6是test的一个普通cosnt左值引用,test6没有构造
    
	cout&lt;&lt;&amp;test&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc78
	cout&lt;&lt;&amp;test2&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc7c
	cout&lt;&lt;&amp;test3&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc80
	cout&lt;&lt;&amp;test4&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc78，与test是一码事
	cout&lt;&lt;&amp;test5&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc84
    cout&lt;&lt;&amp;test6&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc78，与test是一码事，只是你不能通过test6来修改test对象里的任何内容
	cout &lt;&lt; &quot;123&quot; &lt;&lt; endl;
	test.show();&#x2F;&#x2F;10
	test2.show();&#x2F;&#x2F;-858993460
	test4.show();&#x2F;&#x2F;10
	test5.show();&#x2F;&#x2F;100
    cout&lt;&lt;test6.show();&#x2F;&#x2F;10
	return 0;
	&#x2F;&#x2F;test析构
	&#x2F;&#x2F;test2析构
    &#x2F;&#x2F;test3析构
    &#x2F;&#x2F;test5析构
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>例子3：对于内置类型</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main()
&#123;
	int a&#x3D;1;&#x2F;&#x2F;构造，左值
	&#x2F;&#x2F;int &amp;&amp;b&#x3D;a; error，                    												   右值引用无法绑定到左值
	int b&#x3D;move(a);&#x2F;&#x2F;理论应该隐式调用移动构造函数，没有的话调用复制构造函数。  与int b&#x3D;a无异。           b是左值，用a复制构造（或者叫初始化）
	int c&#x3D;a;&#x2F;&#x2F;典型的复制构造                                                                  c是左值，用a复制构造（或者叫初始化）
	int &amp;&amp;d&#x3D;move(a);&#x2F;&#x2F;没有调用到移动构造函数，							与int &amp;d &#x3D;a; 无异。      d就是a的左值引用，d跟a是一码事，d没有构造
	int &amp;&amp;e&#x3D;100;&#x2F;&#x2F;构造，											与int e&#x3D;100无异，          e就是个普通左值
	cout&lt;&lt;a&lt;&lt;endl;&#x2F;&#x2F;1
	cout&lt;&lt;b&lt;&lt;endl;&#x2F;&#x2F;1
	cout&lt;&lt;c&lt;&lt;endl;&#x2F;&#x2F;1
    cout&lt;&lt;d&lt;&lt;endl;&#x2F;&#x2F;1
	cout&lt;&lt;e&lt;&lt;endl;&#x2F;&#x2F;100
    cout&lt;&lt;f&lt;&lt;endl;&#x2F;&#x2F;1
    
	cout&lt;&lt;&amp;a&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc88
	cout&lt;&lt;&amp;b&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc8c
	cout&lt;&lt;&amp;c&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc90
    cout&lt;&lt;&amp;d&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc88，d跟a是一回事，一个地址
	cout&lt;&lt;&amp;e&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc94
    cout&lt;&lt;&amp;f&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedc88，d跟a是一回事，一个地址，只是f是个常引用，你不能修改f，或者说通过修改f来修改a
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-关于什么情况可以绑左右值"><a href="#5-关于什么情况可以绑左右值" class="headerlink" title="5.关于什么情况可以绑左右值"></a>5.关于什么情况可以绑左右值</h4><p>引用（被）绑定(到)值，（将）值绑定到引用.</p>
<p>举例：右值引用<strong>绑定</strong>右值，右值<strong>绑定到</strong>右值引用</p>
<ul>
<li><p>右值引用可以被绑定到右值</p>
<ul>
<li><pre><code class="c++">int i = 42; 
int &amp;&amp;r = i * 2;  //正确！ 将 i * 2 的结果(是个右值)绑定到 右值引用r 上
<pre class="line-numbers language-none"><code class="language-none">
- 右值引用不可以被绑定到左值

  - &#96;&#96;&#96;c++
    int i &#x3D; 42;
    int &amp;&amp;rr &#x3D; i;     &#x2F;&#x2F; 错误！ i 是左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>左值引用不可以被绑定到右值</p>
<ul>
<li><pre><code class="c++">int i = 1;
int &amp;l = 2*i;//错误！ 2*i是个右值，无法绑定到左值引用
int &amp;ll = 10;//错误！	10是个右值，无法绑定到左值引用
<pre class="line-numbers language-none"><code class="language-none">
- const 的左值引用可以被绑定到右值

  - &#96;&#96;&#96;c++
    int i &#x3D; 42;
    const int &amp;l &#x3D; i * 2;  &#x2F;&#x2F; 正确! 可以将 const 引用绑定到右值上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>为什么左值引用不可以绑定到右值，但是const左值引用可以呢</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int l&#x3D; i*2;&#x2F;&#x2F;不行
 const int&amp; l&#x3D;i*2&#x2F;&#x2F;可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>一个字面值右值如 42，或者i<em>2，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题（1.不是常量的引用与常量绑定；2.就算我们可以对其进行绑定，我们只能修改那个临时量，不能修改你原本想绑定的东西（这条见底下的tmp和dval）），所以，我们*<em>只可以用常引用绑定右值，而普通引用是不可以的。</em></em></p>
</li>
<li><p>详细解释：</p>
</li>
<li><pre><code class="c++">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么
double dval = 3.14;

const int &amp;ri = dval;

//上边这句代码将被翻译成两句
// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：
const int tmp = dval;   // 先将双精度浮点数变成一个整型常量
const int &amp;ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上
<pre class="line-numbers language-none"><code class="language-none">
  这种情况下，ri 会被绑定到一个 **临时量** (temporary)对象上，**所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。** 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。

- 我们再来看看如果 ri 不是常量引用会发生什么：

- &#96;&#96;&#96;c++
  double dval &#x3D; 3.14; 
  
  int &amp;ri &#x3D; dval;&#x2F;&#x2F;这种写法其实是错的，编译器会报错
  &#x2F;&#x2F;上边这句代码将被翻译成两句
  &#x2F;&#x2F; 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：
  const int tmp &#x3D; dval;   &#x2F;&#x2F; 还是先将双精度浮点数变成一个整型常量
  int &amp;ri &#x3D; tmp;          &#x2F;&#x2F; 再让这个普通引用和 tmp 绑定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>
<ul>
<li>1.tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>
<li>2.就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>
</ul>
</li>
<li><p>于是乎，<strong>编译器直接禁止了这种行为（<code>double dval = 3.14; int &amp;ri = dval;//error!</code>）</strong>。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>
</li>
<li><p>所以关于左值引用的规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>
</li>
<li><p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>
</li>
</ul>
</li>
<li><p>const左值引用可以绑定右值引用</p>
<ul>
<li><pre><code class="c++">int a=1;
const int&amp; b=move(a);//这句话相当于const int&amp;b=a;
<pre class="line-numbers language-none"><code class="language-none">
    

#### 总结：

- 可以绑定到左值的：
  - 左值引用
  - const左值引用
- 可以绑定到右值的
  - 右值引用
  - const 的左值引用

#### 牛客版答案

右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：

1. 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。（移动构造、移动赋值）

2. 能够更简洁明确地定义泛型函数。（比如move、forward等的函数参数类型和返回值类型）



左值和右值的概念：

左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象。

右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。



右值和左值的区别：

1. 左值可以寻址，而右值不可以。

2. 左值可以被赋值，右值不可以被赋值，但可以用来给左值赋值。

3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。

### 26.C++如何处理返回值？

#### 1.**对于返回值为值类型的函数，其返回值为右值** （对于自定义类型稍有特殊性）

**总述：**

使用临时对象（temporary object）来保存函数的返回值。函数的返回值用于初始化调用点的一个临时对象，该临时对象就是函数调用的结果。

&#96;&#96;&#96;c++
int func()  
&#123;  
return 1;  
&#125;  
int i &#x3D; func(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>此时，有一个临时对象用来保存 func() 函数的返回值 1 ，之后将临时对象的值赋值给变量 i 。像其它任何对象一样，临时对象需要存储空间，并且能够构造和销毁。临时对象和其它对象的区别在于从来看不到它们，编译器负责决定他们的去留以及它们存在的细节。</p>
<p><strong>细节：</strong></p>
<ul>
<li><p><strong>对于内置类型</strong>（函数返回值，<strong>是个右值</strong>，更改它从来都不合法）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int test()
&#123;
	int a &#x3D; 1;
	return a;&#x2F;&#x2F;返回右值
&#125;
int main()
&#123;
	test() &#x3D; 10;&#x2F;&#x2F;error!表达式必须是可修改的左值
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>对于自定义类型</strong>（<strong>居然可以更改这个函数返回值？！</strong>它可以叫做“可以修改的右值”，或者说消亡值？）</p>
<ul>
<li><strong>至于此时rvalue为什么可以被赋值，你可以认为它只是调用了assignment operator而已，就相当于调用一个rvalue的成员函数而已。</strong></li>
<li><strong>匿名临时对象能够调用非const成员函数是一个遗留问题，在新标准(C++11)下可以在成员函数参数列表之后使用成员函数引用限定符 &amp;(限定左值)，&amp;&amp;(限定右值)。至于新标准下，匿名临时对象为什么没有被定义为 const，是为了支持移动语义。</strong></li>
<li>所以当赋值函数X&amp; operator&#x3D;(const X&amp;) &amp;{ cout &lt;&lt; “赋值函数” &lt;&lt; endl; return *this; }加上左值限定时，这个奇葩的写法就会报错了</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

class X
&#123;
public:
	X(int i&#x3D;0) &#123; std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl; &#125;
	X(const X&amp; x) &#123; std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; &#125;
	&#x2F;&#x2F;X( X&amp;&amp; x) &#123; std:; cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125;
	X&amp; operator&#x3D;(const X&amp;) &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
	~X() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
&#125;;

X func()
&#123;
	X x;
	return x;
&#125;

int main()
&#123;
	X test;
	func() &#x3D; test;&#x2F;&#x2F;这个写法非常非常诡异，func()理论上应该是右值，但是它可以被赋值，但是&amp;(func())取地址操作又是错误的
    &#x2F;&#x2F;你可以理解为它只是调用了assignment operator而已，就相当于调用一个rvalue的成员函数而已。
    &#x2F;&#x2F;你想杜绝它的方法就是，声明赋值函数为左值限定时X&amp; operator&#x3D;(const X&amp;)&amp; &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
    &#x2F;&#x2F;func()&#x3D;temp也就会报错了，就跟内置类型一样
	return 0;
&#125;
&#x2F;*construct   构造test
construct	  构造局部对象x	
copy			复制构造给临时对象
析构			局部对象x析构
赋值函数		调用临时对象的operator&#x3D;()
析构			&#x2F;&#x2F;临时对象析构
析构*&#x2F;		&#x2F;&#x2F;test析构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="2-对于一般的自定义类型函数返回值的问题（都是局部对象复制构造给临时对象，临时对象复制构造给主函数的对象-或者是局部对象移动构造给临时对象，临时对象移动构造给主函数的对象）"><a href="#2-对于一般的自定义类型函数返回值的问题（都是局部对象复制构造给临时对象，临时对象复制构造给主函数的对象-或者是局部对象移动构造给临时对象，临时对象移动构造给主函数的对象）" class="headerlink" title="2.对于一般的自定义类型函数返回值的问题（都是局部对象复制构造给临时对象，临时对象复制构造给主函数的对象;或者是局部对象移动构造给临时对象，临时对象移动构造给主函数的对象）"></a>2.对于一般的自定义类型函数返回值的问题（都是局部对象复制构造给临时对象，临时对象复制构造给主函数的对象;或者是局部对象移动构造给临时对象，临时对象移动构造给主函数的对象）</h4><ul>
<li>未定义移动构造时</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;对于自定义类型，无任何编译器优化的情况下
class X
&#123;
public:
	X(int i&#x3D;0) &#123; std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl; &#125;
	X(const X&amp; x) &#123; std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; &#125;
	&#x2F;&#x2F;X( X&amp;&amp; x) &#123; std:; cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125;
	X&amp; operator&#x3D;(const X&amp;) &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
	~X() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
&#125;;

X func()
&#123;
	X x;
	return x;
&#125;

int main()
&#123;
	X test&#x3D;func();
    cout&lt;&lt;&quot;123&quot;&lt;&lt;endl;
	return 0;
&#125;
&#x2F;&#x2F;msvc输出:
&#x2F;&#x2F;construct    	：func()函数内部的局部对象x构造
&#x2F;&#x2F;copy		  	 :func()函数内部的return语句复制构造给主函数中的对象
&#x2F;&#x2F;析构			:func()函数内部的局部对象x析构
&#x2F;&#x2F;123
&#x2F;&#x2F;析构			:对象test析构

差别在于主函数是不是会产生一个临时变量！

&#x2F;&#x2F;gcc输出：
&#x2F;&#x2F;输出:
&#x2F;&#x2F;construct    	：func()函数内部的局部对象x构造
&#x2F;&#x2F;copy		  	 :func()函数内部的return语句复制构造给主函数中的临时对象
&#x2F;&#x2F;析构			:func()函数内部的局部对象x析构
&#x2F;&#x2F;copy			:主函数中的临时对象复制构造给对象test
&#x2F;&#x2F;析构			:临时对象析构
&#x2F;&#x2F;123
&#x2F;&#x2F;析构			:对象test析构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>定义移动构造后（就是把所有上边所有的复制构造变成了移动构造，还是会有中间的临时变量）</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

class X
&#123;
public:
	X(int i&#x3D;0) &#123; std::cout &lt;&lt; &quot;construct&quot; &lt;&lt; std::endl; &#125;
	X(const X&amp; x) &#123; std::cout &lt;&lt; &quot;copy&quot; &lt;&lt; std::endl; &#125;
	X( X&amp;&amp; x) &#123; std:; cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl; &#125;
	X&amp; operator&#x3D;(const X&amp;) &#123; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl; return *this; &#125;
	~X() &#123; cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl; &#125;
&#125;;

X func()
&#123;
	X x;
	return x;
&#125;

int main()
&#123;
	X test&#x3D;func();
	cout&lt;&lt;&quot;123&quot;&lt;&lt;endl;
	return 0;
&#125;

&#x2F;&#x2F;msvc输出:
&#x2F;&#x2F;construct				:func()函数内部的局部变量x构造
&#x2F;&#x2F;move construct		：x移动构造给主函数变量test
&#x2F;&#x2F;析构					：局部变量x析构
&#x2F;&#x2F;123
&#x2F;&#x2F;析构					:变量test析构

差别在于主函数是不是会产生一个个临时变量！
&#x2F;&#x2F;gcc输出：
&#x2F;&#x2F;construct				:func()函数内部的局部变量x构造
&#x2F;&#x2F;move construct		：x移动构造给临时变量
&#x2F;&#x2F;析构					：局部变量x析构
&#x2F;&#x2F;move construct		：临时变量移动构造给变量test
&#x2F;&#x2F;析构					:临时变量析构
&#x2F;&#x2F;123
&#x2F;&#x2F;析构					:变量test析构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-返回值为引用类型的函数（返回值是左值）"><a href="#3-返回值为引用类型的函数（返回值是左值）" class="headerlink" title="3.返回值为引用类型的函数（返回值是左值）"></a>3.返回值为引用类型的函数（返回值是左值）</h4><ul>
<li>当函数的返回值是引用类型时，其返回值即为return的变量，所以不需要临时对象保存其返回值。所以，对于返回值为引用类型的函数，其返回值为左值。</li>
<li>当函数返回引用类型时，没有复制返回值，相反，返回的是对象本身。</li>
<li>所以千万不要返回局部对象的引用！千万不要返回指向局部对象的指针！</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char&amp; get_val(string&amp; str, int index)
&#123;
	return str[index - 1];
&#125;

int main()
&#123;
	string str &#x3D; &quot;12345&quot;;
	char ch &#x3D; get_val(str, 1);&#x2F;&#x2F;ch的值是’1’
	cout &lt;&lt; ch &lt;&lt; endl;
	get_val(str, 1) &#x3D; &#39;a&#39;;&#x2F;&#x2F;此时str的值为”a2345”&#x2F;&#x2F;函数的返回值是左值
	cout &lt;&lt; str &lt;&lt; endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-上述都是不考虑编译器优化时（RVO、NRVO）"><a href="#4-上述都是不考虑编译器优化时（RVO、NRVO）" class="headerlink" title="4.上述都是不考虑编译器优化时（RVO、NRVO）"></a>4.上述都是不考虑编译器优化时（RVO、NRVO）</h4><p>RVO是一个不100%保证、不确定的编译器行为</p>
<ul>
<li><strong>返回值优化</strong>（Return value optimization，缩写为<strong>RVO</strong>）<ul>
<li>是C++的一项编译优化技术。即删除保持函数返回值的临时对象。这可能会省略两次复制构造函数，即使复制构造函数有副作用</li>
</ul>
</li>
<li><strong>命名返回值优化</strong>（Named return value optimization，NRVO）<ul>
<li>NRVO去除了基于栈的返回值的构造与析构。虽然这会导致优化与未优化的程序的不同行为。</li>
</ul>
</li>
<li><img src="http://pichost.yangyadong.site/img/image-20210731212422734.png" alt="image-20210731212422734"></li>
<li>编译器把y的地址，直接传入到getNum函数中。然后a就根本没有生成，在y上直接构造了对象，这才是真正的RVO，所以他根本没return a</li>
</ul>
<p>在g++中可以加上”-fno-elide-constructors”以禁止任何的优化行为</p>
<h3 id="27-A-obj；与A-obj-；的问题"><a href="#27-A-obj；与A-obj-；的问题" class="headerlink" title="27. A  obj；与A obj()；的问题"></a>27. A  obj；与A obj()；的问题</h3><ul>
<li>使用默认构造函数来构造栈上对象时，切记不要写成 A obj()；这会被当做函数声明：<ul>
<li>即编译器认为obj（）是函数名，A是返回值类型</li>
</ul>
</li>
<li>正确构造栈上对象的写法：<ul>
<li>A obj;</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;
public:
	Person(int a &#x3D; 0) :test(a) &#123; cout &lt;&lt; &quot;普通构造&quot; &lt;&lt; endl; &#125;;
	Person(const Person&amp; x) :test(x.test) &#123; cout &lt;&lt; &quot;复制构造&quot; &lt;&lt; endl; &#125;;
	Person&amp; operator&#x3D;(Person x) &#123; test &#x3D; x.test; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl;; return *this; &#125;
	int test;
&#125;;

int main()
&#123;

	Person a(100);&#x2F;&#x2F;普通构造
	Person b;&#x2F;&#x2F;普通构造
    
	Person c();&#x2F;&#x2F;eroor!这样写会报错！因为编译器把这句话认为了是一个函数声明。
    &#x2F;&#x2F;编译器认为，c()是一个函数声明，返回值是Person类型。它并不认为c是一个对象实例！
    
    &#x2F;&#x2F;正确写法
    Person c;&#x2F;&#x2F;普通构造，构造了一个对象c
    
	&#x2F;&#x2F;在new对象的时候，加不加括号都行。在单独声明对象的时候，切记不要加括号。
    Person* temp &#x3D; new Person();&#x2F;&#x2F;普通构造
	Person* temp2 &#x3D; new Person;&#x2F;&#x2F;普通构造
    
    delete temp;
    delete temp2;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="28-C-对象大小"><a href="#28-C-对象大小" class="headerlink" title="28.C++对象大小"></a>28.C++对象大小</h3><ul>
<li>C++类的函数占不占用对象大小<ul>
<li>函数放在代码区（text)段，不占用对象大小</li>
</ul>
</li>
<li>空类的大小<ul>
<li>sizeof(空类)&#x3D;1 Byte</li>
<li>因为每个对象的实例化都需要空间，编译器自动起了一个字节的占位符。但凡类里有一个char成员变量，它都不用使用占位符。</li>
</ul>
</li>
<li>空结构体的大小<ul>
<li>sizeof(空结构体)&#x3D;1 Byte</li>
</ul>
</li>
<li>类中没有数据成员，只有函数成员，类大小<ul>
<li>sizeof(类)&#x3D;1 Byte</li>
</ul>
</li>
<li>类中有虚函数，类的大小<ul>
<li>虚函数表指针占4Byte  （32位系统）</li>
</ul>
</li>
</ul>
<h3 id="29-结构体内存对齐"><a href="#29-结构体内存对齐" class="headerlink" title="29.结构体内存对齐"></a>29.结构体内存对齐</h3><ul>
<li>1、原因：<ul>
<li>1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ul>
</li>
<li>2、规则<ul>
<li><strong>1.对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍</strong></li>
<li><strong>2.结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍</strong></li>
<li><strong>3.如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型</strong></li>
</ul>
</li>
<li>3、定义结构体对齐<ul>
<li>可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</li>
</ul>
</li>
<li>4、举例</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma pack(2)

struct AA &#123;

int a;    &#x2F;&#x2F;长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]

char b;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]

short c;   &#x2F;&#x2F;长度2 &#x3D; 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]

char d;  &#x2F;&#x2F;长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；目前共9Byte
&#x2F;&#x2F;结束时检查整个结构体要是2的倍数，一看目前只有9Byte，再添1Byte形成2的倍数。
&#x2F;&#x2F;即总共10Byte
&#125;;

#pragma pack()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="30-this指针"><a href="#30-this指针" class="headerlink" title="30.this指针"></a>30.this指针</h3><ul>
<li>this指针占用对象大小吗？<ul>
<li>不占用</li>
</ul>
</li>
<li>this指针的地址是什么含义<ul>
<li>就是栈上对象或者堆上对象的地址</li>
</ul>
</li>
<li>普通成员函数和静态成员函数中有关this<ul>
<li>类内普通成员函数，你形参不用写类指针，会自动把this指针传入函数中<ul>
<li>注意类内写sort函数的排序函数时，切记不能写成普通成员函数。因为会自动传入this指针！与形参模板不匹配</li>
</ul>
</li>
<li>但是对<strong>于类内静态成员函数，this指针是不会被传入函数的</strong>。你想使用this指针？人工写形参并且在主函数中人工传入this</li>
</ul>
</li>
</ul>
<h2 id="二、指针、数组、字符串"><a href="#二、指针、数组、字符串" class="headerlink" title="二、指针、数组、字符串"></a>二、指针、数组、字符串</h2><h3 id="1-请说一下C-x2F-C-中指针和引用的区别？"><a href="#1-请说一下C-x2F-C-中指针和引用的区别？" class="headerlink" title="1.请说一下C&#x2F;C++ 中指针和引用的区别？"></a>1.请说一下C&#x2F;C++ 中指针和引用的区别？</h3><p>1.指针和引用的定义和性质区别：</p>
<ul>
<li><p>(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；引用：引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。</p>
<p>- </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a&#x3D;1;int *p&#x3D;&amp;a;&#x2F;&#x2F;定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。

int a&#x3D;1;int &amp;b&#x3D;a;&#x2F;&#x2F;定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>(2)指针可以是空值即nullptr，在创建时可以不进行初始化，可以在任何时候被初始化。引用不可以为空，当被创建的时候，必须初始化。</p>
</li>
<li><p>(3)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不可以再改变了</p>
</li>
<li><p>(4)可以有const指针，但是没有const引用；</p>
<ul>
<li><p>指的是 <code>int * const ptr</code>，即不可以改变指向的指针</p>
</li>
<li><pre><code class="c++">int* const p = &amp;a;//可以
 int&amp; const b = a;//不行
<pre class="line-numbers language-none"><code class="language-none">
- (5)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &amp;&amp;a是不合法的。其实是左值引用）

- (6)使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

- (7)指针和引用的自增(++)运算意义不一样；

- (8)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；

  - 如果返回引用，一个赋值操作就泄露了

  - &#96;&#96;&#96;c++
    比如string &amp; fun()
    &#123;
      string* str&#x3D;new string(&quot;abcd&quot;);
      return *str;
    &#125;
    如果你接收函数返回值时，不是使用引用 string &amp; str&#x3D;fun()  &#x2F;&#x2F;正确
    而是用对象 string str&#x3D;fun()，不会报错，但相当于赋值，调用的是重载的&#x3D;运算符，在函数里new的内存就无法delete了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><pre><code class="c++">//这是类外函数
const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)//返回创建的堆对象的引用
&#123;
    Rational* result=new Rational(lhs.n*rhs.n,lhs,d*rhs.d);
    return *result;
&#125;

Rational w,x,y,z;
w=x*y*z;//与operator*(operator*(x,y),z)相同
//同一个语句调用了两次operator*，因而两次使用new，也就需要两次delete。两次new的对象都没有办法被捕获，没有合理的办法让我们取得operator*返回的references背后隐藏的那个指针，这绝对导致资源泄露。
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  class myclass &#123;
  public:
  	myclass() &#123;
  		cout &lt;&lt; &quot;构造&quot; &lt;&lt; endl;
  	&#125;
  	~myclass()&#123;
  		cout &lt;&lt; &quot;析构&quot; &lt;&lt; endl;
  	&#125;
  &#125;;
  
  myclass&amp; helper()
  &#123;
  	myclass* temp &#x3D; new myclass;
  	return *temp;
  &#125;
  
  int main()
  &#123;
  	myclass a;&#x2F;&#x2F;myclass a&#x3D;helper();这样将仅有一次构造，一次析构
  	a&#x3D;helper();
  	return 0;
  &#125;
  &#x2F;&#x2F;构造
  &#x2F;&#x2F;构造
  &#x2F;&#x2F;析构
  helper()里构造的对象没有析构，资源泄露了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

  (9)作为函数参数传递时，指针需要被解引用才可以对对象进行操作，而引用无需解引用，直接对引用的修改都会改变引用所指向的对象；
</code></pre>
</li>
</ul>
<h3 id="2-数组和指针的区别"><a href="#2-数组和指针的区别" class="headerlink" title="2.数组和指针的区别"></a>2.数组和指针的区别</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li><strong>数组</strong>：数组是用于储存多个相同类型数据的集合。</li>
<li><strong>指针</strong>：指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</li>
</ul>
<h4 id="2-赋值"><a href="#2-赋值" class="headerlink" title="2.赋值"></a>2.赋值</h4><ul>
<li>同类型指针变量可以相互赋值</li>
<li>数组不行，只能一个一个元素的赋值或拷贝.</li>
</ul>
<h4 id="3-存储方式"><a href="#3-存储方式" class="headerlink" title="3.存储方式"></a>3.存储方式</h4><ul>
<li><strong>数组</strong>：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，多维数组在内存中是按照一维数组存储的，只是在逻辑上是多维的。<ul>
<li>数组的存储空间，不是在静态区就是在栈上。</li>
</ul>
</li>
<li><strong>指针</strong>：指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。<ul>
<li>指针：由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</li>
</ul>
</li>
</ul>
<h4 id="4-求sizeof"><a href="#4-求sizeof" class="headerlink" title="4.求sizeof"></a>4.求sizeof</h4><ul>
<li><strong>数组</strong>：<ul>
<li>数组所占存储空间的内存：sizeof（数组名）<br>数组的大小：sizeof（数组名）&#x2F;sizeof（数据类型）</li>
</ul>
</li>
<li><strong>指针</strong>：<ul>
<li>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</li>
</ul>
</li>
</ul>
<h4 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a>5.初始化</h4><ul>
<li><p><strong>数组</strong>：</p>
<ul>
<li><pre><code class="c++">（1）char a[]=&#123;&quot;Hello&quot;&#125;;//按字符串初始化，大小为6.
（2）char b[]=&#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;&#125;;//按字符初始化（错误，输出时将会乱码，没有结束符）
（3）char c[]=&#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;&#125;;//按字符初始化
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  这里补充一个大家的误区，就是关于数组的创建和销毁，尤其是多维数组的创建与销毁。
  （1）一维数组：
  int* arr &#x3D; new int[n];&#x2F;&#x2F;创建一维数组
  delete[] arr;&#x2F;&#x2F;销毁
  （2）二维数组：
  int** arr &#x3D; new int*[row];&#x2F;&#x2F;这样相当于创建了数组有多少行
  for(int i&#x3D;0;i&lt;row;i++)
  &#123;
  arr[i] &#x3D; new int[col];&#x2F;&#x2F;到这里才算创建好了
  &#125;
  &#x2F;&#x2F;释放
  for(int i&#x3D;0;i&lt;row;i++)
  &#123;
  delete[] arr[i];
  &#125;
  delete[] arr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>指针</strong>：</p>
<ul>
<li><pre><code class="c++">//（1）指向对象的指针：（()里面的值是初始化值）
int *p=new int(0) ;    delete p;
//（2）指向数组的指针：(n表示数组的大小，值不必再编译时确定，可以在运行时确定)
int *p=new int[n];    delete[] p;
//（3）指向类的指针：(若构造函数有参数，则new Class后面有参数，否则调用默认构造函数，delete调用析构函数)
Class *p=new Class;  delete p;
//（4）指针的指针：（二级指针）
int **pp=new (int*)[1]; 
pp[0]=new int[6];
delete[] pp[0];
<pre class="line-numbers language-none"><code class="language-none">
- 指针数组与数组指针，它俩都是二级指针

  - [ ]的优先级比*高

  - **指针数组：它实际上是一个一维数组**，数组的每个元素存放的是一个指针类型的元素。

    - 

    &#96;&#96;&#96;c++
    int* arr[8];
    &#x2F;&#x2F;优先级问题：[]的优先级比*高
    &#x2F;&#x2F;说明arr是一个数组，而int*是数组里面的内容
    &#x2F;&#x2F;这句话的意思就是：arr是一个含有8个int*的数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

- ![image.png](https://i.loli.net/2020/08/27/w5Va6ZPu8C9Wh74.png)
</code></pre>
</li>
<li><p><strong>数组指针：它实际上是一个指针</strong>，该指针指向一个数组。</p>
<ul>
<li><pre><code class="c++">int (*arr)[8];
//由于[]的优先级比*高，因此在写数组指针的时候必须将*arr用括号括起来
//arr先和*结合，说明p是一个指针变量
//这句话的意思就是：指针arr指向一个大小为8个整型的数组。
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;c++
  int main()
  &#123;
  	int arr[2][3] &#x3D; &#123;1,1,1,3,3,3&#125;;&#x2F;&#x2F;二维数组
  	int(*arrr)[3];&#x2F;&#x2F;数组指针，arrr指向一个包含3个int的数组名
  	arrr &#x3D; &amp;arr[0];
  	cout &lt;&lt; (*arrr)[0] &lt;&lt; endl;&#x2F;&#x2F;1
  	cout&lt;&lt; (*arrr)[1] &lt;&lt; endl;&#x2F;&#x2F;1
  	cout &lt;&lt; (*arrr)[2] &lt;&lt; endl;&#x2F;&#x2F;1
  	arrr &#x3D; &amp;arr[1];
  	cout &lt;&lt; (*arrr)[0] &lt;&lt; endl;&#x2F;&#x2F;3
  	cout &lt;&lt; (*arrr)[1] &lt;&lt; endl;&#x2F;&#x2F;3
  	cout &lt;&lt; (*arrr)[2] &lt;&lt; endl;&#x2F;&#x2F;3
  	return 0;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-传参"><a href="#6-传参" class="headerlink" title="6.传参"></a>6.传参</h4><p><strong>数组传参时，会退化为指针，所以我们先来看看什么是退化！</strong><br>（1）退化的意义：C语言只会以值拷贝的方式传递参数，参数传递时，如果只拷贝整个数组，效率会大大降低，并且在参数位于栈上，太大的数组拷贝将会导致栈溢出。<br>（2）因此，C语言将数组的传参进行了<strong>退化</strong>。将整个数组拷贝一份传入函数时，<strong>将数组名看做常量指针，传数组首元素的地址</strong>。</p>
<p><strong>重要：</strong></p>
<p>一维数组才可以用一个指针代替，所以指针数组变为二级指针没有问题。</p>
<ul>
<li><p>二级指针<code>int **p</code>做形参可以接收<strong>指针数组</strong><code>int *arr[10]</code>实参。（数组指针做实参不行）</p>
<ul>
<li><code>p[0]</code>就是指针数组的第一个指针</li>
</ul>
</li>
<li><p><strong>数组指针</strong><code>int (*p)[3]</code>做形参可以接收二维数组<code>int arr[2][3]</code>实参  （数组指针做形参不行）</p>
<ul>
<li><code>*p</code>就相当于arr第一行的地址，<code>(*P)[0],(*P)[1],(*P)[2]</code>代表 1 2 3</li>
<li><code>*(p+1)</code>就相当于第二行的地址，<code>(*(P+1))[0],(*(P+1))[1],(*(P+1))[2]</code>代表 4 5 6</li>
</ul>
</li>
<li><p>1.一维数组的传参</p>
<ul>
<li><p>实参是一维数组\指针数组，传给形参</p>
</li>
<li><pre><code class="c++">#include &lt;stdio.h&gt;
//传参方式正确
//用数组的形式传递参数，不需要指定参数的大小，因为在一维数组传参时，形参不会真实的创建数组，传的只是数组首元素的地址。（如果是变量的值传递，那么形参就是实参的一份拷贝）
void test(int arr[])
&#123;&#125;

//传参方式正确
//不传参数可以，传递参数当然也可以
void test(int arr[10])
&#123;&#125;

//传参方式正确
//一维数组传参退化，用指针进行接收，传的是数组首元素的地址
void test(int *arr)
&#123;&#125;

//传参方式正确
//*arr[20]是指针数组，传过去的是数组名,或者说二级指针
void test2(int *arr[20])
&#123;&#125;

//传参方式正确
//传过去是指针数组的数组名，代表首元素地址，首元素是个指针向数组的指针，再取地址，就表示二级指针，用二级指针接收
void test2(int **arr)
&#123;&#125;
int main()
&#123;
int arr[10] = &#123;0&#125;;//一维数组
int *arr2[20] = &#123;0&#125;;//指针数组
test(arr);
test2(arr2);
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- 2.二维数组的传参

  - 实参是二维数组，传给形参

  - 传二维数组，一定要知道每行元素的个数，这样才能切割。

    - 所以对于&#96;int arr[2][3]&#96;，用&#96;int** p&#96;，&#96;int arr[][],int arr[2][]&#96;,&#96;int* p[2]&#96;接收都不行

      - 看似&#96;int* p[2]&#96;也对，因为&#96;arr[2][3]&#96;就可以看作2个一维数组，每个数组3个元素。所以&#96;int* p[2]&#96;代表p是一个数组，里边有两个指针，各自代表一个一维数组。但是实际上，由于传参仅传进去一个地址，不知道每行元素的个数，只知道有几行，这样也无法分割。因为元素是一行一行的串行存放的，传进来可不知道一共有6个元素

    - 只可以&#96;int (*p)[3]&#96;，它代表p是一个指针，指向一个含3个元素的一维数组

      - &#96;&#96;&#96;c++
        void fun(int(*a)[3])
        &#123;
        	for (int i &#x3D; 0; i &lt; 3; i++)
        		cout &lt;&lt; (*a)[i];&#x2F;&#x2F;cout&lt;&lt;a[0][i];也行
        	for (int i &#x3D; 0; i &lt; 3; i++)
        		cout &lt;&lt; (*(a+1))[i];
        &#125;
        123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

    
</code></pre>
</li>
<li><pre><code class="c++">//传参正确
//表明二维数组的大小，三行五列
void test(int arr[3][5])
&#123;&#125;

//传参不正确
//二维数组的两个方括号，不能全部为空，也不能第二个为空，只能第一个为空
void test(int arr[][])
&#123;&#125;

//传参正确
//可以写成如下这样传参形式，但是不能写int arr[3][]
void test(int arr[][5])
&#123;&#125;

//传参不正确
//arr是一级指针，可以传给二维数组，但是不能正确读取
void test(int *arr)
&#123;&#125;

//传参不正确
//这里的形参是指针数组，是一维的，可以传参，但是读取的数据不正确
void test(int* arr[3])
&#123;&#125;

//传参正确
//传过去的是二维数组的数组名，即数组首元素的地址，也就是第一行的地址，第一行也是个数组，用一个数组指针接收
void test(int (*arr)[5])
&#123;&#125;

//传参不正确
//可以传参，但是在读取的时候会有级别不同的问题
void test(int **arr)
&#123;&#125;
int main()
&#123;
int arr[3][5] = &#123;0&#125;;//二维数组
test(arr);
&#125;
<pre class="line-numbers language-none"><code class="language-none">
#### 7.函数指针

&#96;&#96;&#96;c++
void test()
&#123;
printf(&quot;hehe\n&quot;);
&#125;
&#x2F;&#x2F;pfun能存放test函数的地址
void (*pfun)();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>函数指针的形式：<code>类型(*)( )，例如：int (*p)( ).</code>它可以存放函数的地址，在平时的应用中也很常见。</p>
<p><strong>函数指针的典型用途——实现函数回调</strong></p>
<ul>
<li>通过函数指针调用的函数<ul>
<li>例如：将函数的指针作为参数传递给一个函数，使得在处理相似事件的时候可以灵活的使用不同的方法。</li>
</ul>
</li>
<li>调用者不关心谁是被调用者<ul>
<li>需知道存在一个具有特定原型和限制条件的被调用函数</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数回调
#include&lt;iostream&gt;
using namespace std;

int compute(int a,int b,int(*func)(int,int))
&#123;	return func(a, b);&#125;

int max(int a,int b)&#x2F;&#x2F;求最大值
&#123;	return ((a &gt; b) ? a : b);&#125;

int min(int a, int b) &#x2F;&#x2F;求最小值
&#123;return ((a &lt; b) ? a : b);&#125;

int sum(int a,int b)&#x2F;&#x2F;求和
&#123;return a + b;&#125;

int main()
&#123;
	int a, b, res;
	cout &lt;&lt; &quot;输入a:&quot;; cin &gt;&gt; a;
	cout &lt;&lt; &quot;输入b:&quot;; cin &gt;&gt; b;

	res &#x3D; compute(a, b, &amp;max);&#x2F;&#x2F;不加&amp;也行
	cout &lt;&lt; &quot;Max of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
	
	res &#x3D; compute(a, b, &amp;min);
	cout &lt;&lt; &quot;Min of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
	
	res &#x3D; compute(a, b, &amp;sum);
	cout &lt;&lt; &quot;Sum of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="8-函数指针数组"><a href="#8-函数指针数组" class="headerlink" title="8.函数指针数组"></a>8.函数指针数组</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">形式：例如int (*p[10])( );
因为p先和[ ]结合，说明p是数组，数组的内容是一个int (*)( )类型的指针
函数指针数组在转换表中应用广泛<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="9-函数指针数组的指针（过于复杂）"><a href="#9-函数指针数组的指针（过于复杂）" class="headerlink" title="9.函数指针数组的指针（过于复杂）"></a>9.函数指针数组的指针（过于复杂）</h4><p>指向函数指针数组的一个指针，也就是说，指针指向一个数组，数组的元素都是函数指针</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void test(const char* str)
&#123;
printf(&quot;%s\n&quot;, str);
&#125;
int main()
&#123;
&#x2F;&#x2F;函数指针pfun
void (*pfun)(const char*) &#x3D; test;
&#x2F;&#x2F;函数指针的数组pfunArr
void (*pfunArr[5])(const char* str);
pfunArr[0] &#x3D; test;
&#x2F;&#x2F;指向函数指针数组pfunArr的指针ppfunArr
void (*(*ppfunArr)[10])(const char*) &#x3D; &amp;pfunArr;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="指针和数组的主要区别如下："><a href="#指针和数组的主要区别如下：" class="headerlink" title="指针和数组的主要区别如下："></a>指针和数组的主要区别如下：</h4><table>
<thead>
<tr>
<th>指针</th>
<th>数组</th>
</tr>
</thead>
<tbody><tr>
<td>保存数据的地址</td>
<td>保存数据</td>
</tr>
<tr>
<td>间接访问数据，首先获得指针变量的内容，然后将其作为地址，从该地址中提取数据</td>
<td>直接访问数据，</td>
</tr>
<tr>
<td>通常用于动态的数据结构</td>
<td>通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td>通过Malloc分配内存，free释放内存</td>
<td>隐式的分配和删除</td>
</tr>
<tr>
<td>通常指向匿名数据，操作匿名函数</td>
<td>自身即为数据名</td>
</tr>
</tbody></table>
<h3 id="3-请你回答一下野指针是什么？"><a href="#3-请你回答一下野指针是什么？" class="headerlink" title="3.请你回答一下野指针是什么？"></a>3.请你回答一下野指针是什么？</h3><p>在这里注意了，free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重 要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，释放内存后应把把指针指向NULL，防止指针在后面不小心又被使用，造成无法估计的后果。</p>
<h4 id="野指针定义："><a href="#野指针定义：" class="headerlink" title="野指针定义："></a>野指针定义：</h4><p>指向内存被释放的内存或者没有访问权限的内存的指针。野指针不能通过判断是否为NULL来避免</p>
<h4 id="野指针产生的原因："><a href="#野指针产生的原因：" class="headerlink" title="野指针产生的原因："></a>野指针产生的原因：</h4><ul>
<li>（1）指针变量未初始化：任何指针变量刚被创建时不会自动成为NULL指针，所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</li>
<li>（2）指针释放之后未置空：有时指针在free或delete后未赋值 NULL，free或delete后它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。 （这个其实是悬挂指针）<ul>
<li>所以释放后的指针应立即将指针置为NULL，防止产生“野指针”。</li>
</ul>
</li>
<li>（3）指针操作超越变量作用域：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</li>
</ul>
<h4 id="其实跟悬挂指针区别不大，如果硬要区分悬挂指针跟野指针："><a href="#其实跟悬挂指针区别不大，如果硬要区分悬挂指针跟野指针：" class="headerlink" title="其实跟悬挂指针区别不大，如果硬要区分悬挂指针跟野指针："></a>其实跟悬挂指针区别不大，如果硬要区分悬挂指针跟野指针：</h4><ul>
<li>悬垂指针（dangling pointer）一般是说指向已经被释放的自由区内存（free store）的指针。悬挂指针曾经有效过</li>
<li>野指针（wild pointer）则一般是未经初始化的指针。野指针从未有效过。</li>
</ul>
<h4 id="规避方法："><a href="#规避方法：" class="headerlink" title="规避方法："></a>规避方法：</h4><ul>
<li>1.初始化指针的时候将其置为nullptr，之后对其操作。</li>
<li>2.释放指针的时候将其置为nullptr。</li>
</ul>
<h3 id="4-请你来说一下函数指针"><a href="#4-请你来说一下函数指针" class="headerlink" title="4.请你来说一下函数指针"></a>4.请你来说一下函数指针</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>函数指针是指向函数的指针变量。</p>
<p>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<h4 id="2、用途："><a href="#2、用途：" class="headerlink" title="2、用途："></a>2、用途：</h4><p>调用函数和做函数的参数，比如回调函数。</p>
<h4 id="3、示例："><a href="#3、示例：" class="headerlink" title="3、示例："></a>3、示例：</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char* fun(char * p)  &#123;…&#125;    &#x2F;&#x2F; 函数fun

char* (*pf)(char * p);       &#x2F;&#x2F; 函数指针pf

pf &#x3D; &amp;fun;            &#x2F;&#x2F; 函数指针pf指向函数fun，
&#x2F;&#x2F;其实加不加&amp;都可以
&#x2F;&#x2F;pf&#x3D;fun;

char* temp&#x3D;pf(p);            &#x2F;&#x2F; 通过函数指针pf调用函数fun
&#x2F;&#x2F;解不解引用也都可以，甚至都不用跟上边加没加&amp;配套
&#x2F;&#x2F;char* temp&#x3D;(*pf)(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;函数回调
#include&lt;iostream&gt;
using namespace std;

int compute(int a,int b,int(*func)(int,int))
&#123;	return func(a, b);&#125;&#x2F;&#x2F;指针解不解引用也都行,return (*func)(a, b);

int max(int a,int b)&#x2F;&#x2F;求最大值
&#123;	return ((a &gt; b) ? a : b);&#125;

int min(int a, int b) &#x2F;&#x2F;求最小值
&#123;return ((a &lt; b) ? a : b);&#125;

int sum(int a,int b)&#x2F;&#x2F;求和
&#123;return a + b;&#125;

int main()
&#123;
	int a, b, res;
	cout &lt;&lt; &quot;输入a:&quot;; cin &gt;&gt; a;
	cout &lt;&lt; &quot;输入b:&quot;; cin &gt;&gt; b;

	res &#x3D; compute(a, b, &amp;max);&#x2F;&#x2F;不加&amp;也行
	cout &lt;&lt; &quot;Max of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
	
	res &#x3D; compute(a, b, &amp;min);
	cout &lt;&lt; &quot;Min of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
	
	res &#x3D; compute(a, b, &amp;sum);
	cout &lt;&lt; &quot;Sum of&quot; &lt;&lt; a &lt;&lt; &quot;and&quot; &lt;&lt; b &lt;&lt; &quot;is:&quot; &lt;&lt; res &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-以下四行代码的区别是什么？-const-char-arr-x3D-“123”-char-brr-x3D-“123”-const-char-crr-x3D-“123”-char-drr-x3D-“123”"><a href="#5-以下四行代码的区别是什么？-const-char-arr-x3D-“123”-char-brr-x3D-“123”-const-char-crr-x3D-“123”-char-drr-x3D-“123”" class="headerlink" title="5.以下四行代码的区别是什么？ const char * arr &#x3D; “123”; char * brr &#x3D; “123”; const char crr[] &#x3D; “123”; char drr[] &#x3D; “123”;"></a>5.以下四行代码的区别是什么？ const char * arr &#x3D; “123”; char * brr &#x3D; “123”; const char crr[] &#x3D; “123”; char drr[] &#x3D; “123”;</h3><h4 id="1-详细版答案"><a href="#1-详细版答案" class="headerlink" title="1.详细版答案"></a>1.详细版答案</h4><p>常量区就是内存里的数据区，静态区，或者说已初始化数据区</p>
<ul>
<li><p><strong>指向“常量”的指针</strong>，“常量”在这里是真常量</p>
<ul>
<li><pre><code class="c++">const char * arr = &quot;123&quot;;//这里没有const也效果一样
// 可以修改指向: arr = &quot;321&quot;;
// 不可以修改值: arr[0]=&#39;2&#39; //------error
<pre class="line-numbers language-none"><code class="language-none">
  - 指针变量arr在栈区，字符串&quot;123&quot;保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样

- **指向“常量”的指针**，“常量”可能是真常量，例如在常量区的字符串”123“；“常量”也可能是变量，例如Int num_1&#x3D;1。

  - **指向“常量”的指针不代表它所指向的内容一定是常量**，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。

  - &#96;&#96;&#96;c++
    const char *p;&#x2F;&#x2F;上边的arr也是指向常量的指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><pre><code class="c++">先看p,根据优先级它和*结合，是指针，指向char类型，但是char前面有一个const修饰，所以p所指向的内容为const类型不可修改。
int num_a = 1;
const int *p_a = &amp;num_a; //底层const
//*p_a = 2; //错误，指向“常量”的指针不能改变所指的对象
num_a = 2;
cout &lt;&lt; *p_a &lt;&lt; endl;//2
<pre class="line-numbers language-none"><code class="language-none">
  - 注意：**指向“常量”的指针不代表它所指向的内容一定是常量**，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。上例中指针p_a指向的内容就不是常量，可以通过赋值语句：num_a&#x3D;2;  来改变它所指向的内容。

- **普通指针**，但是这里恰巧指向了常量区

  - &#96;&#96;&#96;c++
    &#x2F;&#x2F;const char * arr &#x3D; &quot;123&quot;;&#x2F;&#x2F;加不加const效果一样，因为指针的实际指向就是不能改变的，所以有没有const你都不能改变
    char * brr &#x3D; &quot;123&quot;;&#x2F;&#x2F;加不加const效果一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>字符串123保存在常量区，这个和arr指针指向的是同一个位置，同样不能通过brr去修改”123”的值。</p>
</li>
</ul>
</li>
<li><p><strong>常量数组</strong></p>
<ul>
<li><pre><code class="c++">const char crr[] = &quot;123&quot;;
<pre class="line-numbers language-none"><code class="language-none">
  - 这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区

- **普通数组**

  - &#96;&#96;&#96;c++
    char drr[] &#x3D; &quot;123&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>字符串123保存在栈区，可以通过drr去修改</p>
</li>
</ul>
</li>
<li><p><strong>指针常量</strong></p>
<ul>
<li><pre><code class="c++">char * const p;
<pre class="line-numbers language-none"><code class="language-none">
- const修饰的是p,p不能修改,p所指向的内容可以修改

- &#96;&#96;&#96;c++
  int num_b &#x3D; 2;
  int *const p_b &#x3D; &amp;num_b; &#x2F;&#x2F;顶层const
  &#x2F;&#x2F;p_b &#x3D; &amp;num_a; &#x2F;&#x2F;错误，常量指针不能改变存储的地址值，或者说不能改变指向
  *P_b&#x3D;100;&#x2F;&#x2F;正确，p所指向的内容可以修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2-简洁版的答案"><a href="#2-简洁版的答案" class="headerlink" title="2.简洁版的答案"></a>2.简洁版的答案</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const char * arr &#x3D; &quot;123&quot;;
&#x2F;&#x2F;指针变量arr在栈区，字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区(text段)，本来就不能改变，所以加不加const效果都一样

char * brr &#x3D; &quot;123&quot;;&#x2F;&#x2F;vs里提示错误，const char*不能初始化 char*。所以正确写法是，
char* brr &#x3D; const_cast&lt;char*&gt;(&quot;123&quot;);&#x2F;&#x2F;它依然是保存在常量区！你试图修改brr[0]会报错
&#x2F;&#x2F;指针变量brr在栈区，字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改&quot;123&quot;的值

const char crr[] &#x3D; &quot;123&quot;;
&#x2F;&#x2F;字符数组变量crr在栈区，这里字符串123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区（我测试的还是在栈上）

char drr[] &#x3D; &quot;123&quot;;
&#x2F;&#x2F;字符数组变量drr在栈区，字符串123也保存在栈区，可以通过drr去修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><h2 id="三、类、抽象、封装、继承、多态"><a href="#三、类、抽象、封装、继承、多态" class="headerlink" title="三、类、抽象、封装、继承、多态"></a>三、类、抽象、封装、继承、多态</h2><h3 id="1-为什么有的析构函数是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#1-为什么有的析构函数是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="1.为什么有的析构函数是虚函数？为什么C++默认的析构函数不是虚函数"></a>1.为什么有的析构函数是虚函数？为什么C++默认的析构函数不是虚函数</h3><h4 id="为什么有的析构函数是虚函数？"><a href="#为什么有的析构函数是虚函数？" class="headerlink" title="为什么有的析构函数是虚函数？"></a>为什么有的析构函数是虚函数？</h4><ul>
<li>如果一个类打算作为基类被继承，那么一定要把这个基类声明virtual析构函数。</li>
<li>因为如果不这么做的话，一旦发生继承时，一旦发生这种情况，base class指针指向了一个derived class对象，并执行delete，而该base class带着一个non-virtual析构函数，通常发生的结果是只有base成分被销毁了，而derived成分没被销毁。这将造成严重的资源泄露。</li>
</ul>
<p>另一种简洁的表述：将可能会被继承的父类（基类）的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<h4 id="为什么C-默认的析构函数不是虚函数"><a href="#为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么C++默认的析构函数不是虚函数"></a>为什么C++默认的析构函数不是虚函数</h4><p>因为<strong>每个多态类有一个虚表</strong>（virtual table），虚表中有当前类的各个虚函数的入口地址，<strong>每个对象有一个指向当前类的虚表的指针</strong>（虚指针vptr）。<strong>它们会占用额外的内存</strong>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<p>其次，将一个普通的类构造为多态类还将影响到代码向其他语言传递（移植）</p>
<h3 id="2-C-中析构函数的作用"><a href="#2-C-中析构函数的作用" class="headerlink" title="2.C++中析构函数的作用"></a>2.C++中析构函数的作用</h3><p>析构函数与构造函数对应，<strong>当对象结束其生命周期</strong>，如对象所在的函数已调用完毕时，<strong>系统会自动执行析构函数</strong>。</p>
<p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>类析构顺序：1）派生类本身的析构函数；2）派生类中对象成员析构函数；3）基类析构函数。</p>
<h3 id="3-请你来说一下静态函数和虚函数的区别"><a href="#3-请你来说一下静态函数和虚函数的区别" class="headerlink" title="3.请你来说一下静态函数和虚函数的区别"></a>3.请你来说一下静态函数和虚函数的区别</h3><ul>
<li>静态函数：<ul>
<li>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但<strong>静态函数只是在声明他的文件当中可见，不能被其他文件所用</strong>。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。</li>
</ul>
</li>
<li>虚函数：<ul>
<li>在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数。C++中的虚函数的作用主要是实现了多态的机制。</li>
</ul>
</li>
<li>区别：<ul>
<li>静态函数（其实普通函数也是如此啊）在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。</li>
</ul>
</li>
</ul>
<h3 id="4-你理解的虚函数和多态（对象中有虚指针，每个类有一个虚表，对象里的虚指针指向虚表，不同的类虚表中存有各个虚函数的入口指针）"><a href="#4-你理解的虚函数和多态（对象中有虚指针，每个类有一个虚表，对象里的虚指针指向虚表，不同的类虚表中存有各个虚函数的入口指针）" class="headerlink" title="4.你理解的虚函数和多态（对象中有虚指针，每个类有一个虚表，对象里的虚指针指向虚表，不同的类虚表中存有各个虚函数的入口指针）"></a>4.你理解的虚函数和多态（对象中有虚指针，每个类有一个虚表，对象里的虚指针指向虚表，不同的类虚表中存有各个虚函数的入口指针）</h3><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态的实现主要分为静态多态和动态多态，</p>
<ul>
<li>静态多态主要是重载（函数重载，运算符重载），在编译的时候就已经确定；</li>
<li>动态多态是用虚函数机制实现的，在运行期间动态绑定。</li>
</ul>
<p>举个例子：一个父类(基类)类型的指针指向一个子类（派生类）对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>为什么运行时可以动态绑定呢？运行时没有编译环境了，只有操作系统，谁帮我们确定该执行哪个函数体呢？</p>
<p>答：其实包含在对象里！对象里的虚指针就决定了它真正应该调用的函数是哪个，而不取决于该对象被什么指针指向（管你是base指针还是derived指针，因为实际上是由对象里的虚指针决定的）。</p>
<p>虚函数的实现：在有虚函数的类中，编译器会为每个<strong>有虚函数的类</strong>创建一个<strong>虚函数表</strong>，该虚函数表将被该类的所有对象共享。虚表指针在类对象中，每个同类对象中都有个一个vptr，指向内存中的vtable，所有同类对象，共享一个vtable，但是<strong>每个对象都自带一个vptr</strong>指向这个vtable,虚表指针是对象的第一个数据成员，虚表指针的初始化发生在构造函数过程中。类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类（派生类）继承了父类（基类）的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>每个多态类（Based、derived）都有一个虚表，基类有基类的虚表，派生类有派生类的虚表，虚表里记录了应该调用的各个虚函数的地址。</p>
</li>
<li><p>每个多态类对象都有一个<strong>虚指针，它指向应该调用的虚表的地址</strong>，通过多态类型的指针或引用调用成员函数时，<strong>通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</strong></p>
</li>
<li><p>虚表</p>
<ul>
<li><strong>每个多态类有一个虚表</strong>（virtual table）</li>
<li>也就是说Base和Derived类都将有自己的虚函数表</li>
<li><strong>虚表中有当前类的各个虚函数的入口地址</strong></li>
<li><strong>每个对象有一个指向当前类的虚表的指针（虚指针vptr）</strong></li>
<li>在编译时，编译器做好虚表，等待运行时查找</li>
</ul>
</li>
<li><p>动态绑定的实现</p>
<ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li>
<li>通过该入口地址调用虚函数。</li>
</ul>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/06/14/NSJHxO.png" alt="NSJHxO.png"></p>
<ul>
<li>Derived类的虚表会覆盖那些重新定义的虚函数，没有重新定义的，那么还是指向基类</li>
<li>所以，<strong>虽然一个Derived对象被Base指针指向，但是该Derived实例（对象）里的虚指针VFT其实仍然指向Derived类的虚函数表，就可以实现运行时多态了。</strong></li>
</ul>
<h4 id="别人的回答"><a href="#别人的回答" class="headerlink" title="别人的回答"></a>别人的回答</h4><p>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象的对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</p>
<h3 id="5-const修饰成员函数的目的是什么？"><a href="#5-const修饰成员函数的目的是什么？" class="headerlink" title="5.const修饰成员函数的目的是什么？"></a>5.const修饰成员函数的目的是什么？</h3><p>const修饰的成员函数表明该函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<p>用const成员函数的两个好处</p>
<ol>
<li>可以从声明看出来，哪个函数可以改动对象内容，而哪个函数不行</li>
<li>const对象只能使用const成员函数。</li>
</ol>
<h3 id="6-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？（本质上是形参为底层const可以重载，形参为顶层const不能重载。因为比如-char-与-char-const，作为形参接受参数时，编译器完全看不出他俩有什么区别）"><a href="#6-如果同时定义了两个函数，一个带const，一个不带，会有问题吗？（本质上是形参为底层const可以重载，形参为顶层const不能重载。因为比如-char-与-char-const，作为形参接受参数时，编译器完全看不出他俩有什么区别）" class="headerlink" title="6.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？（本质上是形参为底层const可以重载，形参为顶层const不能重载。因为比如 char*  与 char* const，作为形参接受参数时，编译器完全看不出他俩有什么区别）"></a>6.如果同时定义了两个函数，一个带const，一个不带，会有问题吗？（本质上是形参为底层const可以重载，形参为顶层const不能重载。因为比如 char*  与 char* const，作为形参接受参数时，编译器完全看不出他俩有什么区别）</h3><ul>
<li><p>当这两个函数作为普通的函数时，编译会报错，因为无法仅按返回类型区分两个函数</p>
<ul>
<li>如果函数名相同，在相同的作用域内，其参数类型、参数个数，参数顺序不同等能构成函数重载。</li>
<li>换句话说，各个重载函数的形参必须不同:即 类型不同 或 个数不同。</li>
</ul>
</li>
<li><p>当这两个函数作为类的成员函数时，const关键字可以被用于参与对重载函数的区分</p>
<ul>
<li>如果同时在类中，对于函数名相同参数列表也相同的成员函数的const函数和非const函数能够构成重载。</li>
<li>它们被调用的时机为：如果定义的对象是常对象，则调用的是const成员函数，如果定义的对象是非常对象，则调用重载的非const成员函数。</li>
<li>如果是非常对象，某个成员函数仅有const版本，这也是可以调用的</li>
</ul>
</li>
<li><p>其实本质上是，形参是底层const可以重载，形参为顶层const则不能重载。因为比如 char*  与 char* const，作为形参接受参数时，编译器完全看不出他俩有什么区别</p>
<ul>
<li><p>所以，两个函数作为类的成员函数时，const关键字修饰的其实是this指针，你无法通过这个指针来修改对象，也就意味着，它是一个底层const指针。所以是形参是底层const指针的函数，和形参是非const指针之间的重载。</p>
</li>
<li><p>换句话说，两个函数，如果形参是顶层const指针和非const指针的区别，那么不能重载</p>
</li>
<li><p>两个函数，如果形参是底层const指针和非const指针的区别，那么可以重载</p>
</li>
<li><pre><code class="c++">void testfunc(const char* a) &#123; cout &lt;&lt; &quot;底层const&quot;&lt;&lt; endl; &#125;
void testfunc(char* a) &#123; cout &lt;&lt; &quot;非const&quot; &lt;&lt; endl; &#125;
//void testfunc(char* const a) &#123; cout &lt;&lt; &quot;顶层const&quot; &lt;&lt; endl; &#125;//它与testfunc(char* a)冲突了
//void testfunc(const char* const a) &#123; cout &lt;&lt; &quot;底层and顶层const&quot; &lt;&lt; endl; &#125;//它与testfunc(const char* a)冲突了，换句话说，char*与char* const毫无区分度
int main()
&#123;
    testfunc(&quot;123&quot;);//输出：底层const
    char yyd[] = &quot;123&quot;;
    testfunc(yyd);//输出：非const
    return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
&#96;&#96;&#96;c++
&#x2F;&#x2F;这两个也是不能重载的，把你当做编译器，来判断一下，传入实参过来，两个形参有没有差别就知道了。
void fun(int a) &#123;&#125;
void fun(const int a)&#123;&#125;&#x2F;&#x2F;不能重载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="7-C-中拷贝复制构造和拷贝赋值函数的形参能否进行值传递？"><a href="#7-C-中拷贝复制构造和拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="7.C++中拷贝复制构造和拷贝赋值函数的形参能否进行值传递？"></a>7.C++中拷贝复制构造和拷贝赋值函数的形参能否进行值传递？</h3><h4 id="1-对于拷贝复制构造函数-不能进行值传递，只能使用引用，const不const都行"><a href="#1-对于拷贝复制构造函数-不能进行值传递，只能使用引用，const不const都行" class="headerlink" title="1.对于拷贝复制构造函数(不能进行值传递，只能使用引用，const不const都行)"></a>1.对于拷贝复制构造函数(不能进行值传递，只能使用引用，const不const都行)</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 拷贝构造函数原型
Person( Person&amp; );  &#x2F;&#x2F; method 1
Person( const Person&amp; );  &#x2F;&#x2F; method 2

&#x2F;&#x2F; 下面这种原型是错的
Person( Person );  &#x2F;&#x2F; 不能进行值传递，只能传递引用，这样写会报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不能进行值传递的原因：如果自身参数不是引用，则永远不会调用成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又必须调用拷贝构造函数，如此无限循环。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person&#123;
public:
    Person(int i&#x3D;0):test(i)&#123;&#125;;
    Person(Person x):test(x.test)&#123;&#125;;&#x2F;&#x2F;它肯定不能通过编译，假若可以，我们思考一下
    int test;
&#125;

int main()&#123;
    
    Person temp(1);
    Person temp2(temp);&#x2F;&#x2F;调用复制构造函数
    &#x2F;&#x2F;你想要构造temp2，调用这个函数Person(Person x):test(x.test)&#123;&#125;。
    &#x2F;&#x2F;那么首先就得调用复制构造函数将实参temp复制构造到形参Person x吧，
    &#x2F;&#x2F;那么这个复制构造形参的过程即 Person x(temp)，又要调用这个函数Person(Person x):test(x.test)&#123;&#125;。
    &#x2F;&#x2F;那你又得把实参temp复制构造到形参Person x吧，
    &#x2F;&#x2F;那么这个复制构造形参的过程即 Person x(temp)，又要调用这个函数Person(Person x):test(x.test)&#123;&#125;
    &#x2F;&#x2F;.....循环往复，会形成递归调用栈溢出
    &#x2F;&#x2F;问题就出在，你本想复制构造一个对象，然而实参到形参的过程也是一个复制构造，将无限循环下去
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-对于拷贝赋值函数（能进行值传递，就只是多一个额外的实参到形参的一次复制拷贝）"><a href="#2-对于拷贝赋值函数（能进行值传递，就只是多一个额外的实参到形参的一次复制拷贝）" class="headerlink" title="2.对于拷贝赋值函数（能进行值传递，就只是多一个额外的实参到形参的一次复制拷贝）"></a>2.对于拷贝赋值函数（能进行值传递，就只是多一个额外的实参到形参的一次复制拷贝）</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 一般的拷贝赋值函数原型
Person&amp; operator&#x3D;( const Person&amp; x);

&#x2F;&#x2F;但是值传递也没错
Person&amp; operator&#x3D;(Person x)&#x2F;&#x2F;仅仅是多了实参到形参的一次复制拷贝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用，这样就可以实现连等的功能（a &#x3D; b &#x3D; c）</p>
<p>为了验证我们的猜测（能进行值传递），我们做了一下验证，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person &#123;
public:
	Person(int a &#x3D; 0) :test(a) &#123; cout &lt;&lt; &quot;普通构造&quot; &lt;&lt; endl; &#125;;
	Person(const Person&amp; x) :test(x.test) &#123; cout &lt;&lt; &quot;复制构造&quot; &lt;&lt; endl; &#125;;
	Person&amp; operator&#x3D;(Person x) &#123; test &#x3D; x.test; cout &lt;&lt; &quot;赋值函数&quot; &lt;&lt; endl;; return *this; &#125;
	int test;
&#125;;

int main()
&#123;
	Person a(100);&#x2F;&#x2F;普通构造
	Person b;&#x2F;&#x2F;普通构造
	b &#x3D; a;&#x2F;&#x2F;复制构造 (赋值函数的实参传形参中发生)
			&#x2F;&#x2F;赋值函数
	cout &lt;&lt; a.test &lt;&lt; endl;&#x2F;&#x2F;100
	cout &lt;&lt; b.test &lt;&lt; endl;&#x2F;&#x2F;100
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-给你一个类，里面有static成员，virtual函数，虚函数表等，说说他们的内存位置"><a href="#8-给你一个类，里面有static成员，virtual函数，虚函数表等，说说他们的内存位置" class="headerlink" title="8.给你一个类，里面有static成员，virtual函数，虚函数表等，说说他们的内存位置"></a>8.给你一个类，里面有static成员，virtual函数，虚函数表等，说说他们的内存位置</h3><h4 id="0-类对象内存分布"><a href="#0-类对象内存分布" class="headerlink" title="0.类对象内存分布"></a>0.类对象内存分布</h4><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new&#x2F;malloc动态申请的，则该类数据存储在堆区。</p>
<h4 id="1-static修饰符"><a href="#1-static修饰符" class="headerlink" title="1.static修饰符"></a>1.static修饰符</h4><ul>
<li>static修饰成员变量<ul>
<li>对于非静态数据成员，每个类对象都有自己的拷贝。</li>
<li>而静态数据成员被当做是类的成员，无论这个类被定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。</li>
<li><strong>因为静态数据成员在全局数据区（静态区，bss段和data段）分配内存</strong>，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。</li>
<li><strong>类的静态数据成员必须在类外定义和初始化</strong>，用(::)来指明所属的类。</li>
</ul>
</li>
<li>static修饰成员函数<ul>
<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>
<li>静态成员函数主要用于处理该类的静态数据成员。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。</li>
<li>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的静态成员函数。</li>
<li>如果静态成员函数中要引用非静态成员时，可通过参数传递的方式得到对象名，然后再通过对象名来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>
<li><strong>Static修饰的成员函数，在代码区分配内存。</strong></li>
</ul>
</li>
</ul>
<h4 id="2-virtual修饰符"><a href="#2-virtual修饰符" class="headerlink" title="2.virtual修饰符"></a>2.virtual修饰符</h4><ul>
<li>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new&#x2F;malloc动态申请的，则该类数据存储在堆区。</li>
<li>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。</li>
<li>如果类中成员是virtual属性，会隐藏父类对应的属性。</li>
</ul>
<p><img src="https://i.loli.net/2020/09/21/RYCvAJWMU1tych8.png" alt="image.png"></p>
<p>假如初始化方式是 A* obj&#x3D;new A;</p>
<ul>
<li>指针变量obj在栈</li>
<li>对象A的实例在堆<ul>
<li>对象A里有虚指针（存的地址指向虚表，即常量区地址，因为虚表存在roadata），各种成员变量等等（这些都存在堆里）</li>
</ul>
</li>
<li>虚指针指向某个类（基类或者某派生类）虚表，<strong>虚表存在c++中内存五区的常量存储区（对应rodata段）</strong><ul>
<li>虚表中存着各虚函数的入口指针（各指针地址指向代码区，因为各虚函数函数存在代码区text）</li>
</ul>
</li>
<li>各虚函数存在代码区<ul>
<li>text段</li>
</ul>
</li>
</ul>
<h4 id="3-特别说一下虚函数表的位置"><a href="#3-特别说一下虚函数表的位置" class="headerlink" title="3.特别说一下虚函数表的位置"></a>3.特别说一下虚函数表的位置</h4><ul>
<li>虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中(rodata)，对应于c++中内存五区的常量存储区（文字常量区）</li>
</ul>
<h3 id="8-请你来说一下C-中类成员的访问权限"><a href="#8-请你来说一下C-中类成员的访问权限" class="headerlink" title="8.请你来说一下C++中类成员的访问权限"></a>8.请你来说一下C++中类成员的访问权限</h3><p><strong>类的一个特征就是封装，public和private作用就是实现这一目的</strong>。</p>
<p><strong>类的另一个特征就是继承，protected的作用就是实现这一目的</strong>。</p>
<h4 id="1-类内和友元函数可以访问所有权限，类外只可以访问public权限的成员"><a href="#1-类内和友元函数可以访问所有权限，类外只可以访问public权限的成员" class="headerlink" title="1.类内和友元函数可以访问所有权限，类外只可以访问public权限的成员"></a>1.类内和友元函数可以访问所有权限，类外只可以访问public权限的成员</h4><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p>
<ul>
<li><p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</p>
</li>
<li><p>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
</li>
<li><p>举例：</p>
<p>- </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A&#123;
public:
  int a;
  A()&#123;
    a1 &#x3D; 1;
    a2 &#x3D; 2;
    a3 &#x3D; 3;
    a &#x3D; 4;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F;正确
    cout &lt;&lt; a1 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a2 &lt;&lt; endl;   &#x2F;&#x2F;正确，类内访问
    cout &lt;&lt; a3 &lt;&lt; endl;   &#x2F;&#x2F;正确，类内访问
  &#125;
public:
  int a1;
protected:
  int a2;
private:
  int a3;
&#125;;
int main()&#123;
  A itema;
  itema.a &#x3D; 10;    &#x2F;&#x2F;正确
  itema.a1 &#x3D; 20;    &#x2F;&#x2F;正确
  itema.a2 &#x3D; 30;    &#x2F;&#x2F;错误，类外（即对象）不能访问protected成员
  itema.a3 &#x3D; 40;    &#x2F;&#x2F;错误，类外（即对象）不能访问private成员
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="2-具体地解析3个权限的区别（private仅限类内（或者友元）访问，public类内外都可以访问，protected与priavate的区别仅在于继承时子类可以访问protected但不能访问private）"><a href="#2-具体地解析3个权限的区别（private仅限类内（或者友元）访问，public类内外都可以访问，protected与priavate的区别仅在于继承时子类可以访问protected但不能访问private）" class="headerlink" title="2.具体地解析3个权限的区别（private仅限类内（或者友元）访问，public类内外都可以访问，protected与priavate的区别仅在于继承时子类可以访问protected但不能访问private）"></a>2.具体地解析3个权限的区别（private仅限类内（或者友元）访问，public类内外都可以访问，protected与priavate的区别仅在于继承时子类可以访问protected但不能访问private）</h4><ul>
<li>private：<ul>
<li>只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象（也就是类外）也不能访问。</li>
<li><strong>派生类（子类）也无法访问</strong></li>
<li>完全是自己的，只能自己用，谁都不能用，好比一个人身体、四肢；</li>
</ul>
</li>
<li>protected： 可以被该类中的函数、其友元函数、其<strong>派生类（子类）内部可以访问</strong>，但不能被该类的对象（也就是类外）访问。<ul>
<li>protected成员与private的区别仅限于继承时，子类能否使用</li>
<li>仅限自己和自己的儿子以及儿子的儿子的儿子……使用的一些东西</li>
</ul>
</li>
<li>public: 可以被该类中的函数、其友元函数、派生类（子类）内部可以访问，也可以由该类的对象（也就是类外）访问。<ul>
<li>通常是功能，好比一个人的工作，比如程序员，老板让程序员写代码，写代码（）就是程序员的一个功能，并且是public 的，可以被老板调用，但是程序员写代码的时候要用到自己private的东西，比如两只手；</li>
</ul>
</li>
</ul>
<h4 id="3-三种继承方式的特点（3个权限和3个继承方式这是两码事）"><a href="#3-三种继承方式的特点（3个权限和3个继承方式这是两码事）" class="headerlink" title="3.三种继承方式的特点（3个权限和3个继承方式这是两码事）"></a>3.三种继承方式的特点（3个权限和3个继承方式这是两码事）</h4><p>先记住：不管是否继承，上面的规则（即类内和友元开放所有权限，类外只可以访问public权限的成员）永远适用！</p>
<p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<p><strong>继承之后的属性变换：</strong></p>
<p><strong>1.public继承：</strong>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：public, protected, private</p>
<p><strong>2.protected继承：</strong>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：protected, protected, private</p>
<p><strong>3.private继承：</strong>基类public成员，protected成员，private成员的访问属性在派生类中分别变成：private, private, private</p>
<p>但无论哪种继承方式，上面两点都没有改变：</p>
<p><strong>1.private成员只能被本类成员（类内）和友元访问，不能被派生类内部访问；</strong></p>
<p><strong>2.protected、public成员（以继承前为准）可以被派生类内部访问。</strong></p>
<p><strong>3.至于类外能否访问，那么请自行判断继承以后的权限，然后继续按照类外只可以访问public权限的成员的规则即可</strong></p>
<h5 id="1-public继承（is-a关系，每一个derived对象同时也是一个base对象）"><a href="#1-public继承（is-a关系，每一个derived对象同时也是一个base对象）" class="headerlink" title="1.public继承（is-a关系，每一个derived对象同时也是一个base对象）"></a>1.public继承（is-a关系，每一个derived对象同时也是一个base对象）</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;

class A&#123;
public:
  int a;
  A()&#123;
    a1 &#x3D; 1;
    a2 &#x3D; 2;
    a3 &#x3D; 3;
    a &#x3D; 4;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F;正确
    cout &lt;&lt; a1 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a2 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a3 &lt;&lt; endl;   &#x2F;&#x2F;正确
  &#125;
public:
  int a1;
protected:
  int a2;
private:
  int a3;
&#125;;
class B : public A&#123;
public:
  int a;
  B(int i)&#123;
    A();
    a &#x3D; i;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;       &#x2F;&#x2F;正确，public成员
    cout &lt;&lt; a1 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类的public成员，在派生类中仍是public成员。
    cout &lt;&lt; a2 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       &#x2F;&#x2F;错误，基类的private成员不能被派生类访问。
  &#125;
&#125;;
int main()&#123;
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;
  cout &lt;&lt; b.a1 &lt;&lt; endl;   &#x2F;&#x2F;正确
  cout &lt;&lt; b.a2 &lt;&lt; endl;   &#x2F;&#x2F;错误，类外不能访问protected成员
  cout &lt;&lt; b.a3 &lt;&lt; endl;   &#x2F;&#x2F;错误，类外不能访问private成员
  system(&quot;pause&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-protected继承：（关系不明确）"><a href="#2-protected继承：（关系不明确）" class="headerlink" title="2.protected继承：（关系不明确）"></a>2.protected继承：（关系不明确）</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A&#123;
public:
  int a;
  A()&#123;
    a1 &#x3D; 1;
    a2 &#x3D; 2;
    a3 &#x3D; 3;
    a &#x3D; 4;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F;正确
    cout &lt;&lt; a1 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a2 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a3 &lt;&lt; endl;   &#x2F;&#x2F;正确
  &#125;
public:
  int a1;
protected:
  int a2;
private:
  int a3;
&#125;;
class B : protected A&#123;
public:
  int a;
  B(int i)&#123;
    A();
    a &#x3D; i;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;       &#x2F;&#x2F;正确，public成员。
    cout &lt;&lt; a1 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。
    cout &lt;&lt; a2 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       &#x2F;&#x2F;错误，基类的private成员不能被派生类访问。
  &#125;
&#125;;
int main()&#123;
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;       &#x2F;&#x2F;正确。public成员
  cout &lt;&lt; b.a1 &lt;&lt; endl;      &#x2F;&#x2F;错误，protected成员不能在类外访问。
  cout &lt;&lt; b.a2 &lt;&lt; endl;      &#x2F;&#x2F;错误，protected成员不能在类外访问。
  cout &lt;&lt; b.a3 &lt;&lt; endl;      &#x2F;&#x2F;错误，private成员不能在类外访问。
  system(&quot;pause&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="3-private继承：（含义：implemented-in-tems-of，derived对象根据base对象实现而得）"><a href="#3-private继承：（含义：implemented-in-tems-of，derived对象根据base对象实现而得）" class="headerlink" title="3.private继承：（含义：implemented-in-tems-of，derived对象根据base对象实现而得）"></a>3.private继承：（含义：implemented-in-tems-of，derived对象根据base对象实现而得）</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;assert.h&gt;
using namespace std;
class A&#123;
public:
  int a;
  A()&#123;
    a1 &#x3D; 1;
    a2 &#x3D; 2;
    a3 &#x3D; 3;
    a &#x3D; 4;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F;正确
    cout &lt;&lt; a1 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a2 &lt;&lt; endl;   &#x2F;&#x2F;正确
    cout &lt;&lt; a3 &lt;&lt; endl;   &#x2F;&#x2F;正确
  &#125;
public:
  int a1;
protected:
  int a2;
private:
  int a3;
&#125;;
class B : private A&#123;
public:
  int a;
  B(int i)&#123;
    A();
    a &#x3D; i;
  &#125;
  void fun()&#123;
    cout &lt;&lt; a &lt;&lt; endl;       &#x2F;&#x2F;正确，public成员。
    cout &lt;&lt; a1 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类public成员,在派生类中变成了private,可以被派生类访问。
    cout &lt;&lt; a2 &lt;&lt; endl;       &#x2F;&#x2F;正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。
    cout &lt;&lt; a3 &lt;&lt; endl;       &#x2F;&#x2F;错误，基类的private成员不能被派生类访问。
  &#125;
&#125;;
int main()&#123;
  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;       &#x2F;&#x2F;正确。public成员
  cout &lt;&lt; b.a1 &lt;&lt; endl;      &#x2F;&#x2F;错误，private成员不能在类外访问。
  cout &lt;&lt; b.a2 &lt;&lt; endl;      &#x2F;&#x2F;错误, private成员不能在类外访问。
  cout &lt;&lt; b.a3 &lt;&lt; endl;      &#x2F;&#x2F;错误，private成员不能在类外访问。
  system(&quot;pause&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>所以派生类包含了基类所有成员以及新增的成员，同名的成员被隐藏起来，调用的时候只会调用派生类中的成员。</p>
<p>如果要调用基类的同名成员，可以用以下方法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int main()&#123;

  B b(10);
  cout &lt;&lt; b.a &lt;&lt; endl;
  cout &lt;&lt; b.A::a &lt;&lt; endl;

  system("pause");
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="9-C-类内可以定义引用数据成员吗？"><a href="#9-C-类内可以定义引用数据成员吗？" class="headerlink" title="9.C++类内可以定义引用数据成员吗？"></a>9.C++类内可以定义引用数据成员吗？</h3><p>可以，必须通过成员函数初始化列表初始化。</p>
<p>必须初始化列表初始化的原因是，因为引用在声明时必须同时初始化。你想在大括号里a&#x3D;b，这是不行的。</p>
<p>C++类内的引用数据成员以及const常量都只能通过构造函数的初始化列表进行初始化，因为一旦进入构造函数函数体内部，就不再是初始化操作而是赋值操作，引用数据成员和const常量都是不能进行赋值操作的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;
public:
    A(int&amp; b) :a(b) &#123;&#125;
    int&amp; a;
&#125;;
int main()
&#123;
    int b &#x3D; 10;
    A test(b);
    cout &lt;&lt; test.a &lt;&lt; endl;&#x2F;&#x2F;10
    cout&lt;&lt;&amp;test&lt;&lt;endl;&#x2F;&#x2F;0x7ffffffedca0
    
    cout &lt;&lt; &amp;(test.a) &lt;&lt; endl;&#x2F;&#x2F;0x7ffffffedc9c
    cout &lt;&lt; &amp;b &lt;&lt; endl;&#x2F;&#x2F;0x7ffffffedc9c，两个变量地址一样
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="10-必须采用初始化列表的三种情况："><a href="#10-必须采用初始化列表的三种情况：" class="headerlink" title="10.必须采用初始化列表的三种情况："></a>10.必须采用初始化列表的三种情况：</h3><h4 id="1-总体概括"><a href="#1-总体概括" class="headerlink" title="1.总体概括"></a>1.总体概括</h4><ul>
<li><p>情况一、需要初始化的数据成员是<strong>对象</strong>的情况</p>
<ul>
<li>数据成员是对象，并且这个对象<strong>只有含参数的构造函数，没有无参数的构造函数；</strong>那么只能列表初始化</li>
</ul>
</li>
<li><p>情况二、需要<strong>初始化const</strong>修饰的类成员<strong>或初始化引用</strong>成员数据；</p>
<ul>
<li>当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，<strong>因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。</strong></li>
</ul>
</li>
<li><p>情况三、<strong>子类初始化父类的成员</strong>，需要在(并且也<strong>只能在)参数初始化列表中显示调用父类的构造函数</strong>；</p>
<ul>
<li><p><strong>不论父类的public还是protected、private成员，你在子类中想要初始化，只能通过父类的构造函数。而不能自行列表初始化</strong></p>
<ul>
<li>解释：因为初始化列表中，才进行初始化父类，子类可以理解为还没有继承到父类的成员。只有进入构造函数内部，才继承到了。继承到以后才可以访问</li>
</ul>
</li>
<li><p><strong>父类的public和protected与private成员不同的是，虽然3种类型的成员都不能自行构造，但是父类的public和proteted成员可以在子类构造函数内部被访问赋值。</strong></p>
</li>
<li><pre><code class="c++">//错误示范
class Test &#123;//父类
public:
    Test() &#123;&#125;;
    Test(int x) &#123; data_private = x; &#125;
    void show() &#123; cout &lt;&lt; data_private &lt;&lt; endl; cout &lt;&lt; data_protected &lt;&lt; endl; &#125;
    int data_public;
protected:
    int data_protected;
private:
    int data_private;
&#125;;
class Mytest :public Test &#123;//子类
public:
    Mytest() :Test(10),data_protected(100),data_public(1000) &#123;//错误！！！报错说Mytest里没有成员data_protected、data_public
        
        //不论父类的public还是protected、private成员，你在子类中想要初始化，只能通过父类的构造函数。而不能自行列表初始化
        //public和protected与private成员不同的是，虽然3种类型的成员都不能自行构造，但是public和proteted成员可以在构造函数内部被访问赋值。
    &#125;
&#125;;


//正确示范
class Test &#123;//父类
public:
    Test() &#123;&#125;;
    Test(int x) &#123; data_private = x; &#125;
    void show() &#123; cout &lt;&lt; data_private &lt;&lt; endl; cout &lt;&lt; data_protected &lt;&lt; endl; &#125;
    int data_public;
protected:
    int data_protected;
private:
    int data_private;
&#125;;
class Mytest :public Test &#123;//子类
public:
    Mytest() :Test(10) &#123;
        data_protected = 100;//data_protected其实在列表初始化阶段就构造了，这是赋值而已
        data_public = 1000;//data_public其实在列表初始化阶段就构造了，这是赋值而已
    &#125;
&#125;;
int main()
&#123;
    Test* p = new Mytest();
    p-&gt;show();
    cout &lt;&lt; p-&gt;data_public &lt;&lt; endl;
    delete p;
    return 0;
&#125;
//10
//100
//1000
<pre class="line-numbers language-none"><code class="language-none">
    

#### 2.实际例子

- 情况一的例子

  - 数据成员是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数；

  - 如果我们有一个类成员（比如Mytest类里的private成员test），它本身是一个类（Test类）或者是一个结构，而且这个成员它只有一个带参数的构造函数，而**没有默认构造函数（就是不需要实参的构造函数）**，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。

  - &#96;&#96;&#96;c++
    #include &quot;iostream&quot;
    using namespace std;
    class Test
    &#123;
     public:
        Test (int, int, int)&#123;
        cout &lt;&lt;&quot;Test&quot; &lt;&lt; endl;
     &#125;;
     private:
        int x;
        int y;
        int z;
    &#125;;
    class Mytest 
    &#123;
     public:
        Mytest():test(1,2,3)&#123;       &#x2F;&#x2F;必须使用列表初始化！因为Test类没有默认构造函数，只能在这里进行构造。如果有默认构造函数的话，那么可以写在大括号里，此时将默认构造test，再在构造函数内部进行赋值操作
        cout &lt;&lt; &quot;Mytest&quot; &lt;&lt; endl;
        &#125;;
    private:
        Test test; &#x2F;&#x2F;声明
    &#125;;
    int _tmain(int argc, _TCHAR* argv[])
    &#123;
     Mytest test;
     return 0;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
<li><p>情况二的例子</p>
<ul>
<li><p>需要<strong>初始化const</strong>修饰的类成员<strong>或初始化引用</strong>成员数据</p>
</li>
<li><p>当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，<strong>因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。</strong></p>
</li>
<li><pre><code class="c++">//1.类成员包含const对象
class Test
&#123;
 priate:
    const int a;             //const成员声明
 public:
    Test():a(10)&#123;&#125;           //必须列表初始化
&#125;;
//2.类成员包含引用对象
class Test
&#123;
 private:
     int &amp;a;                        //声明
 public:
     Test(int a):a(a)&#123;&#125;        //必须列表初始化
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- 情况三的例子

  - 子类初始化父类的私有成员，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数：

  - &#96;&#96;&#96;c++
    class Test&#123;&#x2F;&#x2F;父类
    public:
        Test()&#123;&#125;;
        Test (int x)&#123; int_x &#x3D; x;&#125;
        void show()&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;
    private:
        int int_x;
    &#125;;
    class Mytest:public Test&#123;&#x2F;&#x2F;子类
    public:
        Mytest() ：Test(110)&#123;&#x2F;&#x2F;子类初始化父类的私有成员，只能在参数初始化列表中显示调用父类的构造函数
          &#x2F;&#x2F;Test(110);            &#x2F;&#x2F;  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用
        &#125;
    &#125;;
    int _tmain(int argc, _TCHAR* argv[])
    &#123;
     Test *p &#x3D; new Mytest();
     p-&gt;show();
     return 0;
    &#125;
    &#x2F;&#x2F;结果：如果在构造函数内部被显示调用，而没有初始化列表的话。输出结果是：-842150451（原因是这里调用了无参构造函数初始化了父对象，而内部那句Test(100)仅仅是一个临时对象而已）；
    &#x2F;&#x2F;     如果在初始化列表中被显示调用输出结果是：110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="11-C-中struct和class的区别"><a href="#11-C-中struct和class的区别" class="headerlink" title="11.C++中struct和class的区别"></a>11.C++中struct和class的区别</h3><h4 id="1-struct与class区别"><a href="#1-struct与class区别" class="headerlink" title="1.struct与class区别"></a>1.struct与class区别</h4><p>在C++中，结构体是一种特殊形态的类。</p>
<p>结构体和类的<strong>唯一</strong>区别就是：  结构体和类具有不同的默认访问控制属性。</p>
<ul>
<li>　<strong>类中，对于未指定访问控制属性的成员，其访问控制属性为私有类型（private）</strong></li>
<li>　<strong>结构体中，对于未指定任何访问控制属性的成员，其访问控制属性为公有类型（public）</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Test1 &#123;
    int a;&#x2F;&#x2F;默认public
&#125;;

class Test2 &#123;
    int b;&#x2F;&#x2F;默认private
&#125;;

int main()
&#123;
    Test1 yyd1;
    Test2 yyd2;
    yyd1.a &#x3D; 1;
    yyd2.b &#x3D; 2;&#x2F;&#x2F;error！成员b不可访问
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>还有一个微小的区别：（这其实也可以从默认访问权限推断而知）</p>
<ul>
<li>struct继承其他类的时候，如果不写继承级别，则默认是public 继承。</li>
<li>class则默认private 继承。只是一般情况下我们不会省略继承级别关键字。</li>
</ul>
<p>但实际上，我们一般都会写上继承类型而不会默认（public、protected、private继承）</p>
<h4 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h4><p>注意，在C++中，struct跟class其实没有太大区别，struct也有构造函数、析构函数。也可以自定义函数成员。也可以加上访问权限public、protected、private。也可以继承。</p>
<p>示例，把struct关键字换成class都没有问题（当然得记得加上public，因为class默认是private）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
 
struct Person
&#123;
  Person(std::string name);
  std::string greet(std::string other_name);
  std::string m_name;
&#125;;
 
Person::Person(std::string name)
&#123;
    m_name &#x3D; name;
&#125;
 
std::string Person::greet(std::string other_name)
&#123;
    return &quot;Hi &quot; + other_name + &quot;, my name is &quot; + m_name;
&#125;
 
int main()
&#123;
    Person m_person(&quot;JANE&quot;);
    std::string str &#x3D; m_person.greet(&quot;JOE&quot;);
    std::cout&lt;&lt;str&lt;&lt;std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-C-与C中的struct区别"><a href="#3-C-与C中的struct区别" class="headerlink" title="3.C++与C中的struct区别"></a>3.C++与C中的struct区别</h4><p><strong>C++中保留结构的原因：</strong></p>
<ul>
<li>C语言结构体的目的是使用结构体将不同类型数据组成整体，方便于保存数据。</li>
<li>C++之所以要引入结构体，是为了保持和C程序的兼容性。<ul>
<li>C++在struct之外引入了class关键字，但为了保持与C程序的兼容，C++保留了struct关键字，并规定结构体默认访问控制权限为公有类型。</li>
</ul>
</li>
</ul>
<p><strong>C++与C中的struct区别区别：</strong></p>
<ul>
<li><p>C++为C语言中的结构体引入了成员函数、访问控制权限、继承、包含多态等面向对象特性。</p>
</li>
<li><p>另外，C语言中，空结构体的大小为0，而C++中空结构体（属于空类）的大小为1。</p>
<ul>
<li><p>C++中空类的大小为1的原因：</p>
<ul>
<li>空类也可以实例化，类实例化出的每个对象都需要有不同的内存地址，为使每个对象在内存中的地址不同，所以在类中会加入一个隐含的字节。</li>
</ul>
</li>
<li><p>实测：</p>
<ul>
<li><pre><code class="c">#include &lt;stdio.h&gt;
 
struct A
&#123;
&#125;aa;
 
 
int main()
&#123;
        printf(&quot;%ld\n&quot;, sizeof(struct A));
        printf(&quot;%ld\n&quot;, sizeof(aa));
        return 0;
&#125;
<pre class="line-numbers language-none"><code class="language-none">
- &#96;&#96;&#96;shell
  &#x2F;&#x2F;用gcc编译并执行
  yangyadong@DESKTOP-UTDHAA6:~&#x2F;myproject$ gcc yyd.c -o yyd &amp;&amp; .&#x2F;yyd
  0
  0
  &#x2F;&#x2F;用g++编译并执行    
  yangyadong@DESKTOP-UTDHAA6:~&#x2F;myproject$ g++ yyd.c -o yyd &amp;&amp; .&#x2F;yyd
  1
  1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="四、linux"><a href="#四、linux" class="headerlink" title="四、linux"></a>四、linux</h2><h3 id="1-请你来说一下fork函数"><a href="#1-请你来说一下fork函数" class="headerlink" title="1.请你来说一下fork函数"></a>1.请你来说一下fork函数</h3><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main(void)
&#123;
    pid_t pid;
    signal(SIGCHLD, SIG_IGN);
    printf(&quot;before fork pid:%d\n&quot;, getpid());
    int abc &#x3D; 10;
    pid &#x3D; fork();&#x2F;&#x2F;fork()一个进程
	if(pid&#x3D;&#x3D;-1)&#x2F;&#x2F;错误返回
    &#123;
        perror(&quot;tile&quot;);
		return -1;
    &#125;
    if(pid&gt;0)    &#x2F;&#x2F;父进程空间
    &#123;
       abc++;
        printf(&quot;parent:pid:%d \n&quot;, getpid());
        printf(&quot;abc:%d \n&quot;, abc);
        sleep(20); 
    &#125;
    else if(pid&#x3D;&#x3D;0)&#x2F;&#x2F;子进程空间
    &#123;
        abc++;
		printf(&quot;child:%d,parent: %d\n&quot;, getpid(), getppid());
		printf(&quot;abc:%d&quot;, abc);	
    &#125;
    
    printf(&quot;fork after...\n&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-请你说一说select（还不会）"><a href="#2-请你说一说select（还不会）" class="headerlink" title="2.请你说一说select（还不会）"></a>2.请你说一说select（还不会）</h3><h3 id="3-请你说说fork-wait-exec函数（）"><a href="#3-请你说说fork-wait-exec函数（）" class="headerlink" title="3.请你说说fork,wait,exec函数（）"></a>3.请你说说fork,wait,exec函数（）</h3><h4 id="1-fork"><a href="#1-fork" class="headerlink" title="1.fork()"></a>1.fork()</h4><h2 id="五、编译与底层"><a href="#五、编译与底层" class="headerlink" title="五、编译与底层"></a>五、编译与底层</h2><h3 id="1-请你来说一下一个C-源文件从文本到可执行文件经历的过程？"><a href="#1-请你来说一下一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="1.请你来说一下一个C++源文件从文本到可执行文件经历的过程？"></a>1.请你来说一下一个C++源文件从文本到可执行文件经历的过程？</h3><h4 id="简略版"><a href="#简略版" class="headerlink" title="简略版"></a>简略版</h4><p>对于C++源文件，从文本到可执行文件一般需要四个过程：</p>
<ul>
<li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li>
<li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件<ul>
<li>c代码到汇编代码</li>
</ul>
</li>
<li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件<ul>
<li>汇编代码到机器码</li>
</ul>
</li>
<li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li>
</ul>
<h4 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h4><p><strong>1）预编译</strong>(.c到.i)</p>
<p><strong>主要处理源代码文件中的以“#”开头的预编译指令</strong>。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。</p>
<p>4、删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。</p>
<p>7、预编译之后生成的xxx.i或xxx.ii文件</p>
<p><strong>2）编译</strong>(.i到.s)</p>
<p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码.s文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p><strong>3）汇编</strong>（.s到.o）</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。</p>
<p><strong>4）链接</strong>(.o +(其他.o)+ .lib  + .dll到.exe)</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p>1、静态链接：.lib     (.a)</p>
<p>函数和数据被编译进一个二进制文件。在使用<strong>静态库(.lib)<strong>的情况下，在编译链接可执行文件时，</strong>链接器从库中复制这些函数和数据</strong>并把它们<strong>和应用程序的其它模块组合起来创建最终的可执行文件。</strong></p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是<strong>静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</strong></p>
<p>2、动态链接：.dll    (.so)</p>
<p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，<strong>在程序运行时才将它们链接在一起形成一个完整的程序</strong>，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h3 id="2-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#2-请你来回答一下include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="2.请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>2.请你来回答一下include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h3><p>双引号与尖括号的区别：<br>编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用<strong>双引号</strong>的头文件，查找头文件路径的顺序为：</p>
<ul>
<li><p>1.当前头文件目录</p>
</li>
<li><p>2.编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<ul>
<li><p>如果想在指定路径下检索头文件，可加选项-I。如&#x2F;home&#x2F;Desktop目录下有个头文件local1.h，在编译包含local1.h的test.c文件时，可用：</p>
</li>
<li><pre><code class="shell">gcc test.c -o test -I /root/Desktop
</code></pre>
</li>
</ul>
</li>
<li><p>3.系统变量CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH指定的头文件路径</p>
<ul>
<li>即标准的系统头文件路径</li>
</ul>
</li>
</ul>
<p>对于使用<strong>尖括号</strong>包含的头文件，查找头文件的路径顺序为：（少了查找当前头文件目录这一步）</p>
<ul>
<li>1.编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</li>
<li>2.系统变量CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH指定的头文件路径</li>
</ul>
<h3 id="3-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#3-请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="3.请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>3.请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h3><p><a href="https://www.cnblogs.com/zpcoding/p/10808969.html">https://www.cnblogs.com/zpcoding/p/10808969.html</a></p>
<p><a href="https://www.cnblogs.com/dongzhiquan/p/5621906.html">https://www.cnblogs.com/dongzhiquan/p/5621906.html</a></p>
<h4 id="1-Linux的虚拟内存管理有几个关键概念："><a href="#1-Linux的虚拟内存管理有几个关键概念：" class="headerlink" title="1.Linux的虚拟内存管理有几个关键概念："></a>1.Linux的虚拟内存管理有几个关键概念：</h4><p>1、每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址；<br>2、虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址；<br>3、如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。</p>
<h4 id="2-Malloc原理："><a href="#2-Malloc原理：" class="headerlink" title="2.Malloc原理："></a>2.Malloc原理：</h4><ul>
<li>1）当开辟的空间<strong>小于 128K</strong> 时，调用 brk（）函数，malloc 的底层实现是系统调用函数 brk（），其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)<ul>
<li>brk 是将数据段（.data）的最高地址指针 _edata 往高地址推<ul>
<li>也可以理解为在狭义heap上分配，狭义heap跟.data是紧挨着的。<code>_edata</code>指针一开始就指向了.date的结尾或者说heap的开始。之后往heap里加东西，<code>_edata</code>就代表了堆的顶部</li>
</ul>
</li>
<li>会产生内存碎片（即被释放的内存，是可利用内存空间），<strong>内存碎片的虚拟地址与物理地址之间的映射是保留的，可以方便的重用，再使用时不会产生缺页中断了，因为映射保留</strong>。当然也有弊端，碎片太多时，想分配大内存就没法了，因为可用空间（即各个碎片）不连续。<ul>
<li>举例：假设heap是10MB，我用new依次从这个堆里得到了3块内存块，分别是：1M、2M和7M。<br>假设这三块内存是连续的。那么如果你把1M和7M的块delete掉，那么这个heap里就有了8M的剩余空间，但是这个8M是不连续的：1个1M的块和1个7M的块，两者被那个2M给分隔开了。<br>这时候如果你要申请一个连续的8M内存区，虽然这个heap有8M的剩余空间，但却没法给你。原因就是这个碎片（其实碎片是1M和7M，因为它俩无法被使用）。<strong>当然该例子不恰当，因为这种M量级的内存分配不可能是brk。brk只能分配128K以内的内存。</strong></li>
</ul>
</li>
</ul>
</li>
<li>2）当开辟的空间<strong>大于 128K</strong> 时，mmap（）系统调用函数来在虚拟地址空间中（堆和栈中间，称为<strong>“文件映射区域”</strong>的地方）找一块空间来开辟。<ul>
<li>mmap 是在进程的虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空闲的虚拟内存。</li>
<li>没有内存碎片</li>
</ul>
</li>
</ul>
<p><strong>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</strong></p>
<h4 id="3-实例："><a href="#3-实例：" class="headerlink" title="3.实例："></a>3.实例：</h4><p>跟我们常用的内存模型，刚好上下反了过来，不过高低地址没有错</p>
<p><img src="https://i.loli.net/2020/10/19/TPVexoE6Lahv4Uz.png" alt="image.png"></p>
<ul>
<li>(1)进程启动的时候，其（虚拟）内存空间的初始布局如图1所示</li>
<li>(2)进程调用A&#x3D;malloc(30K)以后，内存空间如图2：<ul>
<li>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配</li>
<li>事实是：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。</li>
</ul>
</li>
<li>(3)进程调用B&#x3D;malloc(40K)以后，内存空间如图3<ul>
<li>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，因为只有一个_edata 指针，这就是内存碎片产生的原因，什么时候紧缩看后文），而mmap分配的内存可以单独释放。</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/10/19/dGPF9C6m1rsKXQw.png" alt="image.png"></p>
<ul>
<li>(4)进程调用C&#x3D;malloc(200K)以后，内存空间如图4<ul>
<li>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间（文件映射区域）分配一块虚拟内存</li>
</ul>
</li>
<li>(5)进程调用D&#x3D;malloc(100K)以后，内存空间如图5</li>
<li>(6)进程调用free(C)以后，<strong>C对应的虚拟内存和物理内存一起释放</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/10/19/CVOXtH589Je3zix.png" alt="image.png"></p>
<ul>
<li>(7)进程调用free(B)以后，如图7所示<ul>
<li>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了</li>
</ul>
</li>
<li>(8)进程调用free(D)以后，如图8所示<ul>
<li>B和D连接起来，变成一块140K的空闲内存</li>
</ul>
</li>
<li>(9)默认情况下的内<strong>存紧缩操作：</strong><ul>
<li><strong>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）</strong>。在上一个步骤free(D)的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示</li>
</ul>
</li>
</ul>
<h4 id="4-既然堆内内存brk和sbrk不能直接释放，为什么不全部使用-mmap-来分配，munmap直接释放呢？"><a href="#4-既然堆内内存brk和sbrk不能直接释放，为什么不全部使用-mmap-来分配，munmap直接释放呢？" class="headerlink" title="4.既然堆内内存brk和sbrk不能直接释放，为什么不全部使用 mmap 来分配，munmap直接释放呢？"></a>4.既然堆内内存brk和sbrk不能直接释放，为什么不全部使用 mmap 来分配，munmap直接释放呢？</h4><p>问题：既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？</p>
<p><strong>答：</strong></p>
<p>其实，进程向 OS 申请和释放地址空间的接口 sbrk&#x2F;mmap&#x2F;munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断 (1M&#x2F;4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。<strong>缺页中断是内核行为，会导致内核态CPU消耗较大。</strong>另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。</p>
<p><strong>同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗</strong>。 因此， glibc（GNU发布的libc库，即c运行库） 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128k) 才使用 mmap 获得地址空间，也可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值。</p>
<p><strong>两种方法的总结：</strong></p>
<ul>
<li>1.为什么要用brk<ul>
<li>首先要知道无论是brk还是mmap，分配内存，在第一次使用时会有缺页中断的，缺页中断是很费CPU的。</li>
<li><strong>假如可以用mmap分配内存64K</strong>，被munmap 后，虚拟内存和物理内存是真的被回收了。<ul>
<li>实际上mmap只能分配大于128K的，它没法分配这么小的内存</li>
</ul>
</li>
<li>如果回收后，此时，又有164K的内存分配，那么第一次使用时又得一遍即64K&#x2F;4K&#x3D;16次缺页中断，这成本好高的。</li>
<li>所以呢，brk分配的64K内存，回收时没有真的还给系统。它的虚拟空间和物理空间还有映射关系都还是保留的。当再次有跟碎片的大小合适的内存分配时，可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗</li>
<li>其次如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。</li>
<li>所以小内存分配，要用brk</li>
</ul>
</li>
<li>2.为什么要用mmp<ul>
<li><strong>假如使用brk可以分配1M内存</strong>，那么被回收后，会直接产生1M的内存碎片，这没法容忍。<ul>
<li>实际上brk只能分配128K以内的内存</li>
</ul>
</li>
<li>所以大内存分配，要用mmp</li>
</ul>
</li>
</ul>
<h3 id="4-请你说一说C-的内存管理是怎样的？"><a href="#4-请你说一说C-的内存管理是怎样的？" class="headerlink" title="4.请你说一说C++的内存管理是怎样的？"></a>4.请你说一说C++的内存管理是怎样的？</h3><h2 id="六、STL"><a href="#六、STL" class="headerlink" title="六、STL"></a>六、STL</h2><h2 id="七、C-11新特性"><a href="#七、C-11新特性" class="headerlink" title="七、C++11新特性"></a>七、C++11新特性</h2>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/radix/</url>
    <content><![CDATA[<p>基数排序（Radix Sort）是一种非比较性的排序算法，它基于元素的每个位进行排序。其基本思想是将待排序的数字按照低位到高位的顺序进行多次分配和收集，最终完成排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序的数字从最低位开始，按照当前位的值进行分桶（也可以理解为分配）。</li>
<li>收集各个桶中的数字，按照桶的顺序依次放回原数组。</li>
<li>重复步骤1和步骤2，直到所有位都被处理完毕。</li>
</ol>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>基数排序（Radix Sort）是一种非比较型的排序算法，它将待排序序列按照每个元素的位数进行分组，然后依次对每个位上的数字进行排序。基数排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：基数排序的时间复杂度是O(d * (n + k))，其中d是最大元素的位数，n是待排序序列的长度，k是进制数。基数排序需要对每个元素的每个位进行排序，因此需要进行d轮排序操作。在每轮排序中，需要对n个元素进行计数和重排，以及对k个可能的取值进行遍历。因此总体时间复杂度为O(d * (n + k))。</p>
<p>空间复杂度：基数排序的空间复杂度是O(n + k)，其中n是待排序序列的长度，k是进制数。基数排序需要使用一个辅助数组来存储每次排序过程中的临时结果，其大小与输入序列的长度相同。另外，还需要使用一个计数数组来记录每个数字出现的次数，其大小取决于进制数k。因此总体空间复杂度为O(n + k)。</p>
<p>稳定性：基数排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在基数排序中，每一轮按位排序将相等的元素放入相同的桶中，并且桶的顺序不会改变，因此相等元素的相对顺序保持不变。</p>
<p>需要注意的是，基数排序的效率受到最大元素位数d和进制数k的影响。当d较大时，基数排序可能不如其他排序算法（如快速排序、归并排序）高效。而且，基数排序适用于待排序元素可以分解为多个关键字进行排序的情况，例如十进制数的各个位。在实际应用中，要根据具体情况选择合适的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>基数排序（Radix Sort）是一种非比较型的排序算法，它根据数字的每个位上的值进行排序。基数排序适用于非负整数或字符串的排序。以下是基数排序的详细步骤：</p>
<ol>
<li><p><strong>确定最大位数</strong>：确定待排序元素中最大值的位数，并记为<code>max_digits</code>。</p>
</li>
<li><p><strong>按位排序</strong>：从最低有效位到最高有效位，依次对待排序的元素进行排序。</p>
<ul>
<li>对于每一位，使用稳定的排序算法（如计数排序或桶排序）对当前位进行排序。</li>
</ul>
</li>
<li><p><strong>重复排序</strong>：重复执行第2步，直到对所有位都进行了排序。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是基数排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 获取数组中元素的最大值</span>
<span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 使用计数排序对数组按照指定位进行排序（根据 LSD 方式）</span>
<span class="token keyword">void</span> <span class="token function">countSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> output<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储排序后的结果</span>
    <span class="token keyword">int</span> count<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 存储每个数字的出现次数</span>

    <span class="token comment">// 统计当前位数字的出现次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 计算累加次数，得到每个数字在输出数组中的位置</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 根据统计信息将数字放置在输出数组中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        output<span class="token punctuation">[</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        count<span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 将排序后的结果拷贝回原数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 基数排序函数</span>
<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取数组中的最大值</span>

    <span class="token comment">// 从个位开始，对每一位进行计数排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> max <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">countSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们实现了一个<code>getMax</code>函数用于获取数组中的最大值，以及一个<code>countSort</code>函数来对数组按照指定位进行排序（使用LSD方式）。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>radixSort</code>函数对其进行基数排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，基数排序成功地将数组元素从小到大进行了排序。请注意，这只是基数排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>基数排序适用于以下一些应用场景：</p>
<ol>
<li><p><strong>非负整数的排序</strong>：基数排序最初是针对非负整数进行排序的。它通过按照数字的每个位上的值进行排序，可以高效地对非负整数序列进行排序。</p>
</li>
<li><p><strong>字符串的排序</strong>：由于字符串可以看作由字符组成的非负整数，因此基数排序也可以用于对字符串进行排序。按照字符的ASCII码或Unicode编码的每个位上的值进行排序，可以得到按字母顺序排列的字符串序列。</p>
</li>
<li><p><strong>固定长度的数据排序</strong>：当待排序的数据都具有固定的位数时，基数排序可以发挥其优势。例如，对于一个固定为8位的社会安全号码或学生学号的排序任务，可以使用基数排序来快速完成。</p>
</li>
<li><p><strong>稳定排序要求</strong>：基数排序是一种稳定的排序算法，即能够保持相等元素之间的相对顺序不变。如果对排序结果需要保持稳定性，基数排序是一个很好的选择。</p>
</li>
</ol>
<p>需要注意的是，基数排序对于具有较大位数的数据集可能需要更多的时间和空间。另外，基数排序只适用于非负整数或字符串的排序，对于包含负整数或其他类型的数据，需要先进行转换才能使用基数排序。</p>
<p>综上所述，基数排序在非负整数和字符串的排序、固定长度数据的排序以及对稳定性有要求的场景中具有优势。但在特定情况下，也可以根据实际需求选择其他排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>基数排序已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>使用桶排序替代计数排序：在基数排序中，每一位上的排序通常使用计数排序。如果待排序元素的范围较大，可以考虑使用桶排序来代替计数排序。对于每一位数字，将待排序元素分配到多个不同的桶中，然后对每个桶进行排序。这样可以减少计数数组的大小和遍历次数，提高性能。</p>
</li>
<li><p>选择合适的进制数：基数排序中的进制数k决定了每一位上可能的取值范围。选择合适的进制数可以减少每一轮排序所需的操作次数。一般来说，进制数与待排序元素范围的关系为k &#x3D; O(n)或者k &#x3D; O(log n)，其中n是待排序序列的长度。</p>
</li>
<li><p>考虑使用最低有效位（LSB）优先的排序：基数排序可以按照从高位到低位或从低位到高位的顺序进行排序。当待排序元素的位数较多时，考虑使用最低有效位（LSB）优先的排序，可以减少排序过程中元素的移动次数。</p>
</li>
<li><p>结合其他排序算法进行优化：在实际应用中，可以结合其他排序算法进行优化。例如，可以在基数排序的每一位上应用插入排序或快速排序来替代计数排序，当待排序序列长度较小的时候，这样可以提高排序效率。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升基数排序的性能。然而，需要注意的是，基数排序对数据的特定要求较高，适用于特定场景下。在面对大规模数据集时，其他排序算法（如快速排序、归并排序）可能更常用和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/merge/</url>
    <content><![CDATA[<p>归并排序（Merge Sort）是一种高效的排序算法，基于分治策略。其基本思想是将待排序序列递归地拆分成两个子序列，然后对这两个子序列进行排序，并将排序结果合并成一个有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序序列递归地拆分成更小的子序列，直到每个子序列只有一个元素。</li>
<li>对相邻的两个子序列进行合并，得到一个有序的更大的子序列。</li>
<li>不断重复步骤2，直到最终合并成一个完整的有序序列。</li>
</ol>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>归并排序（Merge Sort）是一种基于分治策略的排序算法，它将待排序序列划分为较小的子序列，然后逐步合并这些子序列来实现排序。归并排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：归并排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。归并排序的关键操作是合并两个有序序列，合并操作需要O(n)的时间复杂度，而每次递归划分序列的过程需要进行O(log n)次，因此总体时间复杂度为O(n log n)。</p>
<p>空间复杂度：归并排序的空间复杂度是O(n)，其中n是待排序序列的长度。归并排序需要额外的空间来存储临时数组，在合并过程中会对原始数组进行拷贝。在最差情况下，需要额外的O(n)空间来存储临时数组。</p>
<p>稳定性：归并排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在归并排序中，当合并两个有序序列时，如果遇到相等的元素，先从前一个有序序列中取出，可以保持相等元素的相对顺序不变。</p>
<p>归并排序具有较好的时间复杂度和稳定性，但其空间复杂度较高，需要额外的存储空间。然而，在实际应用中，由于归并排序的稳定性和分治特性，它常被用于需要稳定排序的场景或者对内存占用不敏感的情况下。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>归并排序（Merge Sort）是一种基于分治法的排序算法，它将待排序的数组不断划分为更小的子数组，然后通过合并操作将子数组排序，从而得到最终有序的数组。以下是归并排序的详细步骤：</p>
<ol>
<li><p><strong>划分</strong>：将待排序的数组递归地划分为更小的子数组，直到每个子数组只包含一个元素。</p>
</li>
<li><p><strong>合并</strong>：对于每一对相邻的子数组，使用合并操作将它们合并为一个有序的较大数组。重复这个过程，直到所有子数组合并成一个完整的有序数组。</p>
</li>
</ol>
<p>具体步骤如下：</p>
<ul>
<li><p><strong>划分过程</strong>：</p>
<ul>
<li>将待排序的数组划分为两个子数组，分别是左子数组和右子数组。</li>
<li>递归地对左右子数组进行划分，直到每个子数组只包含一个元素（递归的终止条件）。</li>
</ul>
</li>
<li><p><strong>合并过程</strong>：</p>
<ul>
<li>创建一个临时数组来存储合并后的结果。</li>
<li>通过比较左右子数组的第一个元素，选择较小（或较大）的元素放入临时数组中。</li>
<li>若一个子数组的所有元素都已被放入临时数组，则将另一个子数组中剩余的元素依次放入临时数组。</li>
<li>将临时数组中的元素复制回原始数组对应的位置，完成一次合并操作。</li>
</ul>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是归并排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 合并两个有序子数组</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左子数组的大小</span>
    <span class="token keyword">int</span> n2 <span class="token operator">=</span> right <span class="token operator">-</span> mid<span class="token punctuation">;</span>    <span class="token comment">// 右子数组的大小</span>

    <span class="token keyword">int</span> L<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">,</span> R<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 创建临时数组来存储左右子数组的元素</span>

    <span class="token comment">// 拷贝数据到临时数组 L[] 和 R[]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        R<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 归并临时数组到原数组 arr[]</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 左子数组的索引</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 右子数组的索引</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> left<span class="token punctuation">;</span> <span class="token comment">// 合并后的数组的索引</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 拷贝剩余的元素（如果有）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> R<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        j<span class="token operator">++</span><span class="token punctuation">;</span>
        k<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 归并排序函数</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">// 分割数组并递归地对子数组进行排序</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 合并已经排序的子数组</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>merge</code>函数来合并两个有序子数组，并实现了<code>mergeSort</code>函数来进行归并排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>mergeSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，归并排序成功地将数组元素从小到大进行了排序。请注意，这只是归并排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>归并排序是一种高效的排序算法，适用于多种应用场景。以下是一些适合使用归并排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：归并排序具有稳定的时间复杂度O(n log n)，在平均和最坏情况下都表现良好。因此，对于大规模数据集的排序任务，归并排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相较于其他高效的排序算法（如快速排序），归并排序是一种稳定的排序算法，即能够保持相等元素之间的相对顺序不变。如果对稳定性有要求，归并排序是一个很好的选择。</p>
</li>
<li><p><strong>外部排序</strong>：归并排序天生适用于外部排序，其中待排序的数据无法全部加载到内存中。通过将大文件划分为多个小块，并对每个小块进行排序，然后合并这些有序的小块，可以有效地实现外部排序。</p>
</li>
<li><p><strong>链表排序</strong>：对于链表结构而言，归并排序是一种自然而然的选择。由于归并排序的合并操作只涉及指针的重新连接，而不需要实际的元素移动，因此可以很容易地对链表进行排序。</p>
</li>
</ol>
<p>需要注意的是，归并排序虽然具有较好的性能，但它的空间复杂度较高，需要额外的存储空间来存储临时数组。在内存受限的环境下，可能不适合使用归并排序。</p>
<p>综上所述，归并排序在大规模数据集、需要稳定性、外部排序和链表排序等场景中具有优势。但在特定情况下，也可以根据实际需求选择其他排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>归并排序本身已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>优化合并操作：在归并排序中，合并操作是关键步骤。可以通过使用辅助数组，在合并过程中减少数据拷贝的次数。一种常见的优化方式是在合并过程中先将数据拷贝到辅助数组中，然后再进行合并，而不是每次合并都创建新的临时数组。</p>
</li>
<li><p>针对小规模子序列使用插入排序：对于小规模的子序列，归并排序的性能可能被插入排序所超越。可以通过设置一个阈值，在递归划分到达该阈值时，改用插入排序来处理，从而提高性能。</p>
</li>
<li><p>自底向上的归并排序：传统的归并排序采用自顶向下的递归方式，可以尝试使用自底向上的迭代方式进行归并排序。自底向上的归并排序先将待排序序列划分为若干个长度为1的子序列，然后两两合并，并依次增加子序列的长度，直至整个序列有序。</p>
</li>
<li><p>使用循环内合并：在原始的归并排序中，每次合并操作需要递归调用自身。可以将合并操作放在循环内部，减少递归调用的次数，从而提高性能。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升归并排序的性能。然而，需要注意的是，在大规模数据集或者对内存占用敏感的情况下，其他算法（如快速排序）可能更为常用和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/heap/</url>
    <content><![CDATA[<p>堆排序（Heap Sort）是一种高效的排序算法，基于二叉堆数据结构。其基本思想是将待排序序列看作是一棵完全二叉树，并利用堆的性质进行排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是堆排序的算法原理：</p>
<ol>
<li>构建初始堆：将待排序序列构建成一个最大堆（或最小堆）。最大堆要求父节点的值大于等于子节点的值，最小堆要求父节点的值小于等于子节点的值。</li>
<li>将堆顶元素与末尾元素交换位置，并将末尾元素固定为已排序部分。</li>
<li>对剩余的未排序部分重新构建堆。</li>
<li>重复步骤2和步骤3，直到所有元素都排序完成。</li>
</ol>
<p>堆排序利用了堆的特性，在每一轮中选择堆顶元素（最大值或最小值），并将其放置在已排序部分的末尾。然后，重新构建堆来处理剩余的未排序部分。需要执行n-1轮排序操作，其中n为待排序元素的个数。堆排序的时间复杂度为O(n log n)。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的排序算法，它通过构建最大堆或最小堆，并依次将堆顶元素与末尾元素交换，然后调整堆来实现排序。堆排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：堆排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。建堆过程中需要进行n&#x2F;2次比较和交换操作，而每次堆化操作的时间复杂度为O(log n)，因此总体时间复杂度为O(n log n)。</p>
<p>空间复杂度：堆排序的空间复杂度是O(1)，因为它只需要常数级别的额外空间来存储临时变量，无需额外的辅助空间。</p>
<p>稳定性：堆排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在堆排序中，每次交换堆顶元素与末尾元素的位置会对相等元素产生影响，因此可能打破相等元素之间的相对顺序。</p>
<p>需要注意的是，堆排序虽然具有较好的时间复杂度，但由于其涉及到频繁的元素交换操作，因此在实际应用中对内存的访问比较敏感，可能不如一些其他排序算法（如快速排序、归并排序）效率高。堆排序主要适用于需要稳定时间复杂度的特殊场景或者仅需要部分有序的序列。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>堆排序（Heap Sort）是一种基于二叉堆数据结构的排序算法，它利用堆的性质进行排序。具体步骤如下：</p>
<ol>
<li><p><strong>构建最大堆</strong>：将待排序的数组看作一个完全二叉树，并通过自底向上的方式构建一个最大堆。最大堆要求父节点的值大于或等于其子节点的值。</p>
</li>
<li><p><strong>调整最大堆</strong>：将堆顶元素（即最大值）与堆的最后一个元素交换位置，然后将堆的大小减一。接着，对新的堆顶元素进行一次从上往下的调整操作，使得堆重新满足最大堆的性质。</p>
</li>
<li><p><strong>重复调整</strong>：重复执行第2步，直到整个数组有序。每次循环都会将当前堆中的最大值放在已排序区的末尾，同时将堆的大小减一。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是堆排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 调整堆，使其满足堆的性质</span>
<span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 初始化根节点索引为最大值索引</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左子节点索引</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 右子节点索引</span>

    <span class="token comment">// 找到最大值索引</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 如果最大值索引不是根节点索引，则交换并继续调整堆</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 堆排序函数</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 构建初始堆（最大堆）</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// 一个个取出堆顶元素，将其放置在已排序部分的末尾</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>swap</code>函数来交换两个元素的值，并实现了<code>heapify</code>函数用于调整堆的性质，以及<code>heapSort</code>函数来进行堆排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>heapSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，堆排序成功地将数组元素从小到大进行了排序。请注意，这只是堆排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>堆排序是一种高效的排序算法，适用于多种应用场景。以下是一些适合使用堆排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：堆排序具有稳定的时间复杂度O(n log n)，在平均和最坏情况下都表现良好。因此，对于大规模数据集的排序任务，堆排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相较于其他高效的排序算法（如快速排序和归并排序），堆排序是一种原地、不需要额外存储空间的排序算法。如果对稳定性有要求，堆排序可以在保持元素相对顺序方面进行优化。</p>
</li>
<li><p><strong>准实时应用</strong>：由于堆排序具有较好的最坏情况性能，它在某些准实时应用场景中很有用。当排序时间的上限比平均排序时间更重要时，堆排序可以在保证最坏情况下的性能。</p>
</li>
<li><p><strong>优先队列</strong>：堆排序使用堆这种数据结构，在构建和调整堆的过程中，可以快速找到最大或最小的元素。因此，堆排序常被用作实现优先队列的底层算法。</p>
</li>
</ol>
<p>需要注意的是，堆排序的实现相对较复杂，需要理解和掌握堆数据结构的性质和操作。在实际应用中，还应综合考虑数据规模、稳定性需求以及其他因素，选择适合的排序算法。</p>
<p>综上所述，堆排序在大规模数据集、需要稳定性、准实时应用和优先队列等场景中具有优势。但在特定情况下，也可以考虑使用其他排序算法来满足具体需求。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>堆排序本身已经是一种高效的排序算法，但可以考虑以下优化方法进一步提升性能：</p>
<ol>
<li><p>对建堆过程进行优化：在原始的堆排序中，建堆过程需要从最后一个非叶子节点开始依次向前进行下滤操作。可以通过从最后一个非叶子节点往前遍历，对每个节点执行下滤操作，从而减少比较和交换的次数。</p>
</li>
<li><p>选择合适的堆化方式：堆排序中的堆化操作可以选择自顶向下（即上滤）或自底向上（即下滤）两种方式。在实际应用中，可以根据具体情况选择更适合的堆化方式以提高性能。</p>
</li>
<li><p>使用小根堆进行降序排序：默认情况下，堆排序是使用大根堆来实现升序排序。如果需要进行降序排序，可以使用小根堆来构建堆，并依次取堆顶元素，然后调整堆。</p>
</li>
<li><p>针对部分有序序列的优化：对于已经部分有序的序列，可以通过设置一个阈值，当堆化过程中某些节点已经有序时，可以跳过这些节点的堆化操作，从而提高效率。</p>
</li>
<li><p>使用循环内建堆：在原始的堆排序中，每次交换堆顶元素后，需要重新对堆进行调整。可以考虑将这一过程放在循环内部，减少交换和调整堆的次数，提高性能。</p>
</li>
</ol>
<p>这些优化方法可以根据具体情况选择适用的优化策略，以提升堆排序的性能。然而，需要注意的是，在实际应用中，堆排序通常在对稳定性要求不高且需要基于堆结构的其他操作时才会使用，而在面对大规模数据集或追求更高效稳定的排序算法时，其他算法（如快速排序、归并排序等）通常更为常用。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/selection/</url>
    <content><![CDATA[<p>选择排序（Selection Sort）是一种简单但低效的排序算法。其基本思想是在每一轮中选择未排序部分的最小（或最大）元素，并将其与未排序部分的第一个元素交换位置，从而逐渐构建有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是选择排序的算法原理：</p>
<ol>
<li>遍历待排序序列，将序列中的第一个元素看作当前最小（或最大）元素。</li>
<li>依次与后续的元素进行比较，找到最小（或最大）的元素，记为当前最小（或最大）元素。</li>
<li>如果当前最小（或最大）元素不是当前位置的元素，则交换两者的位置，使得当前位置的元素成为有序序列的一部分。</li>
<li>继续从下一个位置开始执行步骤2和步骤3，直到遍历完整个序列。</li>
<li>重复步骤1~4，直到所有元素都排序完成。</li>
</ol>
<p>选择排序每一轮选择出最小（或最大）的元素，然后将其放置到正确的位置上，因此每一轮可以确定一个元素的最终位置。需要执行n-1轮排序操作，其中n为待排序元素的个数。选择排序的时间复杂度为O(n^2)。</p>
<p>尽管选择排序的效率较低，但由于其实现简单直观，对于小规模的数据集仍然具有一定的应用价值。此外，选择排序是一种不稳定的排序算法，相等元素的相对顺序有可能改变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>选择排序（Selection Sort）是一种简单直观的排序算法，它通过在待排序序列中找到最小（或最大）的元素，并将其放置在已排序序列的末尾。选择排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：无论待排序序列是否有序，选择排序的时间复杂度都为O(n^2)，其中n是待排序序列的长度。这是因为选择排序需要进行n次循环，每次循环需要遍历剩余未排序元素来寻找最小（或最大）的元素。</p>
<p>空间复杂度：选择排序的空间复杂度是O(1)，因为它只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：选择排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在选择排序中，每一次选择最小（或最大）的元素并与当前位置交换，可能导致相等元素的相对顺序发生改变。</p>
<p>需要注意的是，尽管选择排序的时间复杂度较高且不稳定，但由于其实现简单，比较次数固定，对于小规模的数据集仍然可能具有一定的实用性。然而，在面对大规模数据集或追求更高效稳定的排序算法时，其他算法（如快速排序、归并排序等）通常更为常用。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>选择排序（Selection Sort）是一种简单直观的排序算法，它通过重复选择最小（或最大）的元素，并放置到已排序序列的末尾，从而逐步构建有序序列。下面是选择排序的详细步骤：</p>
<ol>
<li><p><strong>初始状态</strong>：将待排序的数组分为已排序区和未排序区。初始时，已排序区为空，未排序区包含整个数组。</p>
</li>
<li><p><strong>找到最小元素</strong>：从未排序区中选择最小的元素，记录其索引或值。</p>
</li>
<li><p><strong>交换位置</strong>：将最小元素与未排序区的第一个元素交换位置，将该元素放入已排序区的末尾。</p>
</li>
<li><p><strong>更新区域</strong>：将已排序区扩展一个位置，将未排序区缩小一个位置。</p>
</li>
<li><p><strong>重复执行</strong>：重复执行第2至第4步，直到未排序区为空。此时，整个数组已经有序。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是选择排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 选择排序函数</span>
<span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>

        <span class="token comment">// 找到未排序部分的最小元素的索引</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 将最小元素与当前位置交换</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了一个<code>swap</code>函数来交换两个元素的值，并实现了<code>selectionSort</code>函数来进行选择排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>selectionSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，选择排序成功地将数组元素从小到大进行了排序。请注意，这只是选择排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>选择排序是一种简单直观的排序算法，尽管在时间复杂度上不如其他高级排序算法，但它仍然有一些应用场景。以下是一些适合使用选择排序的情况：</p>
<ol>
<li><p><strong>小规模数据集</strong>：由于选择排序的实现简单且不需要额外的存储空间，对于小规模的数据集来说，其性能表现可接受。</p>
</li>
<li><p><strong>内存受限环境</strong>：选择排序是一种原地排序算法，即不需要额外的存储空间。在内存受限的环境中（如嵌入式系统、某些特殊硬件环境），选择排序可能是一个合适的选择。</p>
</li>
<li><p><strong>教学和理解</strong>：选择排序是最简单的排序算法之一，非常适合作为教学工具，帮助初学者理解排序算法的基本原理和思想。</p>
</li>
<li><p><strong>辅助其他排序算法</strong>：选择排序的交换次数相对较少，可以用作其他排序算法的前置步骤或优化策略。</p>
</li>
</ol>
<p>需要注意的是，选择排序的主要应用场景是在小规模数据和内存受限环境下，或作为教学使用，而不适用于大规模数据和时间敏感的应用。在这些情况下，建议使用更高效的排序算法，如快速排序、归并排序等。选择排序的性能相对较低，通常不是首选的排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>选择排序是一种简单但效率较低的排序算法。尽管它的时间复杂度无法通过优化得到明显改善，但可以考虑以下几种优化方法来提高选择排序的性能：</p>
<ol>
<li><p>最小&#x2F;最大元素同时查找：在每次循环中，除了找到当前未排序序列中的最小（或最大）元素外，还可以同时找到最大和最小元素的位置。这样可以将两个交换操作合并为一次，减少总体的比较次数。</p>
</li>
<li><p>跳过已排序部分查找：在每次循环中，在待排序序列中查找最小（或最大）元素时，可以跳过已经排序好的部分。因为已排序部分的元素已经处于正确的位置上，无需再次比较。</p>
</li>
<li><p>优化交换操作：选择排序每次需要找到最小（或最大）元素，并与当前位置进行交换。可以通过添加一个判断语句，在找到最小（或最大）元素后，若它就处于当前位置，则无需进行交换操作。</p>
</li>
<li><p>针对优化情况的增量设置：对于一些已基本有序的序列，可以通过设定适当的增量（如步长）来进行排序，使得每一趟排序的跨度减小，从而加快排序速度。例如，可以使用希尔增量序列或其他合适的增量序列。</p>
</li>
</ol>
<p>这些优化方法可以在某些情况下提高选择排序的性能。然而，需要注意的是，尽管这些优化措施可能减少了一些比较和交换操作的次数，但选择排序的时间复杂度仍然保持不变，因此对于大规模数据集来说，它仍然不是一个高效的排序算法。在实际应用中，通常会选择其他更为高效的排序算法来处理排序任务。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/quick/</url>
    <content><![CDATA[<p>快速排序（Quick Sort）是一种常用且高效的排序算法。其基本思想是通过分治法将待排序序列不断划分成较小和较大的子序列，然后对子序列进行递归排序，最终合并得到有序序列。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>选择一个基准元素（pivot），通常是待排序序列的第一个或最后一个元素。</li>
<li>将待排序序列划分成两个子序列，一个子序列包含所有比基准元素小的元素，另一个子序列包含所有比基准元素大的元素。在划分过程中，可以使用两个指针（low和high）分别从序列的起始位置和末尾位置向中间移动。</li>
<li>对两个子序列递归地应用快速排序算法，直到子序列的长度为1或0时停止递归。</li>
<li>合并排好序的子序列和基准元素，即可得到完全排序的序列。</li>
</ol>
<p>快速排序的关键在于划分过程，它通过一次遍历将待排序序列划分为两个子序列，其中一个子序列的元素都比基准元素小，另一个子序列的元素都比基准元素大。这样，在每一轮划分后，基准元素就找到了它的最终位置，不需要再移动，从而提高了排序效率。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>快速排序（Quick Sort）是一种常用的排序算法，它基于分治思想，在待排序序列中选择一个元素作为基准值，将序列划分为两个子序列，使得左侧子序列的所有元素小于等于基准值，右侧子序列的所有元素大于基准值，然后对两个子序列递归地进行排序。快速排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：在平均情况下，快速排序的时间复杂度是O(n log n)，其中n是待排序序列的长度。在最坏情况下，当待排序序列已经有序或基本有序时，快速排序的时间复杂度退化为O(n^2)。尽管最坏情况下的时间复杂度较高，但由于快速排序的平均时间复杂度较低且具有良好的性能表现，因此它仍然是一种常用的排序算法。</p>
<p>空间复杂度：快速排序的空间复杂度取决于递归调用的栈空间。在每次划分过程中，需要额外的空间来保存基准值和左右子序列的划分点。因此，快速排序的空间复杂度是O(log n)。</p>
<p>稳定性：快速排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在快速排序中，由于划分过程中涉及到元素的交换，可能打破相等元素之间的相对顺序。因此，快速排序并不保证相等元素的相对顺序不变。</p>
<p>需要注意的是，在实际应用中，可以通过选择合适的基准值和优化划分过程来提高快速排序的性能，例如随机选择基准值或使用三数取中法来选择基准值，并采用插入排序等方法来处理小规模子序列。这些优化措施能够使快速排序更加稳定和高效。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>快速排序（Quick Sort）是一种常用的高效排序算法，基于分治法的思想。它通过选择一个基准元素，并将数组划分成两个子数组，其中一个子数组的元素均小于等于基准元素，而另一个子数组的元素均大于基准元素。然后对这两个子数组分别递归地应用快速排序，最终完成整体的排序。下面详细解释快速排序的步骤：</p>
<ol>
<li><p><strong>选择基准元素</strong>：从待排序的数组中选择一个元素作为基准元素。通常可以选择第一个元素、最后一个元素或者随机位置的元素作为基准。</p>
</li>
<li><p><strong>划分过程</strong>：将数组中的其他元素与基准元素进行比较，并将小于等于基准的元素放在基准元素的左侧，大于基准的元素放在右侧。此过程称为划分（Partition）。</p>
</li>
<li><p><strong>递归调用</strong>：对基准元素左侧和右侧的子数组，分别递归地应用快速排序算法。重复上述步骤，直到每个子数组只包含一个元素，即达到基线条件。</p>
</li>
<li><p><strong>合并结果</strong>：当所有子数组都有序时，整个数组也就有序了。</p>
</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是快速排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token comment">// 交换两个元素的值</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 划分函数，将序列划分为两个子序列</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 选择最后一个元素作为基准</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 小于基准元素的指针</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> high <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 快速排序函数</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> pi <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分并获得基准元素的位置</span>

        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pi <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对基准元素左侧的子序列进行递归排序</span>
        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对基准元素右侧的子序列进行递归排序</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这个示例中，我们定义了三个函数：<code>swap</code>用于交换两个元素的值，<code>partition</code>用于划分序列并返回基准元素的位置，<code>quickSort</code>实现递归地对子序列进行快速排序。</p>
<p>在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>quickSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可以看到，快速排序成功地将数组元素从小到大进行了排序。请注意，这只是快速排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>快速排序是一种高效的排序算法，适用于各种应用场景。以下是一些适合使用快速排序的情况：</p>
<ol>
<li><p><strong>大规模数据集</strong>：快速排序在平均情况下具有良好的性能，其时间复杂度为O(n log n)。因此，对于大规模数据集的排序任务，快速排序通常是一个较好的选择。</p>
</li>
<li><p><strong>需要稳定性</strong>：相比于其他常用的高效排序算法（如堆排序和归并排序），快速排序是一种原地排序算法，不需要额外的存储空间。如果对稳定性有要求，可以通过修改算法来保持相等元素的相对顺序。</p>
</li>
<li><p><strong>部分有序数组</strong>：快速排序的性能在处理部分有序的数组时表现良好。由于快速排序的分区过程会将数组划分成两个子数组，对于已经有序或基本有序的数组，递归处理时只需少量的比较和交换操作。</p>
</li>
<li><p><strong>应用中频繁插入和删除元素</strong>：快速排序的特点是基于分治法，将数组划分成两个子数组。当需要在已排序的数组中频繁地插入和删除元素时，快速排序具有较好的适应性。</p>
</li>
</ol>
<p>需要注意的是，快速排序的最坏情况时间复杂度为O(n^2)，即当选择的基准元素不合适（如数组已经有序或基本有序）时，性能可能下降。因此，在特定情况下，可以考虑使用其他排序算法来避免快速排序的最坏情况。</p>
<p>综上所述，快速排序在大规模数据集、需要稳定性、部分有序数组和频繁插入删除元素等场景中具有优势。但在实际应用中，还应综合考虑数据规模、应用需求以及其他因素，选择合适的排序算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>快速排序本身已经是一种高效的排序算法，但还可以通过以下优化方法进一步提升性能：</p>
<ol>
<li><p>随机选择基准值：在每次划分过程中，选择一个随机位置的元素作为基准值。这样可以避免在待排序序列已经有序或近乎有序的情况下，快速排序退化为最坏情况。</p>
</li>
<li><p>三数取中法选择基准值：从待排序序列的开始、中间和末尾位置分别选取一个元素，然后将它们进行比较，并选择其中位于中间大小的元素作为基准值。这样可以尽量避免选择极端值作为基准值，进而减少快速排序的不平衡性。</p>
</li>
<li><p>小规模子序列使用插入排序：当待排序子序列的长度比较小（通常小于一定阈值）时，可以直接采用插入排序等简单且稳定的排序算法来替代快速排序。因为对于小规模的子序列，插入排序可能会更加高效。</p>
</li>
<li><p>跳过相等元素的划分：在划分过程中，如果遇到与基准值相等的元素，可以跳过它们，避免不必要的交换操作。这样可以减少比较和交换的次数，提高性能。</p>
</li>
<li><p>优化递归：通过尾递归、迭代或使用隐式栈等方式，减少递归调用的深度，避免栈溢出的问题。</p>
</li>
</ol>
<p>这些优化方法可以结合使用，根据具体情况选择适合的优化策略。它们在实际应用中可以显著提升快速排序的性能，使得它更加稳定和高效。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/bubble/</url>
    <content><![CDATA[<p>冒泡排序（Bubble Sort）是一种简单但低效的排序算法。其基本思想是通过不断比较相邻的元素并交换位置，将最大（或最小）的元素逐渐“冒泡”到序列的末尾（或开头），从而实现排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>从待排序的数组的第一个元素开始，依次比较每一对相邻的元素。</li>
<li>如果当前元素大于（或小于）它的下一个元素，则交换这两个元素的位置，使较大（或较小）的元素“浮”到前面。</li>
<li>继续重复步骤2，对剩余的元素进行相同的操作，直到最后一个元素。</li>
<li>一轮比较过程完成后，最大（或最小）的元素已经移动到了序列的末尾（或开头）。</li>
<li>重复步骤1~4，对剩余未排序的元素进行相同的操作，直到所有元素都排序完成。</li>
</ol>
<p>冒泡排序每一轮都会将最大（或最小）的元素“浮”到末尾（或开头），因此在每一轮排序中都可以减少一个元素的比较次数。最坏情况下，需要进行n-1轮比较和移动操作，其中n为待排序元素的个数。冒泡排序的时间复杂度为O(n^2)。</p>
<p>尽管冒泡排序的效率较低，但由于其实现简单直观，对于小规模的数据集仍然具有一定的应用价值。此外，冒泡排序也是稳定的排序算法，相等元素的相对顺序不会改变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>冒泡排序（Bubble Sort）是一种简单且容易理解的排序算法，它通过相邻元素之间的比较和交换来进行排序。冒泡排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：冒泡排序的平均时间复杂度和最坏情况下的时间复杂度都是O(n^2)，其中n是待排序序列的长度。在最好情况下，即待排序序列已经完全有序的情况下，冒泡排序的时间复杂度可以是O(n)。但由于每次循环都需要执行两两比较和可能的交换操作，所以总体时间复杂度仍然是O(n^2)。</p>
<p>空间复杂度：冒泡排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：冒泡排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在冒泡排序中，通过相邻元素之间的比较和交换，只有当相邻元素大小不符合排序规则时才进行交换，所以相等元素之间的相对顺序不会改变，即冒泡排序是一种稳定的排序算法。</p>
<p>需要注意的是，尽管冒泡排序的时间复杂度较高，但在某些特定情况下（如待排序序列已经基本有序），它可能具有较好的性能表现。然而，在实际应用中，根据具体情况选择合适的排序算法，综合考虑数据规模、时间复杂度要求以及稳定性等因素。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它通过多次遍历待排序的数组，并比较相邻元素的大小来进行排序。在每次遍历中，较大的元素会逐渐“浮”到数组的末尾，故称为冒泡排序。下面是冒泡排序的详细步骤：</p>
<ol>
<li><p><strong>从第一个元素开始</strong>：从数组的第一个元素开始，依次比较相邻的两个元素的大小。</p>
</li>
<li><p><strong>比较相邻元素</strong>：将当前元素与其后面的相邻元素进行比较，如果当前元素大于后面的元素，则交换这两个元素的位置，使较大的元素“冒泡”。</p>
</li>
<li><p><strong>向后遍历</strong>：继续向后遍历，重复执行步骤2，直到遍历到倒数第二个元素。此时，最大的元素已经“冒泡”到了数组的最后一个位置。</p>
</li>
<li><p><strong>重复遍历步骤</strong>：重复执行上述步骤，每次遍历范围缩小一个元素，直到整个数组有序。</p>
</li>
<li><p><strong>优化处理</strong>：可以添加一个标志位来判断在一轮遍历中是否发生了元素的交换。如果没有发生交换，说明数组已经有序，可以提前结束排序。</p>
</li>
</ol>
<p>冒泡排序的核心思想是通过相邻元素的比较和交换来将最大（或最小）的元素逐渐移动到数组的末尾。该算法时间复杂度为O(n^2)，其中n是数组的长度。虽然冒泡排序不是一种高效的排序算法，但由于其简单直观的实现方式，对于小规模数据集或已经基本有序的数据集仍具有一定的应用价值。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是冒泡排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 在每一轮中执行比较和交换操作</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 如果当前元素大于下一个元素，则交换位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>该示例中，我们定义了一个<code>bubbleSort</code>函数来实现冒泡排序。在主函数中，我们声明了一个整型数组<code>arr</code>，然后调用<code>bubbleSort</code>函数对其进行排序。最后，打印排序前后的数组内容。</p>
<p>运行以上代码，输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">原始数组：64 34 25 12 22 11 90 
排序后数组：11 12 22 25 34 64 90 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>可见，冒泡排序成功地将数组元素从小到大进行了排序。请注意，这只是冒泡排序的其中一种实现方式，你可以根据需要进行修改和优化。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>尽管冒泡排序在时间复杂度上不如其他高级排序算法，但它仍然有一些应用场景。以下是一些适合使用冒泡排序的情况：</p>
<ol>
<li><p><strong>小规模数据集</strong>：由于冒泡排序的实现简单直观，对于小规模的数据集来说，其性能表现可接受。</p>
</li>
<li><p><strong>部分有序数组</strong>：当待排序的数组已经基本有序时，冒泡排序的效率会更高。因为冒泡排序的特点是每次都会将最大（或最小）的元素交换到末尾，所以对于部分有序的数组，只需进行少量的比较和交换操作即可完成排序。</p>
</li>
<li><p><strong>教学和理解</strong>：冒泡排序是最简单的排序算法之一，非常适合作为教学工具，帮助初学者理解排序算法的基本原理和思想。</p>
</li>
<li><p><strong>稳定性要求</strong>：冒泡排序是一种稳定的排序算法，即相等元素的相对顺序不变。在某些情况下，对于需要保持相等元素顺序的应用场景，冒泡排序是一个合适的选择。</p>
</li>
</ol>
<p>需要注意的是，对于大规模的数据集，冒泡排序的性能不够理想，建议使用更高效的排序算法，如快速排序、归并排序等。冒泡排序的主要应用场景是在小规模数据和部分有序数组情况下，或作为教学使用，而不适用于大规模数据和时间敏感的应用。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>冒泡排序是一种简单但效率较低的排序算法，由于其两两比较和交换的思想，导致在大多数情况下需要进行多次无意义的比较和交换操作。为了提高冒泡排序的效率，可以采用以下几种优化方法：</p>
<ol>
<li><p>设置标志位：在每一轮内部循环中，如果没有发生元素的交换操作，说明待排序序列已经有序，可以提前结束排序过程。</p>
</li>
<li><p>记录最后一次交换位置：在每一轮内部循环中，记录最后一次元素交换的位置，该位置之后的元素已经有序，因此下一轮只需比较到这个位置即可。</p>
</li>
<li><p>双向冒泡排序：正常的冒泡排序是从左到右依次比较相邻元素并进行交换，而双向冒泡排序可以同时从左到右和从右到左进行相邻元素的比较和交换操作，从而减少排序的趟数。</p>
</li>
<li><p>针对优化情况的增量设置：对于一些已基本有序的序列，可以通过设定适当的增量（如步长）来进行排序，使得每一趟排序的跨度减小，从而加快排序速度。例如，可以使用希尔增量序列或者其他合适的增量序列。</p>
</li>
</ol>
<p>这些优化方法都是基于冒泡排序的思想，通过剪枝和减少比较交换次数来提高效率。然而，尽管这些优化方法可以降低冒泡排序的时间复杂度，并且在某些特定情况下可能具有较好的性能表现，但在大多数实际应用中，其他更为高效的排序算法（如快速排序或归并排序）通常更受青睐。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/shell/</url>
    <content><![CDATA[<p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为缩小增量排序。其基本思想是通过将整个待排序序列分割成若干个子序列进行排序，然后逐步缩小子序列的间隔，直到最后一次排序时间隔为1，即执行最后一次普通的插入排序。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>以下是希尔排序的算法原理：</p>
<ol>
<li>首先选择一个增量序列，通常为n&#x2F;2、n&#x2F;4、n&#x2F;8…直到增量为1。</li>
<li>根据选定的增量，将待排序的数组分成多个子序列，每个子序列包含间隔为增量的元素。</li>
<li>对每个子序列进行插入排序，即将每个子序列中的元素按照插入排序的方式进行排序。</li>
<li>缩小增量，重新分割子序列，并对每个子序列进行排序。重复这一步骤，直到增量为1。</li>
<li>最后一次排序时，增量为1，即进行一次普通的插入排序，将整个序列排序完成。</li>
</ol>
<p>希尔排序的关键在于选取的增量序列，不同的增量序列可能会影响排序的效率。一般情况下，增量序列可以使用Hibbard增量序列（2^k - 1, 2^(k-1) - 1, …, 7, 3, 1）或者Sedgewick增量序列（1, 5, 19, 41, 109, …），它们经过实践证明能够获得较好的排序效果。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>希尔排序（Shell Sort）是一种基于插入排序的排序算法，它通过将待排序序列分成多个较小的子序列进行排序，然后逐步缩小子序列的间隔，最终完成整个序列的排序。希尔排序的时间复杂度、空间复杂度和稳定性如下：</p>
<p>时间复杂度：希尔排序的时间复杂度取决于增量序列的选择。最坏情况下，希尔排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。但在大多数情况下，希尔排序的时间复杂度可以达到O(n log n)或更好。具体的时间复杂度分析比较复杂，取决于增量序列的选取和序列的有序度。</p>
<p>空间复杂度：希尔排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：希尔排序是一种不稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在希尔排序中，由于每次排序的跨度比较大，可能会打破相等元素之间的相对顺序，因此希尔排序并不保证相等元素的相对顺序不变。</p>
<p>需要注意的是，希尔排序的性能受到增量序列的选择影响较大。选择合适的增量序列可以显著改善希尔排序的性能，并使其接近最优的时间复杂度。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>希尔排序（Shell Sort）是一种改进的插入排序算法，也被称为缩小增量排序。它通过将待排序的数组分割成多个子序列，并对每个子序列进行插入排序来实现整体的排序。希尔排序的步骤如下所示：</p>
<ol>
<li><p><strong>选择增量序列</strong>：选择一个递减的增量序列，常见的选择方式是使用希尔增量序列（例如，Knuth序列或者Sedgewick序列）。增量序列决定了每次分割子序列的间隔。</p>
</li>
<li><p><strong>根据增量分割子序列</strong>：按照选定的增量将待排序的数组分割成多个子序列，并对每个子序列进行插入排序。通常，初始增量会将数组分割成较小的子序列，随着增量的逐渐减小，子序列的长度也会逐渐增加。</p>
</li>
<li><p><strong>对子序列进行插入排序</strong>：对每个子序列应用插入排序算法，通过比较相邻元素的大小并移动元素，将子序列中的元素进行排序。</p>
</li>
<li><p><strong>减小增量并重复上述步骤</strong>：重复以上步骤，每次减小增量直到增量为1。当增量减小为1时，整个序列被视为一个子序列，并进行最后一次插入排序。</p>
</li>
<li><p><strong>合并子序列</strong>：在完成上述步骤后，所有的子序列都已经有序。最后，对整个数组进行一次插入排序，确保整体有序。</p>
</li>
</ol>
<p>希尔排序通过提前对较远距离的元素进行比较和交换，可以快速地减小逆序对的数量，从而加快排序的速度。尽管希尔排序的时间复杂度没有严格的界定，但在实践中，它通常具有较好的性能表现。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是希尔排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 选择增量序列（可以使用其他增量序列）</span>
    <span class="token keyword">int</span> gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 对每个子序列进行插入排序</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
            
            <span class="token comment">// 在子序列中进行插入排序</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> gap <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span>
                j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>

            array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 缩小增量</span>
        gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">shellSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n排序后数组："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述代码中，<code>shellSort</code>函数实现了希尔排序算法。它首先选择一个增量序列，并使用增量来分割待排序的数组成多个子序列。然后对每个子序列应用插入排序算法来对子序列进行排序。最后，通过不断减小增量的方式重复上述过程，直到增量为1，完成整体的排序。</p>
<p>在<code>main</code>函数中，我们创建一个示例数组并调用<code>shellSort</code>函数来对数组进行排序。最终，打印出原始数组和排序后的数组。</p>
<p>请注意，在实际应用中，可以根据具体需求选择不同的增量序列，并对算法进行优化。以上是希尔排序的一个基本实现，您可以根据需要进行修改和扩展。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>希尔排序在以下情况下适用：</p>
<ol>
<li><p>中等规模的数据集：希尔排序相对于一些更为复杂的排序算法（如快速排序和归并排序）来说，实现起来比较简单且效率较高。因此，在数据集规模不是很大的情况下，希尔排序可以提供较好的性能。</p>
</li>
<li><p>需要原地排序的场景：希尔排序只需要常数级别的额外空间，因此它是一种原地排序算法。如果空间复杂度是一个重要的考虑因素，希尔排序是一个合适的选择。</p>
</li>
<li><p>对稳定性没有特别要求的场景：希尔排序是一种不稳定的排序算法，即可能打破相等元素之间的相对顺序。如果待排序序列中存在相等元素，并且要求保持它们的相对顺序不变，那么希尔排序可能不适合。但在某些情况下，对稳定性没有特别要求的场景，希尔排序仍然可以使用。</p>
</li>
</ol>
<p>总的来说，希尔排序在中等规模的数据集以及需要原地排序且对稳定性没有特别要求的场景下表现良好。然而，在实际应用中，根据具体情况选择合适的排序算法，综合考虑数据规模、时间复杂度要求以及稳定性等因素。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>希尔排序可以通过以下几种优化方法来提高其性能：</p>
<ol>
<li><p><strong>选择优化的增量序列</strong>：希尔排序中增量序列的选择对算法的性能有着重要影响。一些常用的增量序列如Hibbard增量序列和Sedgewick增量序列，它们经过实践证明能够获得较好的排序效果。同时，还可以针对特定数据集进行实验，选择适合该数据集的增量序列。</p>
</li>
<li><p><strong>插入排序的优化</strong>：在希尔排序中，每个子序列都会执行插入排序。可以尝试使用更高效的插入排序算法，比如二分插入排序（折半插入排序）来替代普通的插入排序。这样可以减少每个子序列的比较和移动操作次数，进而提高整体的排序效率。</p>
</li>
<li><p><strong>多线程并行处理</strong>：希尔排序可以通过并行处理来提高排序速度。将待排序的数组分成多个子序列后，可以采用多线程的方式并行地对各个子序列进行排序，从而加快整体的排序过程。需要注意线程同步和数据分配的问题。</p>
</li>
<li><p><strong>结合其他排序算法</strong>：结合其他排序算法进行改进也是一种优化方法。例如，可以通过希尔排序的初步排序得到一个部分有序的数组，然后再使用其他排序算法（如快速排序或归并排序）对部分有序的数组进行最终的排序。这样可以在一定程度上提高整体的排序效率。</p>
</li>
</ol>
<p>需要根据具体情况选择适合的优化方法，并进行实际的测试和评估来确定其效果。不同的数据集和需求可能会导致不同的优化策略。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>折半插入排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/halfinsertion/</url>
    <content><![CDATA[<p>折半插入排序（Binary Insertion Sort）是在直接插入排序的基础上进行改进的一种排序算法。与直接插入排序类似，折半插入排序也通过构建有序序列来对数据进行排序。它的基本思想是利用二分查找的方式来确定待插入元素在已排序部分中的位置，从而减少比较操作的次数。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>将待排序的数组分为已排序和未排序两部分，初始时已排序部分只包含第一个元素。</li>
<li>对于每个未排序的元素，使用二分查找在已排序部分找到合适的插入位置。</li>
<li>采用二分查找时，首先取已排序部分的中间位置mid，将待插入元素与mid处的元素进行比较。</li>
<li>如果待插入元素小于mid处的元素，则说明插入位置在mid的左侧，将搜索范围缩小至左半部分继续进行二分查找。</li>
<li>如果待插入元素大于或等于mid处的元素，则说明插入位置在mid的右侧，将搜索范围缩小至右半部分继续进行二分查找。</li>
<li>不断重复步骤3~5，直到找到合适的插入位置。</li>
<li>将待插入元素插入到已排序部分的正确位置上，将已排序部分的长度增加1。</li>
<li>重复步骤2~7，直到所有元素都插入完成。</li>
</ol>
<p>通过利用二分查找来确定插入位置，折半插入排序减少了比较的次数，相对于直接插入排序可以提高效率。其时间复杂度仍然为O(n^2)，但是在实际应用中，由于比较次数的减少，折半插入排序通常比直接插入排序更快。同时，折半插入排序也是稳定的排序算法，保持相等元素之间的相对顺序不变。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>折半插入排序（或称为二分插入排序）的时间复杂度、空间复杂度和稳定性与直接插入排序相同。</p>
<p>时间复杂度：折半插入排序的时间复杂度仍然是O(n^2)，其中n是待排序序列的长度。虽然折半插入排序减少了比较操作的次数，但仍需要进行元素的移动操作，最坏情况下仍然需要进行n*(n-1)&#x2F;2次比较和移动操作。</p>
<p>空间复杂度：折半插入排序的空间复杂度是O(1)，因为只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>稳定性：折半插入排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在折半插入排序中，当找到待插入元素应该插入的位置时，将其插入到该位置之前，并不会改变相等元素的相对顺序，因此折半插入排序也是稳定的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>折半插入排序的步骤详解如下：</p>
<ol>
<li>将待排序的数组分为已排序和未排序两部分，初始时已排序部分只包含第一个元素。</li>
<li>对于每个未排序的元素，使用二分查找在已排序部分找到合适的插入位置。</li>
<li>采用二分查找时，首先确定已排序部分的起始位置start和结束位置end。初始时，start为0，end为已排序部分的最后一个元素的索引。</li>
<li>计算mid &#x3D; (start + end) &#x2F; 2，取已排序部分中间位置元素的索引。</li>
<li>比较待插入元素与mid处元素的大小关系：<ul>
<li>如果待插入元素小于mid处元素，则说明插入位置在mid的左侧，将end更新为mid-1。</li>
<li>如果待插入元素大于或等于mid处元素，则说明插入位置在mid的右侧，将start更新为mid+1。</li>
<li>如果待插入元素等于mid处元素，则可以选择将待插入元素插入到mid的左侧或右侧，保持稳定性即可。</li>
</ul>
</li>
<li>重复进行二分查找，直到找到合适的插入位置，此时start的值即为插入位置的索引。</li>
<li>将待插入元素插入到start的位置上，并将已排序部分的长度增加1。</li>
<li>重复步骤2~7，对未排序部分的每个元素都进行插入操作，直到所有元素都插入完成。</li>
</ol>
<p>在折半插入排序中，二分查找的使用使得待插入元素的比较次数减少，从而提高了算法的效率。与直接插入排序相比，折半插入排序保持了相同的稳定性，但一般情况下具有更好的性能。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是折半插入排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">binaryInsertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>
    
    <span class="token comment">// 从第二个元素开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前待插入元素</span>
        low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 使用二分查找在已排序部分中寻找待插入元素的插入位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        <span class="token comment">// 将插入位置之后的元素都向后移动一个位置，为待插入元素腾出空间</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> low<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token comment">// 插入待插入元素到正确位置</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始序列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">binaryInsertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此代码中，binaryInsertionSort函数用于实现折半插入排序算法。在main函数中，我们定义了一个待排序序列arr，并对其进行排序。最终输出排序结果。运行该程序将得到如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">原始序列：5 2 4 6 1 3 
排序结果：1 2 3 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这是折半插入排序在C语言中的基本实现，通过利用二分查找来确定待插入元素的插入位置，从而减少比较操作的次数。然后，将插入位置之后的元素都向后移动一个位置，为待插入元素腾出空间，最后将待插入元素插入到正确的位置上，得到有序序列。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>折半插入排序通常在以下情况下适用：</p>
<ol>
<li><p>大部分元素已经有序：折半插入排序的优势在于它利用了已排序部分的有序性质，通过二分查找来确定待插入元素的插入位置。因此，当待排序序列中的大部分元素已经有序时，折半插入排序可以有效地减少比较操作的次数，提高排序效率。</p>
</li>
<li><p>数据量不是很大：由于折半插入排序的时间复杂度仍然是O(n^2)，其中n是待排序序列的长度，所以在数据量较大的情况下，其他更高效的排序算法（如快速排序或归并排序）可能更合适。折半插入排序通常在数据量不是很大的情况下发挥其优势。</p>
</li>
<li><p>稳定排序要求：折半插入排序是一种稳定的排序算法，即相等元素的相对顺序在排序后保持不变。如果需要保持相等元素的原始相对顺序，折半插入排序是一个良好的选择。</p>
</li>
</ol>
<p>总的来说，折半插入排序在某些特定情况下能够提供比直接插入排序更好的性能表现。但在实际应用中，需要根据具体情况选择合适的排序算法，根据数据量大小、有序度以及稳定性等因素进行综合考虑。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>在折半插入排序中，可以使用一些优化方法来进一步提高算法的效率和性能。以下是一些常见的折半插入排序的优化方法：</p>
<ol>
<li><p><strong>二分查找的优化</strong>：传统的二分查找需要不断地比较并更新左右指针，这会带来额外的开销。为了减少比较操作的次数，可以使用二分查找的变种，如插值查找或斐波那契查找等，来更快地找到插入位置。</p>
</li>
<li><p><strong>前置判断</strong>：在开始进行二分查找之前，可以先对待插入元素与已排序部分的第一个元素进行比较。如果待插入元素小于或等于第一个元素，那么直接将其插入到已排序部分的开头即可，无需进行二分查找。</p>
</li>
<li><p><strong>移动元素的优化</strong>：传统的折半插入排序在找到插入位置后，需要依次移动元素以空出插入位置。这一过程可以通过一次数组元素的搬移操作来进行，从而减少元素搬移的次数。</p>
</li>
<li><p><strong>使用二分查找定位插入位置</strong>：除了用二分查找来确定插入位置外，还可以选择使用其他更高效的数据结构，如平衡二叉搜索树（如红黑树）、跳表等，来加速查找插入位置的过程。</p>
</li>
</ol>
<p>这些优化方法可以结合使用，根据具体情况进行选择和调整。优化后的折半插入排序能够更快地找到插入位置并减少元素搬移的次数，从而提高算法的效率和性能。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/yangtong.github.io/2023/08/03/algorihtm/insertion/</url>
    <content><![CDATA[<p>直接插入排序是一种简单直观的排序算法，其基本思想是将待排序的序列分为已排序和未排序两部分。初始时，已排序部分只包含一个元素（即第一个元素），然后逐步将未排序部分中的每个元素插入到已排序部分的适当位置，直到全部元素都被插入到已排序部分为止。</p>
<span id="more"></span>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>首先，从第二个元素开始遍历整个序列，将当前元素标记为待插入元素。</li>
<li>将待插入元素与已排序部分的最后一个元素进行比较。</li>
<li>如果待插入元素小于已排序部分的最后一个元素，则将已排序部分的最后一个元素向后移动一个位置，腾出空间给待插入元素。</li>
<li>继续向前比较，直到找到待插入元素应该插入的位置为止。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤2至5，直到遍历完所有待排序元素。</li>
</ol>
<p>整个过程可以类比为打扑克牌时整理手中的牌，每次将一张新的牌插入到正确的位置上。</p>
<h2 id="稳定性与复杂度"><a href="#稳定性与复杂度" class="headerlink" title="稳定性与复杂度"></a>稳定性与复杂度</h2><p>直接插入排序的时间复杂度是O(n^2)，其中n是待排序序列的长度。在最坏情况下，即待排序序列是逆序的情况下，需要进行n*(n-1)&#x2F;2次比较和移动操作。</p>
<p>空间复杂度是O(1)，因为直接插入排序只需要常数级别的额外空间来存储临时变量，不会随着待排序序列的增长而增加额外的空间消耗。</p>
<p>直接插入排序是一种稳定的排序算法。稳定性指的是如果待排序序列中存在相等元素，经过排序后相等元素之间的相对顺序保持不变。在直接插入排序中，当找到待插入元素应该插入的位置时，将其插入到该位置之前，并不会改变相等元素的相对顺序，因此直接插入排序是稳定的排序算法。</p>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>以下是直接插入排序的详细步骤：</p>
<ol>
<li>假设待排序序列为arr，长度为n。</li>
<li>从第二个元素开始，将当前元素标记为待插入元素。</li>
<li>将待插入元素与已排序部分（即前面的元素）进行比较，从最后一个元素开始。</li>
<li>如果待插入元素小于已排序部分的某个元素，则将该元素向后移动一个位置，为待插入元素腾出空间。</li>
<li>继续向前比较下一个元素，直到找到待插入元素应该插入的位置或者遍历完已排序部分。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤3至6，直到遍历完所有待排序元素。</li>
</ol>
<p>以下是一个简单示例来说明直接插入排序的步骤：<br>假设待排序序列为[5, 2, 4, 6, 1, 3]</p>
<ol>
<li><p>第一轮：</p>
<ul>
<li>待插入元素为2。与已排序部分中的5比较，2小于5，将5向后移动一个位置。</li>
<li>排序结果：[2, 5, 4, 6, 1, 3]</li>
</ul>
</li>
<li><p>第二轮：</p>
<ul>
<li>待插入元素为4。与已排序部分中的5比较，4小于5，将5向后移动一个位置。</li>
<li>排序结果：[2, 4, 5, 6, 1, 3]</li>
</ul>
</li>
<li><p>第三轮：</p>
<ul>
<li>待插入元素为6。与已排序部分中的5和4比较，6大于5和4，找到待插入位置。</li>
<li>排序结果：[2, 4, 5, 6, 1, 3]</li>
</ul>
</li>
<li><p>第四轮：</p>
<ul>
<li>待插入元素为1。与已排序部分中的6、5、4、2比较，1小于所有元素，将它们向后移动一个位置。</li>
<li>排序结果：[1, 2, 4, 5, 6, 3]</li>
</ul>
</li>
<li><p>第五轮：</p>
<ul>
<li>待插入元素为3。与已排序部分中的6、5、4比较，3小于5和6，找到待插入位置。</li>
<li>排序结果：[1, 2, 3, 4, 5, 6]</li>
</ul>
</li>
</ol>
<p>最终得到的有序序列为[1, 2, 3, 4, 5, 6]。通过重复上述步骤，将每个待插入元素插入到正确的位置上，直到所有元素都被插入为止。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>以下是直接插入排序的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> key<span class="token punctuation">;</span>
    
    <span class="token comment">// 从第二个元素开始</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前待插入元素</span>
        j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 将比key大的元素向后移动</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        
        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span> <span class="token comment">// 插入key到正确位置</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"原始序列："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"排序结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>此代码中，insertionSort函数用于实现直接插入排序算法。在main函数中，我们定义了一个待排序序列arr，并对其进行排序。最终输出排序结果。运行该程序将得到如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">原始序列：5 2 4 6 1 3 
排序结果：1 2 3 4 5 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这是直接插入排序在C语言中的基本实现，通过不断比较和移动元素，将待插入的元素插入到正确的位置上，最终得到有序序列。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>直接插入排序在以下几个场景下可以应用：</p>
<ol>
<li><p><strong>小规模数据集</strong>：当待排序的数据集规模比较小的时候，直接插入排序是一种简单而有效的排序方法。由于其简单的实现和较低的时间复杂度常数，直接插入排序对小规模数据集表现良好。</p>
</li>
<li><p><strong>部分有序数据集</strong>：如果待排序的数据集已经部分有序，即大部分元素已经按照近似的顺序排列，那么直接插入排序的效果会很好。由于该算法每次只移动一个元素，所以对于已经有序或近似有序的部分，插入的代价相对较低。</p>
</li>
<li><p><strong>在线排序</strong>：直接插入排序是一种适用于在线排序的算法，即数据不断到达并需要立即排序。每当新的数据到达时，直接插入排序可将其插入到已排序序列中的正确位置，确保序列始终有序。</p>
</li>
<li><p><strong>稳定性要求</strong>：直接插入排序是一种稳定的排序算法，它保持相等元素之间的相对顺序不变。因此，当排序需要保持稳定性时，直接插入排序是一个很好的选择。</p>
</li>
</ol>
<p>需要注意的是，对于大规模乱序的数据集，直接插入排序的性能可能不如其他高效的排序算法。对于大规模数据集的排序，更适合使用快速排序、归并排序等时间复杂度为O(n log n)的算法。</p>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>直接插入排序的一个常见优化方法是使用二分查找来寻找待插入元素的插入位置，以减少比较操作的次数。这种优化称为二分插入排序。</p>
<p>二分插入排序的基本思想是利用已排序部分的有序性质，通过二分查找找到待插入元素应该插入的位置，从而减少比较次数。</p>
<p>以下是二分插入排序的优化步骤：</p>
<ol>
<li>假设待排序序列为arr，长度为n。</li>
<li>从第二个元素开始，将当前元素标记为待插入元素。</li>
<li>使用二分查找在已排序部分中寻找待插入元素的插入位置。</li>
<li>找到插入位置后，将插入位置之后的元素都向后移动一个位置，腾出空间给待插入元素。</li>
<li>将待插入元素插入到找到的位置上。</li>
<li>重复步骤3至5，直到遍历完所有待排序元素。</li>
</ol>
<p>相比于普通的直接插入排序，二分插入排序减少了比较操作的次数，从而提高了算法的效率。尽管二分插入排序减少了比较次数，但仍然需要进行元素的移动操作，因此其时间复杂度仍为O(n^2)。然而，在某些特定情况下，二分插入排序的优化效果可能更显著，特别是当待排序序列较大或有序度较高时。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理</title>
    <url>/yangtong.github.io/2023/08/03/imageprocess/imageprocess/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>生物学</title>
    <url>/yangtong.github.io/2023/08/02/biology/biology/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>生物学</category>
      </categories>
      <tags>
        <tag>生物学</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/binarysearchtree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/binarytree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/balancedbinarytree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/bplustree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/btree/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/heap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树堆</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/treap/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/trie/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/tree/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>树是一种非线性的数据结构，它由节点（node）组成，并且这些节点之间存在特定的层次关系。树的定义如下：</p>
<p>树是一个包含n（n &gt;&#x3D; 0）个节点的有限集合。</p>
<ul>
<li>如果n &#x3D; 0，则称为空树。</li>
<li>否则，树由一个称为根节点（root）的特殊节点以及其他n - 1个不相交的子树T1、T2、…、Tn组成，每个子树本身也是一棵树。</li>
</ul>
<p>树的目的是用于组织和存储数据，并提供高效地搜索、插入和删除数据的操作。树这种数据结构在计算机科学中应用广泛，常见的应用场景包括：</p>
<ol>
<li><p>层次结构表示：树可以用来表示具有层次关系的数据，例如文件系统的目录结构、网站的导航菜单等。</p>
</li>
<li><p>搜索和排序：二叉搜索树是一种基于树的数据结构，可以快速地搜索和排序数据。它具有良好的查找、插入和删除性能。</p>
</li>
<li><p>表达关联关系：树可以用来表示具有父子关系或关联关系的数据，例如家谱、组织架构图等。</p>
</li>
<li><p>算法实现：许多经典的算法和数据结构都基于树的概念，例如平衡二叉树、堆、哈夫曼树等。</p>
</li>
</ol>
<h2 id="特点与属性"><a href="#特点与属性" class="headerlink" title="特点与属性"></a>特点与属性</h2><p>树这种数据结构具有以下主要特点和属性：</p>
<ol>
<li><p>层次关系：树的节点之间存在层次关系，每个节点都可以有零个或多个子节点，除了根节点外，其他节点都有一个父节点。</p>
</li>
<li><p>根节点和叶子节点：树的顶部节点被称为根节点，它没有父节点。没有子节点的节点称为叶子节点。根据根节点与叶子节点之间的路径长度，树可以被划分为不同的层级。</p>
</li>
<li><p>分支因子：树的分支因子是指每个节点的子节点数量。二叉树是一种特殊的树，每个节点最多只有两个子节点，即分支因子为2。</p>
</li>
<li><p>深度和高度：树的深度是从根节点到任意节点的路径长度。树的高度是从根节点到最远叶子节点的路径长度。</p>
</li>
<li><p>无环性质：树是无环的，即不存在任何节点之间的回路。</p>
</li>
</ol>
<p>树具有以下优势：</p>
<ul>
<li>快速搜索：树的结构使得在包含大量数据时，能够快速搜索目标元素，时间复杂度通常为O(log n)。</li>
<li>插入和删除效率高：树的插入和删除操作通常比线性结构（如数组）的操作效率更高。</li>
<li>数据分层组织：树的层次结构可以方便地表示和操作具有层次关系的数据，例如文件系统的目录结构。</li>
</ul>
<p>然而，树也有一些限制和适用场景：</p>
<ul>
<li>内存消耗：树的节点需要额外的空间来存储子节点的引用，因此在存储大量数据时，可能需要较多的内存空间。</li>
<li>平衡性维护：某些树类型（如二叉搜索树）在插入和删除操作后可能变得不平衡，导致搜索性能下降。为了保持平衡，可能需要额外的操作成本。</li>
<li>不适合有序数据：对于已经有序的数据集合，树的优势可能不明显，可能会选择其他更适合的数据结构。</li>
</ul>
<p>树适用于以下场景：</p>
<ul>
<li>层次关系表示：需要表达分层关系的数据结构，如组织架构、家谱等。</li>
<li>快速搜索：需要在大量数据中快速搜索目标元素，例如数据库索引、哈希表等。</li>
<li>排序和范围查询：树可以支持高效的排序和范围查询操作，例如二叉搜索树和B树。</li>
<li>数据组织和管理：树可以用于管理和组织具有层次结构的数据，例如文件系统、网络路由表等。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>树这种数据结构有以下几种基本操作：</p>
<ol>
<li><p>插入（Insertion）：向树中添加一个新节点。插入操作需要考虑树的特定规则，如二叉搜索树中插入节点时需要保持左子节点小于父节点、右子节点大于父节点的性质。</p>
</li>
<li><p>删除（Deletion）：从树中移除一个节点。删除操作也需要遵循树的规则，例如在二叉搜索树中删除节点时需要调整树结构以保持排序性质。</p>
</li>
<li><p>查找（Search）：在树中搜索指定值或关键字。查找可以是深度优先搜索（DFS）或广度优先搜索（BFS）的形式，具体取决于树的遍历方式。</p>
</li>
<li><p>遍历（Traversal）：按照一定顺序访问树中的所有节点。常见的树遍历算法包括前序遍历、中序遍历和后序遍历，它们定义了节点的访问次序。</p>
</li>
<li><p>最小值和最大值查找：在树中查找最小值和最大值。在二叉搜索树中，最小值位于最左边的叶子节点，最大值位于最右边的叶子节点。</p>
</li>
<li><p>树的高度和大小计算：计算树的高度（从根节点到最远叶子节点的路径长度）和大小（树中节点的总数）。</p>
</li>
<li><p>平衡检查和平衡操作：对于具有平衡性要求的树，例如AVL树或红黑树，需要执行平衡检查和相应的平衡操作，以确保树的高度平衡。</p>
</li>
<li><p>迭代器操作：提供迭代器来顺序访问树的所有元素。迭代器可以按照预定义的顺序遍历树中的节点。</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以下是一个简单的树的C语言实现示例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 树节点结构定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>                 <span class="token comment">// 节点数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> left<span class="token punctuation">;</span>    <span class="token comment">// 左子节点指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span><span class="token operator">*</span> right<span class="token punctuation">;</span>   <span class="token comment">// 右子节点指针</span>
<span class="token punctuation">&#125;</span> TreeNode<span class="token punctuation">;</span>

<span class="token comment">// 创建一个新节点</span>
TreeNode<span class="token operator">*</span> <span class="token function">createNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    TreeNode<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"内存分配失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 插入节点</span>
TreeNode<span class="token operator">*</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">createNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">></span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 在树中搜索指定值</span>
TreeNode<span class="token operator">*</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root<span class="token operator">-></span>data <span class="token operator">==</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 中序遍历打印树节点</span>
<span class="token keyword">void</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> root<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 主函数测试树的功能</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token comment">// 插入节点</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 中序遍历打印树节点</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中序遍历结果："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 搜索节点</span>
    <span class="token keyword">int</span> searchData <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> searchResult <span class="token operator">=</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>searchResult <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"找到了节点 %d\n"</span><span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"未找到节点 %d\n"</span><span class="token punctuation">,</span> searchData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个示例中，我们定义了一个<code>TreeNode</code>结构表示树的节点，在<code>createNode</code>函数中创建了新节点。<code>insertNode</code>函数用于插入新节点到树中，并保持排序性质。<code>searchNode</code>函数用于在树中搜索指定值。<code>inorderTraversal</code>函数用于中序遍历打印树节点。</p>
<p>在主函数中，我们通过调用<code>insertNode</code>函数插入节点到树中，并使用<code>inorderTraversal</code>函数进行中序遍历打印树节点。然后，我们使用<code>searchNode</code>函数搜索特定的值。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/linklist/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>链表是一种常用的动态数据结构，用于存储和组织数据。它由一系列节点（Node）组成，每个节点包含两部分：数据（data）和指向下一个节点的指针（next）。</p>
<p>链表的目的是在内存中灵活地存储和访问数据。与数组不同，链表的节点可以在内存中任意位置分布，而不需要连续的存储空间。这使得链表能够有效地处理插入、删除等操作，并且可以动态地调整大小。</p>
<p>链表有多种类型，其中最常见的两种是单向链表和双向链表。单向链表中，每个节点只有一个指向下一个节点的指针，而双向链表中，每个节点除了指向下一个节点的指针外，还有指向前一个节点的指针。</p>
<p>链表的优点：</p>
<ul>
<li>动态性：链表的大小可以根据需要进行动态调整，支持高效的插入和删除操作。</li>
<li>灵活性：链表可以存储不同类型的数据，节点之间的连接方式也可以根据需求进行变化。</li>
<li>内存利用率高：链表节点可以根据需求分散在内存中，不需要预先分配固定大小的连续空间。</li>
</ul>
<p>链表的缺点：</p>
<ul>
<li>随机访问性能较差：由于链表中的节点不是连续存储的，如果需要访问特定位置的数据，需要从头节点开始遍历。</li>
<li>需要额外的内存空间：链表中的每个节点都需要额外的指针来存储连接关系，这增加了一定的内存开销。</li>
</ul>
<h2 id="特点和属性"><a href="#特点和属性" class="headerlink" title="特点和属性"></a>特点和属性</h2><p>链表的主要特点和属性如下：</p>
<ol>
<li><p>动态性：链表的大小可以根据需要动态调整，支持高效的插入和删除操作。</p>
</li>
<li><p>灵活性：链表可以存储不同类型的数据，节点之间的连接方式也可以根据需求变化。</p>
</li>
<li><p>内存利用率高：链表的节点可以分散在内存中，不需要预先分配固定大小的连续空间。</p>
</li>
<li><p>随机访问性能较差：由于链表中的节点不是连续存储的，如果需要访问特定位置的数据，需要从头节点开始遍历。这导致链表的随机访问效率较低。</p>
</li>
<li><p>额外的指针开销：链表中的每个节点都需要额外的指针来存储连接关系，这增加了一定的内存开销。</p>
</li>
<li><p>时间复杂度分析：链表中插入和删除一个节点的时间复杂度为O(1)，因为只需要修改节点的指针即可。然而，查找特定节点的时间复杂度为O(n)，其中n是链表的长度。</p>
</li>
<li><p>空间要求：链表需要额外的指针来存储连接关系，因此相对于数组等数据结构，链表需要更多的内存空间。</p>
</li>
</ol>
<p>适用场景：</p>
<ul>
<li>当需要频繁执行插入和删除操作，而对查找操作的要求相对较低时，链表是一个很好的选择。</li>
<li>当预先不知道需要存储多少元素时，链表可以动态地调整大小。</li>
<li>在内存有限且大小未知的情况下，链表可以提供更好的空间利用率。</li>
</ul>
<p>限制：</p>
<ul>
<li>如果需要频繁进行随机访问，链表的性能会比较差。在这种情况下，数组可能是更好的选择。</li>
<li>链表需要额外的指针来维护连接关系，因此相对于数组等数据结构，链表会占用更多的内存空间。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>链表支持以下基本操作：</p>
<ol>
<li><p>插入节点（Insertion）：在链表中插入一个新节点。可以在链表的开头、结尾或指定位置插入节点。</p>
</li>
<li><p>删除节点（Deletion）：从链表中删除指定节点。可以根据节点的值或位置来删除。</p>
</li>
<li><p>遍历链表（Traversal）：按顺序访问链表中的每个节点，以便读取或处理节点的数据。</p>
</li>
<li><p>查找节点（Search）：根据给定的值或条件，搜索链表中特定的节点。可以返回第一个匹配的节点或所有匹配的节点。</p>
</li>
<li><p>获取节点数量（Count）：计算链表中节点的数量。</p>
</li>
<li><p>判空（Empty Check）：检查链表是否为空。</p>
</li>
<li><p>反转链表（Reverse）：将链表中的节点顺序反转。</p>
</li>
<li><p>合并链表（Merge）：将两个有序链表合并成一个有序链表。</p>
</li>
<li><p>获取链表长度（Length）：计算链表的长度。</p>
</li>
</ol>
<p>这些操作使得我们能够有效地操作和管理链表中的数据。具体的实现方式会根据链表类型（如单向链表或双向链表）而有所不同。对于每个操作，需要考虑边界情况（如插入&#x2F;删除首尾节点、空链表等）和错误处理（如节点不存在等）以保证链表的正确性和稳定性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以下是一个简单的C语言实现单向链表的例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 定义链表节点结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>           <span class="token comment">// 节点数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>  <span class="token comment">// 指向下一个节点的指针</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token comment">// 插入节点到链表头部</span>
<span class="token keyword">void</span> <span class="token function">insertAtHead</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新节点</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                         <span class="token comment">// 设置节点数据</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>                        <span class="token comment">// 将新节点的指针指向当前头节点</span>
    <span class="token operator">*</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                              <span class="token comment">// 更新头节点为新节点</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 插入节点到链表尾部</span>
<span class="token keyword">void</span> <span class="token function">insertAtTail</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建新节点</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>                         <span class="token comment">// 设置节点数据</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                         <span class="token comment">// 将新节点的指针设置为NULL</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                          <span class="token comment">// 如果链表为空，直接将新节点设为头节点</span>
        <span class="token operator">*</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    Node<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 找到链表的尾节点</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    temp<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>                         <span class="token comment">// 将新节点连接到尾节点的后面</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 删除指定值的节点</span>
<span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>          <span class="token comment">// 用于记录要删除节点的前一个节点</span>
    Node<span class="token operator">*</span> curr <span class="token operator">=</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>         <span class="token comment">// 用于遍历链表</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>data <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果要删除的是头节点</span>
        <span class="token operator">*</span>head <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> curr<span class="token operator">-></span>data <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 查找要删除的节点</span>
        prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>
        curr <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                         <span class="token comment">// 如果没有找到要删除的节点</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Node not found.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    prev<span class="token operator">-></span>next <span class="token operator">=</span> curr<span class="token operator">-></span>next<span class="token punctuation">;</span>                    <span class="token comment">// 将要删除节点的前一个节点指向要删除节点的下一个节点</span>
    <span class="token function">free</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>                                 <span class="token comment">// 释放要删除节点的内存空间</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 打印链表元素</span>
<span class="token keyword">void</span> <span class="token function">printList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> temp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 主函数测试链表操作</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化链表为空</span>

    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">insertAtTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Linked list: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出链表内容：1 2 3</span>

    <span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 删除值为2的节点</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Linked list after deleting node with value 2: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 输出链表内容：1 3</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="应用和示例"><a href="#应用和示例" class="headerlink" title="应用和示例"></a>应用和示例</h2><p>链表在各个领域中有广泛的应用，以下是一些常见的应用和实际示例：</p>
<ol>
<li><p>数据结构实现：链表是许多其他数据结构的基础，比如栈、队列和图等。链表的动态性和灵活性使得它们成为这些数据结构的核心组成部分。</p>
</li>
<li><p>文件系统：文件系统使用链表来组织文件和目录的层次结构。每个目录节点可以包含指向子目录或文件的指针，从而形成一个树状结构。</p>
</li>
<li><p>缓存管理：链表可用于实现缓存替换算法，例如LRU（最近最少使用）算法。LRU缓存将最近使用的项放在链表的头部，当缓存满时，删除链表尾部的项。</p>
</li>
<li><p>高级程序设计语言中的垃圾回收器：链表被广泛用于实现垃圾回收机制。垃圾回收器使用链表来跟踪分配的内存块，并在不再使用时回收这些块。</p>
</li>
<li><p>网络流量管理：链表可以用于追踪路由器或交换机中的网络流量。每个数据包都可以表示为一个节点，并通过链表进行管理和处理。</p>
</li>
<li><p>游戏开发：链表可以用于管理游戏中的对象，如角色、敌人、子弹等。通过链表，可以轻松地添加、删除和遍历游戏对象。</p>
</li>
</ol>
<p>与其他数据结构相比，链表具有一些独特的优势和特点：</p>
<ul>
<li>相对于数组，链表的大小可以动态调整，不需要预先分配固定大小的连续空间。</li>
<li>插入和删除节点的操作效率高，时间复杂度为O(1)。</li>
<li>链表可以存储不同类型的数据，节点之间的连接方式可以根据需要进行变化。</li>
</ul>
<p>然而，链表也有一些限制：</p>
<ul>
<li>随机访问性能较差，需要从头节点开始遍历以获取指定位置的节点。</li>
<li>需要额外的指针来存储连接关系，增加了一定的内存开销。</li>
</ul>
<p>因此，在选择数据结构时，需要根据具体需求权衡利弊。链表适用于频繁插入和删除操作、动态大小需求或对内存空间有限制的场景。在需要快速随机访问和对空间利用率有严格要求的情况下，可能需要考虑其他数据结构，如数组。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/list/</url>
    <content><![CDATA[<blockquote>
<p>队列，又称为伫列（queue），计算机科学中的一种抽象资料类型，是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><p>队列是一种基本的数据结构，用于存储元素集合，并按照先进先出（First-In-First-Out, FIFO）的原则进行管理。它类似于现实生活中排队等待服务的场景。</p>
<p>队列的定义包括以下几个关键点：</p>
<ul>
<li>元素插入操作只能在队列的末尾进行，而元素移除操作只能从队列的开头进行。</li>
<li>插入操作称为入队（enqueue），移除操作称为出队（dequeue）。</li>
<li>队列可以为空，也可以有限制长度。</li>
<li>队列内元素的顺序由其插入的顺序决定，最早插入的元素最先被移除。</li>
</ul>
<p>队列的目的主要在于提供一种有序处理元素的方式，以满足特定的需求。以下是队列的一些常见应用场景和目的：</p>
<ul>
<li>任务调度：使用队列可以按照特定的顺序调度和执行任务，确保任务按照先后顺序完成。</li>
<li>广度优先搜索（BFS）：在图或树的遍历中，使用队列来保存待访问的节点，以确保按层次顺序进行遍历。</li>
<li>缓冲区：队列可以作为缓冲区，允许生产者将数据放入队列，然后消费者按照相同的顺序取出数据进行处理。</li>
<li>管理资源共享：多个进程或线程需要访问共享资源时，使用队列可以确保公平地分配资源，避免数据竞争。</li>
<li>消息传递系统：在分布式系统或通信系统中，消息队列用于实现异步通信，降低系统间耦合性。</li>
</ul>
<h2 id="特点和属性"><a href="#特点和属性" class="headerlink" title="特点和属性"></a>特点和属性</h2><p>队列具有以下主要特点和属性：</p>
<ol>
<li><p>先进先出（FIFO）：最先插入的元素最先被移除，保持元素按照插入顺序进行处理。</p>
</li>
<li><p>插入操作只在队尾：新元素只能被添加到队列的末尾。</p>
</li>
<li><p>移除操作只在队头：只能从队列的开头移除元素。</p>
</li>
<li><p>有限长度或无限长度：队列可以有限长度，即固定容量，也可以是无限长度，即不受容量限制。</p>
</li>
<li><p>空队列和满队列：队列可以为空（没有元素）或满（达到了容量上限）。</p>
</li>
</ol>
<p>对于队列的优势、限制和适用场景，我们可以考虑以下方面的特点：</p>
<ul>
<li><p><strong>复杂度分析</strong>：插入（enqueue）和删除（dequeue）操作的时间复杂度为O(1)，即常数时间。因此，队列操作的效率很高。</p>
</li>
<li><p><strong>空间要求</strong>：队列通常需要连续的内存空间来存储元素。具体的空间需求取决于队列的长度和元素的大小。</p>
</li>
<li><p><strong>操作效率</strong>：由于队列遵循先进先出原则，它在处理需要按照顺序进行的任务时非常有效。然而，如果需要在队列中间插入或删除元素，效率将比较低。</p>
</li>
<li><p><strong>适用场景</strong>：队列在许多应用中都非常有用。例如，广度优先搜索（BFS）算法、任务调度、消息传递系统等都可以使用队列来实现。队列还能够解决需要按照特定顺序处理元素的问题。</p>
</li>
<li><p><strong>限制</strong>：队列的主要限制之一是容量限制。当队列达到其最大容量时，无法再插入新元素，即队列为满状态。此外，由于插入和删除操作只能在两端进行，如果需要频繁地在队列中间执行插入或删除操作，可能会导致性能下降。</p>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>要实现和使用队列，我们可以考虑以下几个基本操作：插入（enqueue）、删除（dequeue）和查找队首元素（peek）。下面是一种基本的队列实现方式：</p>
<ol>
<li><p>使用数组：我们可以使用数组来实现队列。创建一个固定大小的数组，并定义两个指针front和rear。</p>
</li>
<li><p>插入（enqueue）操作：</p>
<ul>
<li>检查队列是否已满。如果rear指针等于数组的长度减1，表示队列已满。</li>
<li>将新元素添加到rear指针所在位置的后一位。</li>
<li>更新rear指针，使其指向新添加的元素。</li>
</ul>
</li>
<li><p>删除（dequeue）操作：</p>
<ul>
<li>检查队列是否为空。如果front指针等于rear指针，表示队列为空。</li>
<li>移除front指针所在位置的元素。</li>
<li>更新front指针，使其指向下一个元素。</li>
</ul>
</li>
<li><p>查找队首元素（peek）操作：</p>
<ul>
<li>检查队列是否为空。如果front指针等于rear指针，表示队列为空。</li>
<li>返回front指针所在位置的元素。</li>
</ul>
</li>
</ol>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>以下是使用数组实现队列的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义队列结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front<span class="token punctuation">;</span>
    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span>

<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否为空</span>
<span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否已满</span>
<span class="token keyword">int</span> <span class="token function">isFull</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>rear <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入队操作</span>
<span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is full. Cannot enqueue %d\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    queue<span class="token operator">-></span>rear<span class="token operator">++</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d enqueued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出队操作</span>
<span class="token keyword">int</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot dequeue.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> queue<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d dequeued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 查找队首元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot peek.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> queue<span class="token operator">-></span>data<span class="token punctuation">[</span>queue<span class="token operator">-></span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Queue myQueue<span class="token punctuation">;</span>
    <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element after dequeuing: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述示例代码中，我们使用了一个包含固定大小数组的队列结构体。通过<code>initQueue</code>函数初始化队列，并用<code>enqueue</code>和<code>dequeue</code>函数进行元素的入队和出队操作。<code>peek</code>函数用于查找队首元素。最后，在<code>main</code>函数中展示了如何创建队列、进行基本操作，并输出一些结果。</p>
<p>以下是使用链表实现队列的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token comment">// 定义链表节点结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Node<span class="token punctuation">;</span>

<span class="token comment">// 定义队列结构体</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> front<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> rear<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Queue<span class="token punctuation">;</span>

<span class="token comment">// 初始化队列</span>
<span class="token keyword">void</span> <span class="token function">initQueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断队列是否为空</span>
<span class="token keyword">int</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-></span>rear <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入队操作</span>
<span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Node<span class="token operator">*</span> newNode <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>data <span class="token operator">=</span> value<span class="token punctuation">;</span>
    newNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>rear<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d enqueued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出队操作</span>
<span class="token keyword">int</span> <span class="token function">dequeue</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot dequeue.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> temp <span class="token operator">=</span> queue<span class="token operator">-></span>front<span class="token punctuation">;</span>
    value <span class="token operator">=</span> temp<span class="token operator">-></span>data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token operator">-></span>front <span class="token operator">==</span> queue<span class="token operator">-></span>rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        queue<span class="token operator">-></span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        queue<span class="token operator">-></span>front <span class="token operator">=</span> queue<span class="token operator">-></span>front<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d dequeued successfully.\n"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 查找队首元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Queue<span class="token operator">*</span> queue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Queue is empty. Cannot peek.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> queue<span class="token operator">-></span>front<span class="token operator">-></span>data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Queue myQueue<span class="token punctuation">;</span>
    <span class="token function">initQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

    frontElement <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>myQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Front element after dequeuing: %d\n"</span><span class="token punctuation">,</span> frontElement<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在上述示例代码中，我们使用一个包含链表节点的队列结构体。通过<code>initQueue</code>函数初始化队列，并用<code>enqueue</code>和<code>dequeue</code>函数进行元素的入队和出队操作。<code>peek</code>函数用于查找队首元素。最后，在<code>main</code>函数中展示了如何创建队列、进行基本操作，并输出一些结果。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/yangtong.github.io/2023/07/28/datastruct/stack/</url>
    <content><![CDATA[<blockquote>
<p>堆栈（stack）又称为栈或堆叠，是计算机科学中的一种抽象资料类型，只允许在有序的线性资料集合的一端（称为堆栈顶端，top）进行加入数据（push）和移除数据（pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作，堆栈常用一维数组或链接串列来实现。常与另一种有序的线性资料集合队列相提并论。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义与目的"><a href="#定义与目的" class="headerlink" title="定义与目的"></a>定义与目的</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种线性数据结构，用于存储和管理数据元素。它支持两个主要操作：压入（Push）将元素添加到栈的顶部，弹出（Pop）从栈的顶部移除元素。栈还提供了一个检查栈顶元素的操作（Top）。</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>栈通常被用于需要按照特定顺序处理或管理元素的场景。它可以帮助实现递归算法、括号匹配、表达式求值、函数调用等。栈的设计目的是提供一种快速有效的数据访问方式，并且在插入和删除元素时具有常数时间复杂度。</p>
<h2 id="特点与属性"><a href="#特点与属性" class="headerlink" title="特点与属性"></a>特点与属性</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>后进先出（LIFO）：栈中最后插入的元素是第一个被访问和移除的。</li>
<li>仅允许在栈顶进行操作：只能对栈顶元素进行插入、删除、查看等操作，而不能直接访问或修改其他元素。</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>简单高效：栈的操作时间复杂度为O(1)，即常数时间，因为只需修改栈顶指针即可。</li>
<li>节省空间：栈可以使用连续的内存块实现，不需要额外的指针或链表结构。</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>容量限制：栈的容量可能有限，当栈满时无法再插入新元素，可能导致溢出错误。</li>
<li>访问限制：只能访问栈顶元素，如果需要访问其他位置的元素，需要先将栈顶元素出栈。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>函数调用栈：用于保存函数调用过程中的局部变量、返回地址等信息。</li>
<li>表达式求值：用于计算中缀表达式转换为后缀表达式，并进行运算。</li>
<li>括号匹配：用于检查表达式中的括号是否匹配。</li>
<li>历史记录：用于实现撤销、恢复等操作。</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：栈的插入、删除、查看等操作都只涉及栈顶元素，时间复杂度为O(1)。</li>
<li>空间复杂度：栈的空间复杂度与存储的元素数量成线性关系，即O(n)，其中n为栈中元素的个数。但通常情况下，栈的空间需求不会随输入规模的增长而线性增加，因为栈可以重复利用已分配的内存空间。</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>栈可以通过数组或链表来实现。下面将涵盖基本的操作，包括插入（压栈）、删除（弹栈）和查找（获取栈顶元素）。</p>
<ol>
<li>使用数组实现栈：</li>
</ol>
<ul>
<li>创建一个数组，并定义一个指针top用于记录栈顶位置。</li>
<li>插入（压栈）操作：将元素添加到top指向的位置，并将top加1。</li>
<li>删除（弹栈）操作：将top减1，并返回top指向的元素作为弹栈结果。</li>
<li>查找（获取栈顶元素）操作：返回top指向的元素。</li>
</ul>
<ol start="2">
<li>使用链表实现栈：</li>
</ol>
<ul>
<li>创建一个链表，并定义一个指针top指向链表的头部（栈顶）。</li>
<li>插入（压栈）操作：创建一个新节点，将其链接到链表的头部，并更新top指针指向新节点。</li>
<li>删除（弹栈）操作：移动top指针到下一个节点，并返回原top指向的节点的值作为弹栈结果。</li>
<li>查找（获取栈顶元素）操作：返回top指向的节点的值。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p>以下是使用数组实现栈的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义栈结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> stack<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Stack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否为空</span>
<span class="token keyword">int</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否已满</span>
<span class="token keyword">int</span> <span class="token function">is_full</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入栈操作</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Overflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出栈操作</span>
<span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Underflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 获取栈顶元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Stack my_stack<span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试入栈操作</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试出栈操作</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试获取栈顶元素</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Top element: %d\n"</span><span class="token punctuation">,</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>以下是使用链表实现栈的示例代码（C语言）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span>

<span class="token comment">// 定义栈结构</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> stack<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> top<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Stack<span class="token punctuation">;</span>

<span class="token comment">// 初始化栈</span>
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    s<span class="token operator">-></span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否为空</span>
<span class="token keyword">int</span> <span class="token function">is_empty</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 判断栈是否已满</span>
<span class="token keyword">int</span> <span class="token function">is_full</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>s<span class="token operator">-></span>top <span class="token operator">==</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 入栈操作</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> item<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_full</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Overflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 出栈操作</span>
<span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack Underflow\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span><span class="token punctuation">(</span>s<span class="token operator">-></span>top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 获取栈顶元素</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack<span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_empty</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Stack is Empty\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> s<span class="token operator">-></span>stack<span class="token punctuation">[</span>s<span class="token operator">-></span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Stack my_stack<span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试入栈操作</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试出栈操作</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Popped: %d\n"</span><span class="token punctuation">,</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 测试获取栈顶元素</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Top element: %d\n"</span><span class="token punctuation">,</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="应用和示例"><a href="#应用和示例" class="headerlink" title="应用和示例"></a>应用和示例</h2><p>栈作为一种简单高效的数据结构，在各个领域中有许多常见应用和实际示例。以下是一些常见的应用和示例：</p>
<ol>
<li><p>函数调用栈：栈在编程语言中的函数调用过程中发挥着重要作用。每当一个函数被调用，栈会保存调用前的状态（如返回地址、局部变量等），以便在函数执行完毕后能够正确返回到调用点。</p>
</li>
<li><p>表达式求值：在表达式求值过程中，栈可以用于转换中缀表达式为后缀表达式，并进行运算。栈可用于保存操作符，按照优先级对操作符进行排序，并确保正确的计算顺序。</p>
</li>
<li><p>括号匹配：栈在括号匹配中非常有用。通过遍历字符串中的字符，将左括号入栈，当遇到右括号时，检查栈顶元素是否与其对应的左括号匹配。如果匹配，则弹出栈顶元素；如果不匹配，则括号不匹配。</p>
</li>
<li><p>十进制转二进制&#x2F;十六进制：使用栈可以将十进制数转换为二进制或十六进制。通过对十进制数连续进行除法操作，并将余数入栈，最后将栈中的余数依次出栈即可得到相应的二进制或十六进制表示。</p>
</li>
<li><p>撤销&#x2F;恢复操作：在编辑器、图形界面设计等应用中，栈可以用于实现撤销和恢复功能。每次用户执行操作时，将操作记录保存在栈中。当用户希望撤销操作时，从栈中弹出最近的操作，并对应地进行撤销操作。</p>
</li>
</ol>
<p>与其他数据结构相比，栈具有自身的优势和适用性。相对于数组，栈的插入和删除操作更加高效，并且不需要预先知道存储元素的数量。与链表相比，栈仅涉及栈顶元素的操作，没有指针域的访问和修改，因此操作更加简单有效。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>多维数组</title>
    <url>/yangtong.github.io/2023/07/14/datastruct/multarray/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>多维数组是一种扩展的数组数据结构，用于存储具有多个维度的元素集合。与一维数组类似，多维数组也提供了连续的内存空间来存储数据，并使用多个索引来访问和操作元素。以下是对多维数组的概述：</p>
<p>多维数组是一种灵活且强大的数据结构，常用于矩阵、图像处理、科学计算等领域。它提供了一种有效的方式来组织和操作具有多个维度的数据集合，使得数据的表示和处理更加直观和高效。</p>
<span id="more"></span>
<h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p>多维数组是一个具有多个维度的数据集合，其中的元素具有相同的数据类型。每个维度代表一个独立的索引范围，用于标识元素在多维数组中的位置。例如，二维数组由行和列两个维度组成，可以通过行和列的索引来访问元素。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>多维数组在内存中以类似于矩阵的方式排列，其中的元素按照行优先或列优先的顺序存储。在二维数组中，每行的元素紧邻存放，而各行之间相隔整个一行大小的内存空间。三维及更高维度的数组也遵循类似的规则。</p>
<h2 id="索引和访问"><a href="#索引和访问" class="headerlink" title="索引和访问"></a>索引和访问</h2><p>多维数组的元素可以通过多个索引进行访问和操作。对于二维数组，可以使用两个索引（行索引和列索引）来指定元素的位置。例如，要访问二维数组arr中的第i行、第j列的元素，可以使用arr[i][j]来获取或修改该元素的值。</p>
<h2 id="大小和边界检查"><a href="#大小和边界检查" class="headerlink" title="大小和边界检查"></a>大小和边界检查</h2><p>多维数组的大小在创建时指定，并且各个维度的大小可以不相同。在访问多维数组元素时，需要确保每个索引在其对应维度范围内以避免越界错误。</p>
<h2 id="多维数组的优点和缺点"><a href="#多维数组的优点和缺点" class="headerlink" title="多维数组的优点和缺点"></a>多维数组的优点和缺点</h2><ul>
<li>优点：多维数组提供了一种方便的方式来存储和处理具有多个维度的数据。它可以直观地表示复杂的结构和关系，并提供高效的元素访问能力。</li>
<li>缺点：多维数组可能会占用较大的内存空间，尤其是当维度较高时。另外，多维数组的创建和操作可能更复杂和容易出错，特别是在维度和索引管理方面。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>一般形式如下</p>
<pre class="line-numbers language-none"><code class="language-none">type name[size1][size2]...[sizeN];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>例如，下面的声明创建了一个三维 5 x 10 x 4 整型数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> threedim<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">type arrayName [ x ][ y ];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，type 可以是任意有效的 C 数据类型，arrayName 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/yangtong.github.io/images/muarray.png"></p>
<p>因此，数组中的每个元素是使用形式为 a[ i , j ] 的元素名称来标识的，其中 a 是数组名称，i 和 j 是唯一标识 a 中每个元素的下标。</p>
<h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><p>多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  
 <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span> <span class="token punctuation">,</span>   <span class="token comment">/*  初始化索引号为 0 的行 */</span>
 <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">&#125;</span> <span class="token punctuation">,</span>   <span class="token comment">/*  初始化索引号为 1 的行 */</span>
 <span class="token punctuation">&#123;</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">&#125;</span>   <span class="token comment">/*  初始化索引号为 2 的行 */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内部嵌套的括号是可选的，下面的初始化与上面是等同的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 定义并初始化一个2x3的二维数组</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="访问二维数组元素"><a href="#访问二维数组元素" class="headerlink" title="访问二维数组元素"></a>访问二维数组元素</h3><p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> val <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
   <span class="token comment">/* 一个带有 5 行 2 列的数组 */</span>
   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
 
   <span class="token comment">/* 输出数组中每个元素的值 */</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a[%d][%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
   <span class="token punctuation">&#125;</span>
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<pre class="line-numbers language-none"><code class="language-none">a[0][0] &#x3D; 0
a[0][1] &#x3D; 0
a[1][0] &#x3D; 1
a[1][1] &#x3D; 2
a[2][0] &#x3D; 2
a[2][1] &#x3D; 4
a[3][0] &#x3D; 3
a[3][1] &#x3D; 6
a[4][0] &#x3D; 4
a[4][1] &#x3D; 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/yangtong.github.io/2023/07/14/datastruct/array/</url>
    <content><![CDATA[<blockquote>
<p>在计算机科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
</blockquote>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数组是一种常见的数据结构，用于存储相同类型的元素的集合。它提供了一种连续的内存空间来存储数据，并使用索引来访问和操作元素。</p>
<p>数组是一种简单但强大的数据结构，广泛应用于编程和算法中。它提供了高效的元素访问和处理能力，适合用于存储和处理静态或有序的数据集合。</p>
<h2 id="定义和特点"><a href="#定义和特点" class="headerlink" title="定义和特点"></a>定义和特点</h2><p>数组是一个有序的数据集合，其中的元素具有相同的数据类型。数组的大小（即元素数量）在创建时就确定，并且通常在运行时不可更改。每个数组元素都有一个唯一的索引，用于标识其在数组中的位置。</p>
<p><img src="/yangtong.github.io/images/array1.png"></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>数组在内存中以连续的方式存储元素。这意味着数组的各个元素占用相邻的内存地址，可以通过偏移量和元素大小来计算和访问特定索引处的元素。由于连续的内存分配，数组具有快速的随机访问能力。</p>
<h2 id="索引和访问"><a href="#索引和访问" class="headerlink" title="索引和访问"></a>索引和访问</h2><p>数组中的元素可以通过索引进行访问和操作。索引通常从0开始，依次递增。例如，要访问数组arr中的第i个元素，可以使用arr[i]来获取或修改该元素的值。由于索引从0开始，因此最后一个元素的索引是数组大小减1。</p>
<h2 id="大小和边界检查"><a href="#大小和边界检查" class="headerlink" title="大小和边界检查"></a>大小和边界检查</h2><p>数组的大小在创建时指定，并且不能动态调整。因此，在使用数组之前，需要明确知道数组的大小。在访问数组元素时，应进行边界检查以确保索引不超出数组范围，否则可能导致访问越界错误。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>除了一维数组外，还可以创建多维数组，如二维、三维等。多维数组在内存中以类似于矩阵的方式排列，通过多个索引来访问元素。例如，二维数组可以使用arr[i][j]的形式来访问其中的元素。</p>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><ul>
<li>优点：快速随机访问，节省内存空间，直观表示数据的顺序性。</li>
<li>缺点：大小固定，插入和删除元素的操作效率低，如果需要频繁改变大小或执行插入&#x2F;删除操作，使用动态数据结构（如链表）更合适。</li>
</ul>
<h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    array<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"数组长度为: %d\n"</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
   <span class="token keyword">int</span> n<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* n 是一个包含 10 个整数的数组 */</span>
   <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
 
   <span class="token comment">/* 初始化数组元素 */</span>         
   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
        n<span class="token punctuation">[</span> i <span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* 设置元素 i 为 i + 100 */</span>
   <span class="token punctuation">&#125;</span>
   
   <span class="token comment">/* 输出数组中每个元素的值 */</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Element[%d] = %d\n"</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> n<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++</title>
    <url>/yangtong.github.io/2023/07/10/cplusplus/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言</title>
    <url>/yangtong.github.io/2023/07/10/c/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11</title>
    <url>/yangtong.github.io/2023/07/10/cplusplus11/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++11</category>
      </categories>
      <tags>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件</title>
    <url>/yangtong.github.io/2023/07/10/middleware/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/yangtong.github.io/2023/07/10/algorihtm/algorihtm/</url>
    <content><![CDATA[<blockquote>
<p>算法（英语：algorithm），在数学（算学）和计算机科学之中，指一个被定义好的、计算机可施行其指示的有限步骤或次序[1]，常用于计算、数据处理和自动推理。算法是有效方法，包含一系列定义清晰的指令[2]，并可于有限的时间及空间内清楚的表述出来[3]。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>算法具有以下几个主要特点：</p>
<ol>
<li><p>输入：算法接受输入数据，这些数据可能是预先给定的或通过外部来源获取的。</p>
</li>
<li><p>输出：算法产生输出结果，输出可以是一个值、一组值、数据结构、文件等。</p>
</li>
<li><p>确定性：算法中的每一步都必须明确定义，无二义性。对于相同的输入，算法将始终产生相同的输出。</p>
</li>
<li><p>有限性：算法必须在有限的步骤之后终止。这是因为算法中不能包含无限循环或递归。</p>
</li>
<li><p>可行性：算法的每个步骤都必须可行，即能够在有限时间内执行完成。</p>
</li>
<li><p>独立性：算法应该是独立的，即不依赖于特定的硬件或操作系统。</p>
</li>
<li><p>利用资源：算法可以使用计算机的处理能力、内存空间和其他资源，以实现所需的计算过程。</p>
</li>
<li><p>优化性能：好的算法应该尽量优化性能，例如时间复杂度和空间复杂度，以提高执行效率。</p>
</li>
<li><p>可读性：算法应该易于理解和阅读，使人们能够理解其思想和实现。</p>
</li>
<li><p>可扩展性：算法应该能够在需要时进行扩展和修改，以适应不同的数据规模或问题要求。</p>
</li>
</ol>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p>评估算法的复杂度是为了衡量算法在不同输入规模下所需的计算资源（如时间和空间）的增长情况。常用的评估指标包括时间复杂度和空间复杂度。</p>
<ol>
<li><p>时间复杂度（Time Complexity）：表示算法执行所需的时间量级。它描述了算法运行时间随着输入规模增加而增长的速率。通常使用大 O 记法来表示时间复杂度。例如，O(1) 表示常数时间复杂度，O(log n) 表示对数时间复杂度，O(n) 表示线性时间复杂度，O(n^2) 表示平方时间复杂度等。时间复杂度可以帮助我们比较不同算法之间的效率，并预测算法在大型输入上的表现。</p>
</li>
<li><p>空间复杂度（Space Complexity）：表示算法所需的额外空间或内存的量级。它描述了算法消耗的空间随着输入规模增加而增长的速率。类似于时间复杂度，空间复杂度也使用大 O 记法来表示。例如，O(1) 表示常数空间复杂度，O(n) 表示线性空间复杂度，O(n^2) 表示平方空间复杂度等。空间复杂度可以帮助我们评估算法在内存使用方面的效率，并预测算法在大规模数据上的可行性。</p>
</li>
</ol>
<p>评估算法复杂度时，需要考虑最坏情况下的时间和空间消耗。通常关注最高阶的项，忽略低阶项和常数因子，以及对于非常大的输入规模，更关注增长最快的项。</p>
<p>通过分析和评估算法的复杂度，我们可以选择更有效的算法来解决问题，并做出合理的时间和空间优化。</p>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>常见的算法有很多，以下列举了一些常见的算法：</p>
<h3 id="排序算法（Sorting-Algorithms）"><a href="#排序算法（Sorting-Algorithms）" class="headerlink" title="排序算法（Sorting Algorithms）"></a>排序算法（Sorting Algorithms）</h3><ol>
<li><p>冒泡排序（Bubble Sort）：重复比较相邻的两个元素，如果顺序错误则交换它们。通过多次遍历，将最大（或最小）的元素逐渐移到数组的末尾。</p>
</li>
<li><p>插入排序（Insertion Sort）：将未排序部分的每个元素插入到已排序部分的合适位置。从第二个元素开始，逐个将元素插入到前面已排序的部分。</p>
</li>
<li><p>选择排序（Selection Sort）：在未排序部分中选择最小（或最大）的元素，并将其与未排序部分的第一个元素进行交换。通过多次遍历，将最小（或最大）的元素逐渐移到数组的开头。</p>
</li>
<li><p>快速排序（Quick Sort）：选择一个基准元素，将数组分成两个子数组，使得左子数组所有元素都小于基准，右子数组所有元素都大于基准，然后对子数组递归地应用快速排序。</p>
</li>
<li><p>归并排序（Merge Sort）：将数组不断二分，直到只剩一个元素，然后将这些单个元素按顺序合并为有序数组。通过递归不断合并，最终得到完全有序的数组。</p>
</li>
<li><p>堆排序（Heap Sort）：将待排序的元素构建成一个堆，然后反复从堆顶取出最大（或最小）的元素，并将其与堆的最后一个位置交换，再重新调整堆，直到所有元素都排序完成。</p>
</li>
<li><p>希尔排序（Shell Sort）：将待排序的元素按一定间隔分组，然后对每个分组进行插入排序。逐渐缩小间隔，直到间隔为1，最后进行一次完整的插入排序。</p>
</li>
<li><p>计数排序（Counting Sort）：统计数组中每个元素的出现次数，并根据统计信息将元素按顺序放置在输出数组中。适用于有限范围内的整数排序。</p>
</li>
<li><p>桶排序（Bucket Sort）：将元素分布在不同的桶中，然后对每个桶中的元素进行排序，最后按顺序将各个桶中的元素合并起来。</p>
</li>
<li><p>基数排序（Radix Sort）：按照元素的位数依次对元素进行排序。先按最低有效位排序，然后按次低有效位排序，以此类推，直到最高有效位。</p>
</li>
</ol>
<h3 id="搜索算法（Searching-Algorithms）"><a href="#搜索算法（Searching-Algorithms）" class="headerlink" title="搜索算法（Searching Algorithms）"></a>搜索算法（Searching Algorithms）</h3><ol>
<li><p>线性搜索（Linear Search）：从数据集的开头开始，逐个比较元素，直到找到目标元素或遍历完整个数据集。</p>
</li>
<li><p>二分搜索（Binary Search）：仅适用于已排序的数据集。将数据集分成两部分，并根据目标值与中间值的大小关系，确定目标值在哪一部分，然后再在该部分进行继续二分搜索。</p>
</li>
<li><p>广度优先搜索（BFS，Breadth-First Search）：从一个起始节点开始，逐层扩展搜索，先访问离起始节点最近的节点，再访问其邻居节点，以此类推。常用于寻找最短路径等问题。</p>
</li>
<li><p>深度优先搜索（DFS，Depth-First Search）：从一个起始节点开始，沿着路径尽可能深入，直到无法继续为止，然后回溯并探索其他路径。通常使用递归或栈实现。</p>
</li>
<li><p>A<em>搜索（A</em> Search）：是一种启发式搜索算法，结合了广度优先搜索和贪心算法的思想。通过估计函数来评估每个节点的优先级，并选择具有最低优先级的节点进行扩展，以找到最优解。</p>
</li>
<li><p>Dijkstra算法（Dijkstra’s Algorithm）：用于在加权图中找到单源最短路径。从起始节点开始，逐步选择距离最小的节点，并更新到达其他节点的累积距离。</p>
</li>
<li><p>Bellman-Ford算法（Bellman-Ford’s Algorithm）：用于在有向图中找到单源最短路径，可以处理带有负权边的图。通过迭代松弛操作来逐步更新节点的最短路径估计。</p>
</li>
<li><p>深度受限搜索（Depth-Limited Search）：与深度优先搜索类似，但限制深度以避免无限循环。适用于深度过大导致嵌套层数过多的情况。</p>
</li>
<li><p>迭代加深搜索（Iterative Deepening Search）：结合了深度受限搜索和广度优先搜索的优点，在每次迭代中递增限制的深度，以逐渐扩展搜索范围。</p>
</li>
<li><p>双向搜索（Bidirectional Search）：同时从起始节点和目标节点开始搜索，逐步扩展搜索，直到两个搜索方向相交为止。常用于寻找两个节点之间的最短路径。</p>
</li>
</ol>
<h3 id="图算法（Graph-Algorithms）"><a href="#图算法（Graph-Algorithms）" class="headerlink" title="图算法（Graph Algorithms）"></a>图算法（Graph Algorithms）</h3><ol>
<li><p>深度优先搜索（DFS，Depth-First Search）：从一个起始节点开始，沿着路径尽可能深入，直到无法继续为止，然后回溯并探索其他路径。DFS可以用于遍历图中的所有节点或查找特定节点。</p>
</li>
<li><p>广度优先搜索（BFS，Breadth-First Search）：从一个起始节点开始，逐层扩展搜索，先访问离起始节点最近的节点，再访问其邻居节点，以此类推。BFS通常用于寻找最短路径等问题。</p>
</li>
<li><p>最小生成树算法（Minimum Spanning Tree）：例如Prim算法和Kruskal算法，用于找到连接图中所有节点的最小权重边的集合，形成一棵无环的树。</p>
</li>
<li><p>单源最短路径算法（Single Source Shortest Path）：例如Dijkstra算法和Bellman-Ford算法，用于在加权图中找到从一个节点到其他所有节点的最短路径。</p>
</li>
<li><p>全源最短路径算法（All Pairs Shortest Path）：例如Floyd-Warshall算法，用于找到图中任意两个节点之间的最短路径。</p>
</li>
<li><p>拓扑排序（Topological Sorting）：用于有向无环图(DAG)中将节点线性排序，使得每个节点在排序中都出现在它的后继节点之前。</p>
</li>
<li><p>强连通分量算法（Strongly Connected Components）：例如Tarjan算法和Kosaraju算法，用于将图中的节点划分为强连通分量，即在分量内任意两个节点都可以互相到达。</p>
</li>
<li><p>最大流算法（Maximum Flow）：例如Ford-Fulkerson算法和Edmonds-Karp算法，用于在有向图中找到从源节点到汇节点的最大可行流量。</p>
</li>
<li><p>最小割算法（Minimum Cut）：例如Karger算法，用于在无向图中找到将图分割成两个部分的最小边权重总和。</p>
</li>
<li><p>图染色算法（Graph Coloring）：例如贪心算法和回溯算法，用于给图中的节点分配颜色，使得相邻节点具有不同的颜色。</p>
</li>
</ol>
<h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><p>动态规划是一种常用的优化问题求解方法，常见的动态规划算法有以下几种：</p>
<ol>
<li><p>最长公共子序列（Longest Common Subsequence）：用于找到两个序列（字符串、数组等）中最长的公共子序列的长度。</p>
</li>
<li><p>背包问题（Knapsack Problem）：包括0&#x2F;1背包问题和无限背包问题，用于在给定容量限制下选择物品以达到最大价值或最小重量。</p>
</li>
<li><p>最长递增子序列（Longest Increasing Subsequence）：在一个序列中找到最长的递增子序列的长度。</p>
</li>
<li><p>切割钢条问题（Cutting Rod Problem）：给定一根长度为n的钢条和对应价格表，找到切割方案使得售出的价值最大化。</p>
</li>
<li><p>矩阵链乘法（Matrix Chain Multiplication）：给定一系列矩阵的大小，确定它们相乘的最佳顺序，使得计算乘法运算的总次数最少。</p>
</li>
<li><p>最长公共子串（Longest Common Substring）：在两个字符串中找到最长的公共连续子串的长度。</p>
</li>
<li><p>编辑距离（Edit Distance）：计算将一个字符串转换成另一个字符串所需的最少操作次数，允许插入、删除和替换操作。</p>
</li>
<li><p>最大子数组和（Maximum Subarray Sum）：在一个数组中找到连续子数组的和的最大值。</p>
</li>
<li><p>最优二叉搜索树（Optimal Binary Search Tree）：在给定的一组关键字和它们对应的概率下，构建一个具有最小搜索代价的二叉搜索树。</p>
</li>
<li><p>最长路径问题（Longest Path Problem）：在一个加权有向图中找到从起始节点到目标节点的最长路径。</p>
</li>
</ol>
<h3 id="贪心算法（Greedy-Algorithms）"><a href="#贪心算法（Greedy-Algorithms）" class="headerlink" title="贪心算法（Greedy Algorithms）"></a>贪心算法（Greedy Algorithms）</h3><p>一种每次选择局部最优解以期望获得全局最优解的算法。</p>
<ol>
<li><p>贪心选择性质（Greedy-choice Property）：在每个步骤中，选择最佳的局部解，以期望最终获得全局最优解。</p>
</li>
<li><p>活动选择问题（Activity Selection Problem）：给定一组活动，每个活动都有开始时间和结束时间，要求选择出最大数量的互不相交的活动。</p>
</li>
<li><p>哈夫曼编码（Huffman Coding）：通过构建最优二叉树，将出现频率高的字符用更短的编码表示，而出现频率低的字符用更长的编码表示。</p>
</li>
<li><p>最小生成树（Minimum Spanning Tree）：在一个加权连通图中，找到一棵包含所有顶点的树，并且边的权重之和最小。</p>
</li>
<li><p>最短路径问题（Shortest Path Problem）：在带权重的有向图或无向图中，找到从起点到目标点的路径，使得路径上各边的权重之和最小。</p>
</li>
<li><p>背包问题（Knapsack Problem）：给定一组物品以及它们的价值和重量，在限制总重量的情况下选择物品，使得总价值最大化。</p>
</li>
</ol>
<h3 id="回溯算法（Backtracking-Algorithms）"><a href="#回溯算法（Backtracking-Algorithms）" class="headerlink" title="回溯算法（Backtracking Algorithms）"></a>回溯算法（Backtracking Algorithms）</h3><p>回溯算法是一种通过穷举所有可能的解并逐步构建可行解的算法。常见的回溯算法有以下几种：</p>
<ol>
<li><p>八皇后问题（Eight Queens Problem）：在8×8的棋盘上放置8个皇后，使得它们互不攻击（即不在同一行、同一列或同一对角线上）。</p>
</li>
<li><p>正则表达式匹配（Regular Expression Matching）：判断一个字符串是否与给定的正则表达式匹配。</p>
</li>
<li><p>数独问题（Sudoku Problem）：填充一个9×9的数独盘面，使得每一行、每一列和每个小九宫格内的数字都是1到9且不重复。</p>
</li>
<li><p>字符串的全排列（Permutations of a String）：生成一个字符串的所有可能排列组合。</p>
</li>
<li><p>子集问题（Subset Problem）：找出一个集合的所有子集。</p>
</li>
<li><p>图的哈密顿回路（Hamiltonian Cycle in a Graph）：判断一个无向图是否存在一条哈密顿回路，即一条遍历所有节点且不重复的闭合路径。</p>
</li>
<li><p>图的着色问题（Graph Coloring Problem）：为一个图的每个节点分配颜色，使得相邻节点拥有不同的颜色。</p>
</li>
<li><p>寻找单词（Word Search）：在一个字符矩阵中查找是否存在给定的单词。</p>
</li>
<li><p>子集和问题（Subset Sum Problem）：判断一个给定集合中是否存在一个子集，使得子集中元素的和等于给定目标值。</p>
</li>
<li><p>旅行商问题（Traveling Salesman Problem）：找到一条路径，使得访问所有城市且回到起始城市的总路径最短。</p>
</li>
</ol>
<h3 id="分治算法（Divide-and-Conquer-Algorithms）"><a href="#分治算法（Divide-and-Conquer-Algorithms）" class="headerlink" title="分治算法（Divide and Conquer Algorithms）"></a>分治算法（Divide and Conquer Algorithms）</h3><p>一种将问题分解为更小的子问题，并将子问题的解合并以获得原始问题解的算法，如归并排序、快速排序等。</p>
<ol>
<li><p>快速排序（Quick Sort）：将待排序数组划分为两个子数组，然后分别对子数组进行递归地快速排序。</p>
</li>
<li><p>归并排序（Merge Sort）：将待排序数组分成两部分，分别对两部分进行归并排序，然后再将已排序的子数组合并成一个有序数组。</p>
</li>
<li><p>傅里叶变换（Fast Fourier Transform, FFT）：通过将信号分解成频域上的频率分量，应用分治思想来高效计算信号的傅里叶变换。</p>
</li>
<li><p>棋盘覆盖问题（Chessboard Coverage Problem）：将一个棋盘按特定规则分割为不同大小的若干块，然后使用分治策略解决覆盖问题。</p>
</li>
<li><p>最接近点对问题（Closest Pair of Points Problem）：在给定的点集中找到最近的一对点，利用分治算法的思想来高效解决。</p>
</li>
<li><p>Karatsuba乘法算法：用于高精度乘法的算法，通过将乘法运算分解为较小的子乘法来提高计算效率。</p>
</li>
</ol>
<h3 id="字符串匹配算法（String-Matching-Algorithms）"><a href="#字符串匹配算法（String-Matching-Algorithms）" class="headerlink" title="字符串匹配算法（String Matching Algorithms）"></a>字符串匹配算法（String Matching Algorithms）</h3><ol>
<li><p>暴力匹配算法（Brute Force）：也称为朴素匹配算法，从文本串中的每个位置开始与模式串逐个字符进行比较，直到找到匹配或遍历完整个文本串。</p>
</li>
<li><p>KMP算法（Knuth-Morris-Pratt Algorithm）：利用了模式串自身的信息，在匹配失败时通过跳过一些已经匹配过的字符来提高匹配效率。</p>
</li>
<li><p>Boyer-Moore算法（Boyer-Moore Algorithm）：根据模式串最右端的字符在该模式串中的出现情况来确定下一次匹配的起始位置，以此进行快速的匹配。</p>
</li>
<li><p>Rabin-Karp算法（Rabin-Karp Algorithm）：利用哈希函数对文本串和模式串进行哈希计算，通过比较哈希值来尽可能排除不匹配的情况。</p>
</li>
<li><p>Aho-Corasick算法（Aho-Corasick Algorithm）：用于多模式串的匹配，可以同时在一个文本串中查找多个模式串的出现位置。</p>
</li>
</ol>
<h3 id="最优化算法（Optimization-Algorithms）"><a href="#最优化算法（Optimization-Algorithms）" class="headerlink" title="最优化算法（Optimization Algorithms）"></a>最优化算法（Optimization Algorithms）</h3><ol>
<li><p>梯度下降法（Gradient Descent）：用于求解无约束优化问题的迭代优化算法，通过沿着负梯度方向更新参数来最小化目标函数。</p>
</li>
<li><p>共轭梯度法（Conjugate Gradient）：用于求解线性方程组或二次型最小化问题的迭代方法，通过共轭方向的选择和迭代来加速收敛。</p>
</li>
<li><p>牛顿法（Newton’s Method）：一种求解优化问题的迭代算法，通过使用目标函数的二阶导数（Hessian矩阵）和一阶导数（梯度）来逼近解。</p>
</li>
<li><p>雅可比法（Jacobian Method）：用于求解非线性方程组的迭代方法，通过构建雅可比矩阵来逼近解。</p>
</li>
<li><p>遗传算法（Genetic Algorithms）：模拟生物进化过程的优化算法，通过遗传操作（如交叉、变异）和自然选择来搜索最优解。</p>
</li>
<li><p>粒子群优化算法（Particle Swarm Optimization）：模拟鸟群觅食行为的优化算法，通过粒子的位置和速度更新来搜索最优解。</p>
</li>
<li><p>蚁群算法（Ant Colony Optimization）：模拟蚂蚁觅食行为的优化算法，通过蚂蚁在解空间中的移动路径和信息素更新来搜索最优解。</p>
</li>
<li><p>卡尔曼滤波算法（Kalman Filtering）：一种用于估计系统状态的优化算法，可以处理带有噪声和不确定性的动态系统。</p>
</li>
</ol>
<h3 id="哈希算法（Hashing-Algorithms）"><a href="#哈希算法（Hashing-Algorithms）" class="headerlink" title="哈希算法（Hashing Algorithms）"></a>哈希算法（Hashing Algorithms）</h3><ol>
<li><p>MD5（Message Digest Algorithm 5）：MD5是一种广泛使用的哈希算法，生成128位（16字节）的哈希值。尽管MD5在数据完整性校验上表现良好，但由于其容易被碰撞攻击，已经不再被推荐用于安全性要求较高的场景。</p>
</li>
<li><p>SHA-1（Secure Hash Algorithm 1）：SHA-1是一种160位（20字节）的哈希算法，用于生成哈希值。然而，由于SHA-1存在碰撞漏洞，已经不再被推荐作为加密哈希函数。</p>
</li>
<li><p>SHA-256（Secure Hash Algorithm 256-bit）：SHA-256是SHA-2系列中的一种算法，生成256位（32字节）的哈希值。SHA-256在许多领域中得到广泛应用，如密码学、数字证书等。</p>
</li>
<li><p>CRC32（Cyclic Redundancy Check 32）：CRC32是一种循环冗余校验算法，生成32位（4字节）的哈希值。它主要用于错误检测和数据完整性验证，例如在网络通信中常用于校验数据传输的准确性。</p>
</li>
<li><p>MurmurHash：MurmurHash是一种快速非加密型哈希算法，适用于一般的哈希表和哈希集合实现。MurmurHash具有较低的冲突率和计算速度，被广泛应用于分布式系统中的哈希算法。</p>
</li>
<li><p>CityHash：CityHash是一种高效的哈希算法，适用于存储在内存或磁盘中的数据。它在处理大型数据集时表现出色，并且对于随机输入有较低的冲突率。</p>
</li>
<li><p>xxHash（Extremely Fast Hash）：xxHash是一种快速且可靠的哈希算法，具有极高的速度和低的冲突率。它适用于需要高性能哈希算法的场景，如校验和计算、数据完整性检查等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/yangtong.github.io/2023/07/10/database/database/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/yangtong.github.io/2023/07/10/design/design/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/yangtong.github.io/2023/07/10/datastruct/datastruct/</url>
    <content><![CDATA[<blockquote>
<p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
</blockquote>
<span id="more"></span>
<h2 id="概念与定义"><a href="#概念与定义" class="headerlink" title="概念与定义"></a>概念与定义</h2><blockquote>
<p>数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。</p>
</blockquote>
<blockquote>
<p>简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
</blockquote>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><h3 id="数据逻辑结构"><a href="#数据逻辑结构" class="headerlink" title="数据逻辑结构"></a>数据逻辑结构</h3><p>指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括：</p>
<ol>
<li>集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系<br><img src="/yangtong.github.io/images/set.png"></li>
<li>线性结构：数据结构中的元素存在一对一的相互关系<br><img src="/yangtong.github.io/images/array.png"></li>
<li>树形结构：数据结构中的元素存在一对多的相互关系<br><img src="/yangtong.github.io/images/tree.png"></li>
<li>图形结构：数据结构中的元素存在多对多的相互关系<br><img src="/yangtong.github.io/images/graph.png"></li>
</ol>
<h3 id="数据物理结构"><a href="#数据物理结构" class="headerlink" title="数据物理结构"></a>数据物理结构</h3><p>数据的物理结构是数据结构在计算机中的表示（又称映像），它包括数据元素的机内表示和关系的机内表示。由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。</p>
<h3 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h3><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构(也称为存储结构)。</p>
<p>常用的存储结构有顺序存储、链式存储、索引存储和哈希存储等。</p>
<ul>
<li>数据的顺序存储结构的特点是：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系；</li>
<li>非顺序存储的特点是：借助指示元素存储地址的指针表示数据元素之间的逻辑关系。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括线性结构和非线性结构两类。 </p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>简单地说，线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点： </p>
<ol>
<li>线性结构是非空集。 </li>
<li>线性结构有且仅有一个开始结点和一个终端结点。 </li>
<li>线性结构所有结点都最多只有一个直接前驱结点和一个直接后继结点。</li>
</ol>
<p>常见的线性结构：</p>
<ol>
<li>数组（Array）</li>
<li>链表（Linked List）</li>
<li>栈（Stack）</li>
<li>队列（Queue）</li>
<li>双端队列（Deque）</li>
<li>线性表（List）</li>
</ol>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><p>简单地说，非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点： </p>
<ol>
<li>非线性结构是非空集。 </li>
<li>非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点。</li>
</ol>
<p>常见的非线性结构：</p>
<ol>
<li>树（Tree）</li>
<li>图（Graph）</li>
<li>堆（Heap）</li>
<li>散列表（Hash Table）</li>
<li>图论中的树和森林</li>
</ol>
<h2 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 </p>
<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈( Stack)"></a>栈( Stack)</h3><p>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照先进后出或后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 </p>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h3><p>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。 </p>
<h3 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表( Linked List)"></a>链表( Linked List)</h3><p>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 </p>
<h2 id="树形数据结构"><a href="#树形数据结构" class="headerlink" title="树形数据结构"></a>树形数据结构</h2><p>树形数据结构是一种分层的、非线性的数据结构，由节点和边组成。它模拟了现实世界中的树结构，具有一个根节点以及零个或多个子节点。树形数据结构在计算机科学中有广泛的应用，如文件系统、数据库索引、组织结构等。</p>
<h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树( Tree)"></a>树( Tree)</h3><p>树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。 </p>
<h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树可以是空树，也可以只有根节点。</p>
<ul>
<li>完全二叉树（Complete Binary Tree）：除了最后一层外，其他层的节点都要填满，且最后一层从左到右连续填入节点。</li>
<li>满二叉树（Full Binary Tree）：每个节点要么没有子节点，要么有两个子节点。<br>二叉搜索树（Binary Search Tree）：二叉搜索树是一种有序的二叉树，其中任意节点的值都大于其左子树中的所有节点的值，而小于其右子树中的所有节点的值。这使得查找、插入和删除操作的时间复杂度可以在平均情况下达到 O(log n)。</li>
</ul>
<h3 id="AVL-树（Adelson-Velsky-and-Landis-Tree）"><a href="#AVL-树（Adelson-Velsky-and-Landis-Tree）" class="headerlink" title="AVL 树（Adelson-Velsky and Landis Tree）"></a>AVL 树（Adelson-Velsky and Landis Tree）</h3><p>AVL 树是一种自平衡的二叉搜索树，它通过旋转操作来保持树的平衡性。在 AVL 树中，任意节点的左子树和右子树的高度差（平衡因子）不超过 1。</p>
<h3 id="红黑树（Red-Black-Tree）"><a href="#红黑树（Red-Black-Tree）" class="headerlink" title="红黑树（Red-Black Tree）"></a>红黑树（Red-Black Tree）</h3><p>红黑树也是一种自平衡的二叉搜索树，它通过颜色标记来保持树的平衡性。在红黑树中，节点被标记为红色或黑色，并且遵循一些规则，如根节点和叶子节点（NIL 节点）都是黑色，红色节点的子节点必须是黑色等。</p>
<h3 id="B-树（B-Tree）"><a href="#B-树（B-Tree）" class="headerlink" title="B 树（B-Tree）"></a>B 树（B-Tree）</h3><p>B 树是一种多路搜索树，用于处理大量数据的外部存储器操作。它具有多个子节点和一个关键字集合，可以支持高效的插入、删除和查找操作。B 树适用于磁盘或其他随机访问时间较长的存储设备。</p>
<h3 id="字典树（Trie）"><a href="#字典树（Trie）" class="headerlink" title="字典树（Trie）"></a>字典树（Trie）</h3><p>字典树是一种专门为快速查找和插入单词而设计的树结构。每个节点代表一个字符，并且从根节点到叶子节点的路径构成了一个完整的单词。字典树通常用于实现字典、拼写检查和字符串匹配算法。</p>
<h2 id="图形数据结构"><a href="#图形数据结构" class="headerlink" title="图形数据结构"></a>图形数据结构</h2><p>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。</p>
<h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><ul>
<li>无向图是一种图形数据结构，其中的边没有方向或箭头。任意两个节点之间的连接都是双向的。</li>
<li>无向图可以用邻接矩阵或邻接表来表示。邻接矩阵是一个二维数组，用于记录节点之间的连接关系；邻接表是一个链表数组，每个节点都有一个链表存储与其相连的节点。</li>
</ul>
<h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><ul>
<li>有向图是一种图形数据结构，其中的边具有方向或箭头，表示从一个节点指向另一个节点的关系。</li>
<li>有向图也可以用邻接矩阵或邻接表来表示。邻接矩阵是一个二维数组，其中的元素表示边的方向和权重；邻接表是一个链表数组，每个节点都有一个链表存储从该节点出发的边和目标节点。</li>
</ul>
<h3 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h3><ul>
<li>加权图是一种图形数据结构，在边上附加了权重或成本信息。这些权重可以表示距离、时间、容量等。</li>
<li>加权图可以用邻接矩阵或邻接表来表示，与无向图和有向图类似。不同之处在于邻接矩阵的元素表示边的权重，而邻接表中的链表节点包含权重信息。</li>
</ul>
<h2 id="散列（哈希）数据结构"><a href="#散列（哈希）数据结构" class="headerlink" title="散列（哈希）数据结构"></a>散列（哈希）数据结构</h2><h3 id="散列表-Hash"><a href="#散列表-Hash" class="headerlink" title="散列表(Hash)"></a>散列表(Hash)</h3><p>散列（哈希）数据结构是一种通过使用哈希函数将键映射到存储位置的数据结构。它可以高效地插入、查找和删除数据。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/yangtong.github.io/2023/07/10/net/network/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/yangtong.github.io/2023/07/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
